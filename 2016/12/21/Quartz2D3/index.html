<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Quartz 2D（三）样式、阴影、渐变 | Mark Miao</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Quartz 2D（三）样式、阴影、渐变</h1><a id="logo" href="/.">Mark Miao</a><p class="description">Mark’s blog</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Quartz 2D（三）样式、阴影、渐变</h1><div class="post-meta">Dec 21, 2016<span> | </span><span class="category"><a href="/categories/iOS开发/">iOS开发</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pattern"><span class="toc-text">Pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#样式单元格"><span class="toc-text">样式单元格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#着色样式和模板样式"><span class="toc-text">着色样式和模板样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绘制着色样式"><span class="toc-text">绘制着色样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绘制模板样式"><span class="toc-text">绘制模板样式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阴影"><span class="toc-text">阴影</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渐变"><span class="toc-text">渐变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CGGradient"><span class="toc-text">CGGradient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CGShading"><span class="toc-text">CGShading</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><p>Pattern可翻译为样式、模型。类似于iOS中自定义的view，可以重复多次把自定义的view添加到控制器的view上。样式(Pattern)是绘制操作的一个序列，可以重复的绘制到一个图形上下文上。</p>
<a id="more"></a>
<h3 id="样式单元格"><a href="#样式单元格" class="headerlink" title="样式单元格"></a>样式单元格</h3><p>样式单元格是样式的基本组件，在创建的时候就要定义单元格的边界，并在这个范围内进行绘制。在图形上下文上绘制单元格时，可以随意指定两个单元格之间上下左右间距，也可以指定负数，单元格重合而已。像极了添加view控件。</p>
<h3 id="着色样式和模板样式"><a href="#着色样式和模板样式" class="headerlink" title="着色样式和模板样式"></a>着色样式和模板样式</h3><p>着色样式是有固定颜色的，在创建样式单元格的时候就指定其颜色了，跟绘制流程没有关系。</p>
<p>模板样式即为非着色样式，在创建样式单元格的时候只指定了形状，并没有指定颜色，在绘制过程中指定颜色。</p>
<p>在Quartz 2D中可以使用这两种样式实现样式绘图，将创建好的样式绘制到page上的过程称为平铺，有三种平铺选项：1、没有失真，2、最小的失真的恒定间距，3、恒定间距。</p>
<h3 id="绘制着色样式"><a href="#绘制着色样式" class="headerlink" title="绘制着色样式"></a>绘制着色样式</h3><p>绘制着色样式一般需要下面几步：1、设置样式单元格的回调函数，2、设置着色模式单元格，3、绘制操作。下面是绘制着色样式的示例代码和运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    [super drawRect:rect];</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    clorePatternPaingting(context, CGRectMake(0, 0, 300, 500));</div><div class="line">&#125;</div><div class="line">void clorePatternPaingting(CGContextRef context, CGRect rect) &#123;</div><div class="line">    CGColorSpaceRef patternSpace = CGColorSpaceCreatePattern(NULL);</div><div class="line">    CGContextSetFillColorSpace(context, patternSpace);</div><div class="line">    CGColorSpaceRelease(patternSpace);</div><div class="line">    static const CGPatternCallbacks call = &#123;0, &amp;drawPattern, NULL&#125;;</div><div class="line">    CGPatternRef pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 30, 30), CGAffineTransformIdentity, 30, 30, kCGPatternTilingConstantSpacing, true, &amp;call);</div><div class="line">    CGFloat alpha = 1.0;</div><div class="line">    CGContextSetFillPattern(context, pattern, &amp;alpha);</div><div class="line">    CGPatternRelease(pattern);</div><div class="line">    CGContextFillRect(context, rect);</div><div class="line">&#125;</div><div class="line">void drawPattern(void *info, CGContextRef context) &#123;</div><div class="line">    CGContextSetRGBFillColor(context, 1, 0, 0, 1);</div><div class="line">    CGContextFillRect(context, CGRectMake(0, 0, 10, 10));</div><div class="line">    CGContextSetRGBFillColor(context, 0, 1, 0, 1);</div><div class="line">    CGContextFillRect(context, CGRectMake(10, 0, 10, 10));</div><div class="line">    CGContextSetRGBFillColor(context, 0, 0, 1, 1);</div><div class="line">    CGContextFillRect(context, CGRectMake(0, 10, 10, 10));</div><div class="line">    CGContextSetRGBFillColor(context, 0.5, 0, 0.5, 1);</div><div class="line">    CGContextFillRect(context, CGRectMake(10, 10, 10, 10));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161220-0.png" alt="绘制着色模式的运行结果"></p>
<p><strong>代码解释：</strong></p>
<p>上述代码块中第三个函数<code>drawPattern</code>的作用就是第1步：设置样式单元格的回调函数。参数<code>info</code>:是指向模式相关数据的指针，可以传<code>NULL</code>。<code>context</code>:是图形上下文。在该函数中指定了每个颜色块的大小和填充色。因为是着色样式，所以指定填充色。</p>
<p>第二个函数，也是在<code>drawRect</code>方法中调用的函数<code>clorePatternPaingting</code>，执行了第2步:设置着色模式单元格和第3步:绘制操作。下面对每块代码进行解释：</p>
<p><strong>清空基本颜色空间：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGColorSpaceRef patternSpace = CGColorSpaceCreatePattern(NULL);</div><div class="line">CGContextSetFillColorSpace(context, patternSpace);</div><div class="line">CGColorSpaceRelease(patternSpace);</div></pre></td></tr></table></figure>
<p>因为我们要使用着色样式里面的颜色，所以清空基本颜色空间，以确保着色样式上的颜色能显示。可以试一下把这段代码注释的结果，绘制着色样式的空间为黑色，因为基本颜色空间没清空也没着色，所以呈黑色。</p>
<p><strong>设置着色模式单元格：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static const CGPatternCallbacks call = &#123;0, &amp;drawPattern, NULL&#125;;</div><div class="line">CGPatternRef pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 30, 30), CGAffineTransformIdentity, 30, 30, kCGPatternTilingConstantSpacing, true, &amp;call);</div></pre></td></tr></table></figure>
<p>模式单元格的信息保存在<code>CGPatternRef</code>类型的<code>CGPattern</code>对象中，使用<code>CGPatternCreate</code>创建该对象。需要传入的参数依次解释为：</p>
<ol>
<li>info：是一个指针，指向我们要传递给绘制回调函数的数据。这里传的是<code>NULL</code></li>
<li>bound：指定模式单元格的大小</li>
<li>matrix：指定模式矩阵，它将模式坐标系统映射到图形上下文的默认坐标系统。如果希望两个坐标系统是一样的，则可以使用单位矩阵。</li>
<li>xStep, yStep：指定单元格之间的水平和竖直间距。</li>
<li>tiling：平铺模式，可以是kCGPatternTilingNoDistortion、kCGPatternTilingConstantSpacingMinimalDistortion、kCGPatternTilingConstantSpacing</li>
<li>isColored：指定模式单元格是着色模式(true)还是模板模式(false)</li>
<li>callbacks：是一个指向CGPatternCallbacks结构体的指针。格式如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct CGPatternCallbacks &#123;</div><div class="line">    unsigned int version;</div><div class="line">    CGPatternDrawPatternCallback __nullable drawPattern;</div><div class="line">    CGPatternReleaseInfoCallback __nullable releaseInfo;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>version</code>一般设置为<code>0</code>，<code>drawPattern</code>是指向设置样式单元格的回调函数，<code>releaseInfo</code>是指向回调函数，释放CGPattern对象时调用，以释放存储在我们传递给绘制回调的info参数中的数据。如果在这个参数中没有传递任何数据传<code>NULL</code>。</p>
<p>所以<code>CGPatternCallbacks</code>结构体定义为<code>static const CGPatternCallbacks call = {0, &amp;drawPattern, NULL};</code></p>
<p><strong>绘制着色样式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CGFloat alpha = 1.0;</div><div class="line">CGContextSetFillPattern(context, pattern, &amp;alpha);</div><div class="line">CGPatternRelease(pattern);</div><div class="line">CGContextFillRect(context, rect);</div></pre></td></tr></table></figure>
<p>调用函数<code>CGContextSetFillPattern</code>使用着色样式进行填充操作，或者调用函数<code>CGContextSetStrokePattern</code>进行描边操作。需要指定着色样式在填充或描边过程的透明度。</p>
<p>样式使用完毕后需要释放，调用函数：<code>CGPatternRelease</code></p>
<p>将定义的着色样式使用函数<code>CGContextFillRect</code>填充到指定<code>rect</code>的矩形中。</p>
<p>这一系列操作都放到函数<code>clorePatternPaingting</code>内，在<code>drawRect</code>方法中直接调用该函数即可完成着色样式的定义和绘制。</p>
<h3 id="绘制模板样式"><a href="#绘制模板样式" class="headerlink" title="绘制模板样式"></a>绘制模板样式</h3><p>绘制模板样式的步骤和绘制着色样式的一样：1、设置样式单元格的回调函数，2、设置模板模式单元格，3、绘制操作。下面是绘制模板样式的示例代码和运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    [super drawRect:rect];</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    stencilPatternPaingting(context, CGRectMake(0, 0, 300, 500));</div><div class="line">&#125;</div><div class="line">void stencilPatternPaingting(CGContextRef context, CGRect rect) &#123;</div><div class="line">    CGColorSpaceRef baseSpace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    CGColorSpaceRef patternSpace = CGColorSpaceCreatePattern(baseSpace);</div><div class="line">    CGContextSetFillColorSpace(context, patternSpace);</div><div class="line">    CGColorSpaceRelease(patternSpace);</div><div class="line">    CGColorSpaceRelease(baseSpace);</div><div class="line">    static const CGPatternCallbacks cell = &#123;0, &amp;drawStencilPattern, NULL&#125;;</div><div class="line">    CGPatternRef pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 30, 30), CGAffineTransformIdentity, 40, 40, kCGPatternTilingConstantSpacing, false, &amp;cell);</div><div class="line">    static const CGFloat color[] = &#123;1, 0, 0, 1&#125;;</div><div class="line">    CGContextSetFillPattern(context, pattern, color);</div><div class="line">    CGPatternRelease(pattern);</div><div class="line">    CGContextFillRect(context, rect);</div><div class="line">&#125;</div><div class="line">void drawStencilPattern(void *info, CGContextRef context) &#123;</div><div class="line">    CGContextAddEllipseInRect(context, CGRectMake(0, 0, 30, 30));</div><div class="line">    CGContextFillPath(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161220-1.png" alt="绘制模板样式的运行结果"></p>
<p>代码解释参考上文中着色样式的代码解释。区别1是用下述代码设置样式单元格的颜色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static const CGFloat color[] = &#123;1, 0, 0, 1&#125;;</div><div class="line">CGContextSetFillPattern(context, pattern, color);</div></pre></td></tr></table></figure>
<p>区别2是<code>CGPatternCreate</code>函数中传的参数是<code>false</code>。</p>
<h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>阴影有三个属性：x偏移量，y偏移量，模糊度</p>
<p>阴影通过函数<code>CGContextSetShadow</code>设置，指定图形上下文、x偏移量、y偏移量、模糊度。设置阴影后，绘制的对象都会有阴影，阴影的色值为0.3透明度的黑色，颜色RGBA值为{0, 0, 0, 0.3}。</p>
<p>也可以是使用函数<code>CGContextSetShadowWithColor</code>设置彩色阴影。</p>
<p>在调用<code>CGContextSetShadow</code>或<code>CGContextSetShadowWithColor</code>之前保存图形状态，可以通过恢复图形状态来关闭阴影。或者设置阴影颜色为<code>NULL</code>关闭阴影。</p>
<p>分别设置彩色阴影和普通阴影：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextSaveGState(context);</div><div class="line">CGContextSetShadowWithColor(context, CGSizeMake(10, 10), 2, [UIColor redColor].CGColor);</div><div class="line">CGContextSetRGBFillColor (context, 0, 1, 0, 1);</div><div class="line">CGContextAddEllipseInRect(context, CGRectMake(40, 40, 100, 100));</div><div class="line">CGContextFillPath(context);</div><div class="line">CGContextSetShadow(context, CGSizeMake(10, 10), 2);</div><div class="line">CGContextFillRect(context, CGRectMake(200, 40, 100, 100));</div><div class="line">CGContextRestoreGState(context);</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161220-2.png" alt="圆形的红色阴影和矩形的灰色阴影"></p>
<p>x偏移量正值在图形右边，负值在图形左边。y偏移量和坐标有关，在iOS中，UIKit坐标系y轴和Quartz 2D坐标系y轴相反，所以如果是由UIKit创建的图形上下文则正值在图形下面，负值在图形上面。macOS的坐标系和Quartz 2D坐标系一样，所以正值在图形上面，负值在图形下面。阴影绘制不受CTM影响。</p>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>可以使用函数<code>CGShadingRef</code>和<code>CGGradientRef</code>创建渐变。渐变分为轴向渐变和径向渐变。渐变的颜色变化有很多，可以是一种颜色到另一种颜色过度，也可以是多种颜色依次过度变化，还有是一种颜色的透明度<code>alpha</code>变化，但是这种无法绘制到PDF上，无法打印。</p>
<p><code>CGShading</code>和<code>CGGradient</code>的区别：</p>
<table>
<thead>
<tr>
<th style="text-align:left">CGGradient</th>
<th style="text-align:left">CGShading</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">可以使用同一对象绘制轴向和径向梯度</td>
<td style="text-align:left">需要创建单独的对象的轴向和径向梯度</td>
</tr>
<tr>
<td style="text-align:left">在绘图时设置渐变的几何体</td>
<td style="text-align:left">在对象创建时间设置渐变的几何体</td>
</tr>
<tr>
<td style="text-align:left">Quartz计算梯度中每个点的颜色</td>
<td style="text-align:left">需要提供一个回调函数，用来计算渐变中每个点的颜色</td>
</tr>
<tr>
<td style="text-align:left">可以定义两个以上的位置和颜色</td>
<td style="text-align:left">需要设计回调，使用两个以上的位置和颜色</td>
</tr>
</tbody>
</table>
<h3 id="CGGradient"><a href="#CGGradient" class="headerlink" title="CGGradient"></a>CGGradient</h3><p>使用CGGradient创建渐变。</p>
<ol>
<li>首先调用函数<code>CGGradientCreateWithColorComponents</code>创建<code>CGGradient</code>对象，参数含义分别是：颜色空间、颜色数组（采用RGBA颜色）、位置数组（0.0-1.0之间的数值，0.0为轴线起点，1.0为轴线终点。传递NULL默认0为起始位置，1为终点位置，相当于{0.0, 1.0}）、数组中元素个数。</li>
<li>调用<code>CGContextDrawLinearGradient</code>函数绘制轴向渐变或<code>CGContextDrawRadialGradient</code>函数绘制径向渐变，参数含义分别是：图形上下文、<code>CGGradient</code>对象、起始位置、终止位置、绘图选项。</li>
<li>绘制完毕后，释放颜色空间和<code>CGGradient</code>对象。</li>
</ol>
<p>绘制轴向渐变:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGFloat compoents[] = &#123;1,0,1,1, 0.3,0.5,1,1.0&#125;;</div><div class="line">CGFloat locations[] = &#123;0.0, 1.0&#125;;</div><div class="line">CGColorSpaceRef colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);</div><div class="line">CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, compoents, locations, 2);</div><div class="line">CGContextDrawLinearGradient(context, gradient, CGPointMake(0, 0), CGPointMake(0, 100), kCGGradientDrawsBeforeStartLocation);</div><div class="line">CGColorSpaceRelease(colorSpace);</div><div class="line">CGGradientRelease(gradient);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161221-0.png" alt="使用CGGradient绘制轴向渐变"></p>
<p>绘制径向渐变:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGFloat compoents[] = &#123;1,0,1,1, 0.3,0.5,1,1.0&#125;;</div><div class="line">CGFloat locations[] = &#123;0.0, 1.0&#125;;</div><div class="line">CGColorSpaceRef colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);</div><div class="line">CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, compoents, locations, 2);</div><div class="line">CGContextDrawRadialGradient(context, gradient, CGPointMake(200, 50), 20, CGPointMake(200, 400), 70, kCGGradientDrawsAfterEndLocation);</div><div class="line">CGColorSpaceRelease(colorSpace);</div><div class="line">CGGradientRelease(gradient);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161221-1.png" alt="使用CGGradient绘制径向渐变"></p>
<h3 id="CGShading"><a href="#CGShading" class="headerlink" title="CGShading"></a>CGShading</h3><p>绘制轴向渐变需要以下步骤：</p>
<ol>
<li>设置 CGFunction 对象来计算颜色值</li>
<li>创建轴向渐变的 CGShading 对象</li>
<li>裁减上下文</li>
<li>使用 CGShading 对象来绘制轴向渐变</li>
<li>释放对象</li>
</ol>
<p>绘制轴向渐变完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    [super drawRect:rect];</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    CGFunctionRef functionObj = getFunction(colorspace);</div><div class="line">    CGShadingRef shading = CGShadingCreateAxial(colorspace, CGPointMake(0, 0.5), CGPointMake(1, 0.5), functionObj, false, false);</div><div class="line">    CGAffineTransform myTransform = CGAffineTransformMakeScale(100, 100);</div><div class="line">    CGContextConcatCTM (context, myTransform);</div><div class="line">    CGContextSaveGState (context);</div><div class="line">    CGContextBeginPath(context);</div><div class="line">    CGContextAddArc(context,  .5, .5, .3, 0, M_PI, 0);</div><div class="line">    CGContextClosePath(context);</div><div class="line">    CGContextClip(context);</div><div class="line">    CGContextDrawShading(context, shading);</div><div class="line">    CGShadingRelease(shading);</div><div class="line">    CGColorSpaceRelease(colorspace);</div><div class="line">    CGFunctionRelease(functionObj);</div><div class="line">    CGContextRestoreGState (context);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static CGFunctionRef getFunction(CGColorSpaceRef colorspace) &#123;</div><div class="line">    size_t numComponents = 1 + CGColorSpaceGetNumberOfComponents(colorspace);</div><div class="line">    CGFloat input_value_range[] = &#123;0, 1&#125;;</div><div class="line">    CGFloat output_value_range[] = &#123;0, 1, 0, 0, 0,0,1,1&#125;;</div><div class="line">    CGFunctionCallbacks callbacks = &#123;0, &amp;calculateShadingValues, NULL&#125;;</div><div class="line">    return CGFunctionCreate((void *) numComponents, 1, input_value_range, numComponents, output_value_range, &amp;callbacks);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void calculateShadingValues(void *info, const CGFloat *in, CGFloat *out) &#123;</div><div class="line">    CGFloat v;</div><div class="line">    size_t k, compoents;</div><div class="line">    static const CGFloat c[] = &#123;1,0,0.5,1&#125;;</div><div class="line">    compoents = (size_t)info;</div><div class="line">    v = *in;</div><div class="line">    for (k = 0; k &lt; compoents - 1; k ++)</div><div class="line">        *out ++ = c[k] * v;</div><div class="line">    *out++ = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161221-2.png" alt="使用CGShading绘制轴向渐变"></p>
<p>绘制径向渐变，需要以下步骤：</p>
<ol>
<li>设置 CGFunction 对象来计算颜色值</li>
<li>创建径向渐变的 CGShading 对象</li>
<li>使用 CGShading 对象来绘制径向渐变</li>
<li>释放对象</li>
</ol>
<p>绘制径向渐变完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    [super drawRect:rect];</div><div class="line"></div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    </div><div class="line">    CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    CGFunctionRef functionObj = getFunction(colorspace);</div><div class="line">    CGShadingRef shading = CGShadingCreateRadial(colorspace, CGPointMake(0.25, 0.3), 0.1, CGPointMake(0.7, 0.7), 0.25, functionObj, false, false);</div><div class="line"></div><div class="line">    CGAffineTransform myTransform = CGAffineTransformMakeScale(100, 100);</div><div class="line">    CGContextConcatCTM (context, myTransform);</div><div class="line">    CGContextSaveGState (context);</div><div class="line">    </div><div class="line">    CGContextClipToRect (context, CGRectMake(0, 0, 1, 1));</div><div class="line">    CGContextSetRGBFillColor (context, 1, 1, 1, 1);</div><div class="line">    CGContextFillRect (context, CGRectMake(0, 0, 1, 1));</div><div class="line">    </div><div class="line">    CGContextDrawShading(context, shading);</div><div class="line">    </div><div class="line">    CGShadingRelease(shading);</div><div class="line">    CGColorSpaceRelease(colorspace);</div><div class="line">    CGFunctionRelease(functionObj);</div><div class="line">    CGContextRestoreGState (context);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static CGFunctionRef getFunction(CGColorSpaceRef colorspace) &#123;</div><div class="line">    size_t numComponents = 1 + CGColorSpaceGetNumberOfComponents(colorspace);</div><div class="line">    </div><div class="line">    CGFloat input_value_range[] = &#123;0, 1&#125;;</div><div class="line">    CGFloat output_value_range[] = &#123;0, 1, 0, 0, 0,0,1,1&#125;;</div><div class="line">    </div><div class="line">    CGFunctionCallbacks callbacks = &#123;0, &amp;calculateShadingValues, NULL&#125;;</div><div class="line">    return CGFunctionCreate((void *) numComponents, 1, input_value_range, numComponents, output_value_range, &amp;callbacks);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">static void calculateShadingValues(void *info, const CGFloat *in, CGFloat *out) &#123;</div><div class="line">    </div><div class="line">    size_t k, compoents;</div><div class="line">    double frequency[] = &#123;55, 220, 110, 0&#125;;</div><div class="line">    compoents = (size_t)info;</div><div class="line">    for (k = 0; k &lt; compoents - 1; k ++)</div><div class="line">        *out++ = (1 + sin(*in * frequency[k])) / 2;</div><div class="line">    *out++ = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161221-3.png" alt="使用CGShading绘制径向渐变"></p>
<hr>
<p>参考文章：<a href="http://southpeak.github.io/categories/translate/" target="_blank" rel="external">南峰子翻译的Quartz2D编程指南</a></p>
</div><iframe src="/donate/?AliPayQR=http://oalg33nuc.bkt.clouddn.com/WechatIMG766.jpeg&amp;WeChatQR=http://oalg33nuc.bkt.clouddn.com/WechatIMG767.jpeg&amp;GitHub=https://github.com/mxdios&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/Quartz2D/">Quartz2D</a></div><div class="post-nav"><a href="/2016/12/28/私有API的使用/" class="pre">私有API的使用</a><a href="/2016/12/19/Quartz2D2/" class="next">Quartz 2D（二）颜色和颜色空间、变换</a></div><div id="uyan_frame"></div><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2140361"></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://markmiao.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTML5/">HTML5</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS开发/">iOS开发</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/macOS开发/">macOS开发</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/程序人生/">程序人生</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/记事/">记事</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/RxSwift/" style="font-size: 15px;">RxSwift</a> <a href="/tags/总结/" style="font-size: 15px;">总结</a> <a href="/tags/Quartz2D/" style="font-size: 15px;">Quartz2D</a> <a href="/tags/swift/" style="font-size: 15px;">swift</a> <a href="/tags/文档/" style="font-size: 15px;">文档</a> <a href="/tags/游记/" style="font-size: 15px;">游记</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/iOS10/" style="font-size: 15px;">iOS10</a> <a href="/tags/ipa/" style="font-size: 15px;">ipa</a> <a href="/tags/macOS/" style="font-size: 15px;">macOS</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/应用/" style="font-size: 15px;">应用</a> <a href="/tags/短文/" style="font-size: 15px;">短文</a> <a href="/tags/AppStore/" style="font-size: 15px;">AppStore</a> <a href="/tags/静态库/" style="font-size: 15px;">静态库</a> <a href="/tags/HTML5/" style="font-size: 15px;">HTML5</a> <a href="/tags/小程序/" style="font-size: 15px;">小程序</a> <a href="/tags/APP开发/" style="font-size: 15px;">APP开发</a> <a href="/tags/外包/" style="font-size: 15px;">外包</a> <a href="/tags/碎碎念/" style="font-size: 15px;">碎碎念</a> <a href="/tags/私有API/" style="font-size: 15px;">私有API</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/22/tucaoappshenhe/">吐槽苹果APP审核</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/07/macosdevelnote1/">macOS开发笔记(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/01/duoyuyan/">APP国际化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/26/sycjlxj/">十一长假旅行记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/24/rxswiftlearn1/">RxSwift学习笔记(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/13/apidoc/">用apiDoc写接口文档</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/12/talkingtoapple/">被苹果爸爸完全碾压的通话记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/03/mymacbooks/">那些年用过的Mac</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/27/macosapprejected/">macOS应用上架被拒</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/26/stenonote/">速记 - 快速记录每一段文字</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">Mark Miao.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3a6b5f9b69c85227a288646d3403af6e";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>