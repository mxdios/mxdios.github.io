<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mark Miao</title>
  
  <subtitle>Mark’s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://markmiao.com/"/>
  <updated>2020-05-08T07:21:50.140Z</updated>
  <id>http://markmiao.com/</id>
  
  <author>
    <name>Mark</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mRemind - 提醒你每一件小事</title>
    <link href="http://markmiao.com/2020/05/08/mremind/"/>
    <id>http://markmiao.com/2020/05/08/mremind/</id>
    <published>2020-05-08T08:54:02.000Z</published>
    <updated>2020-05-08T07:21:50.140Z</updated>
    
    <content type="html"><![CDATA[<p>mRemind 是一款专为 macOS 设计的待办提醒应用，操作简单而功能强大。</p><a id="more"></a><p>当我们专注于工作或某项任务时，往往会忽略计划好的其他事情。当想起时，已经错过了最佳时间。</p><p>mRemind 是为解决这类烦恼而生的，它能帮你记录待办事项。当你把任务交给 mRemind 记录后，你便可以专注于当下工作，时间到了，mRemind 会提醒你的待办事项该做了。</p><p>mRemind，让你保持专注不遗漏。</p><p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/mremindappstore.png" alt="mRemind"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>在状态栏中一键添加待办提醒</li><li>查看添加的所有待办提醒</li><li>时间到了，通知栏提醒待办</li><li>在消息通知上可一键操作完成</li></ul><h2 id="mRemind基础功能"><a href="#mRemind基础功能" class="headerlink" title="mRemind基础功能"></a>mRemind基础功能</h2><ul><li><p>添加不超过3条的mRemind提醒</p></li><li><p>5/10/20/30分钟的倒计时提醒</p></li><li><p>全部提醒的完成/删除操作</p></li><li><p>其他 mRemind 提供的服务</p></li></ul><h2 id="mRemind高级版"><a href="#mRemind高级版" class="headerlink" title="mRemind高级版"></a>mRemind高级版</h2><ul><li><p>添加多条mRemind提醒</p></li><li><p>日期选择功能，可随意指定未来时间</p></li><li><p>自定义时间功能，可设置任意倒计时</p></li></ul><h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><p>订阅 mRemind高级版 解锁全部功能，您可自由选择月度订阅或年度订阅：</p><ul><li><p>按月订阅：¥6.00/月</p></li><li><p>按年订阅：¥60.00/年（推荐，约节省17%）</p></li></ul><p>确认订阅后，将向您的Apple ID账户收款。除非您在当前计费周期结束前至少24小时取消订单，否则项目会自动续订，您的账户将在当前计费周期结束前24小时内收取续订费用。当前订阅被激活后不可取消。购买后，您可在App Store的账户设置中管理您的订阅。</p><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>我们欢迎您对 mRemind 提出意见或建议，请邮件联系 <a href="mailto:i@markmiao.com">i@markmiao.com</a> ，我们会认真对待每一个反馈，将 mRemind 做的更好。</p><hr><p>隐私政策：<a href="https://markmiao.com/2018/12/25/yinsizhengce/">https://markmiao.com/2018/12/25/yinsizhengce/</a></p><p>使用条款：<a href="https://markmiao.com/2018/12/26/shiyongtiaokuan/">https://markmiao.com/2018/12/26/shiyongtiaokuan/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mRemind 是一款专为 macOS 设计的待办提醒应用，操作简单而功能强大。&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS开发" scheme="http://markmiao.com/categories/macOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="应用" scheme="http://markmiao.com/tags/%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>macOS开发笔记(2)</title>
    <link href="http://markmiao.com/2020/04/29/macosdevelnote2/"/>
    <id>http://markmiao.com/2020/04/29/macosdevelnote2/</id>
    <published>2020-04-28T22:05:19.000Z</published>
    <updated>2020-04-29T02:00:28.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NSToolbar"><a href="#NSToolbar" class="headerlink" title="NSToolbar"></a>NSToolbar</h2><p>常用<code>NSToolbar</code>开发偏好设置界面，在xib中可以直接拖<code>NSToolbar</code>到<code>Window</code>中，可以自定义图片文字。</p><a id="more"></a><p>勾选<code>Behavior</code>中的<code>Selectable</code>，<code>NSToolbarItem</code>是可选中样式的。</p><p>设置某个<code>NSToolbarItem</code>默认选中，需要先设置默认选中的<code>NSToolbarItem</code>的<code>Identifier</code>，使用下面代码完成默认选中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolbar.selectedItemIdentifier = <span class="type">NSToolbarItem</span>.<span class="type">Identifier</span>(rawValue: <span class="string">"id"</span>)</span><br></pre></td></tr></table></figure><h2 id="Window按钮"><a href="#Window按钮" class="headerlink" title="Window按钮"></a>Window按钮</h2><p>控制window左上角关闭、最小化、最大化按钮的是否可用，以及显示隐藏。</p><p>可以在xib中勾选<code>Controls</code>中的<code>Close</code>、<code>Minimize</code>、<code>Resize</code>，控制按钮是否可用。或者使用代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.window?.standardWindowButton(.closeButton)?.isEnabled = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>使用代码可以隐藏按钮：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.window?.standardWindowButton(.miniaturizeButton)?.isHidden = <span class="literal">true</span></span><br><span class="line"><span class="keyword">self</span>.window?.standardWindowButton(.zoomButton)?.isHidden = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="NSButton"><a href="#NSButton" class="headerlink" title="NSButton"></a>NSButton</h2><p>设置按钮为蓝色背景，需要设置按钮的<code>Key Equivalent</code>为回车键</p><h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>macOS中<code>Label</code>继承自<code>NSTextField</code>，有两种：<code>Label</code> 和<code>Wrapping Label</code></p><p><code>Wrapping Label</code>为多行Label，无需设置Line Break为<code>Character Wrap</code></p><p>使用<code>Label</code> 设置Line Break也无法折行显示。</p><p>当<code>Label</code>仅作为文字显示时，鼠标移上不变光标显示，需要设置Action为<code>Sent On End Editing</code></p><h2 id="NSTableCellView"><a href="#NSTableCellView" class="headerlink" title="NSTableCellView"></a>NSTableCellView</h2><p>移除默认的Cell点击变蓝，设置NSTableView的<code>selectionHighlightStyle</code> :</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.selectionHighlightStyle = .<span class="keyword">none</span></span><br></pre></td></tr></table></figure><p>NSTableCellView根据存放的Label内容自适应高度，OSX 10.13以后，在xib中设置正确的约束，设置Row自适应高度即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.usesAutomaticRowHeights = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>无需指定默认高度<code>rowHeight</code>，亦无需实现row高度的代理方法<code>func tableView(_ tableView: NSTableView, heightOfRow row: Int) -&gt; CGFloat</code></p><p><a href="https://www.itranslater.com/qa/details/2325926279662535680" target="_blank" rel="noopener">基于视图的NSTableView，其行具有动态高度</a></p><h2 id="NSTextField"><a href="#NSTextField" class="headerlink" title="NSTextField"></a>NSTextField</h2><p>限制输入框<code>NSTextField</code>的输入内容，仅允许输入数字，需要自定义<code>Formatter</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Cocoa</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnlyIntegerValueFormatter</span>: <span class="title">NumberFormatter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">isPartialStringValid</span><span class="params">(<span class="number">_</span> partialString: String, newEditingString newString: AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?, errorDescription error: AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> partialString.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 禁止输入非数字 &amp;&amp; 首位不能为0 &amp;&amp; 最多输入3位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>(partialString) != <span class="literal">nil</span> &amp;&amp; <span class="type">Int</span>(partialString)! &gt; <span class="number">0</span> &amp;&amp; partialString.<span class="built_in">count</span> &lt; <span class="number">4</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;NSToolbar&quot;&gt;&lt;a href=&quot;#NSToolbar&quot; class=&quot;headerlink&quot; title=&quot;NSToolbar&quot;&gt;&lt;/a&gt;NSToolbar&lt;/h2&gt;&lt;p&gt;常用&lt;code&gt;NSToolbar&lt;/code&gt;开发偏好设置界面，在xib中可以直接拖&lt;code&gt;NSToolbar&lt;/code&gt;到&lt;code&gt;Window&lt;/code&gt;中，可以自定义图片文字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS开发" scheme="http://markmiao.com/categories/macOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="macOS" scheme="http://markmiao.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Flutter笔记5-初探Widget布局</title>
    <link href="http://markmiao.com/2020/03/19/flutter5/"/>
    <id>http://markmiao.com/2020/03/19/flutter5/</id>
    <published>2020-03-19T06:30:50.000Z</published>
    <updated>2020-03-19T07:26:32.114Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter核心思想：用Widget构建UI界面、万物皆Widget。</p><p>Flutter渲染思想：Widget描述UI，当Widget的状态改变，会重新构建UI。flutter会比对前后两者的差异，确定底层渲染树的最小更改。</p><a id="more"></a><h2 id="初探Widget布局"><a href="#初探Widget布局" class="headerlink" title="初探Widget布局"></a>初探Widget布局</h2><ul><li>Text：带样式的文本</li><li>Row和Column：水平/垂直布局</li><li>Container：矩形控件</li></ul><p>使用这些常用的Widget自定义一个导航栏样式：</p><p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/flutterdemo20200319100137.png" alt="示例"></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>对整个页面进行分解，分为导航栏和展示内容两部分，这两者垂直排布，所以使用<code>Column</code>，导航栏内控件水平排布，所以用<code>Row</code>。</p><p>先自定义导航栏，导航栏分四部分：矩形背景、标题、两个icon。矩形背景可以用<code>Container</code>，标题用<code>Text</code>, 标题与icon的布局用<code>Row</code>实现。自定义导航栏，标题和icon要求外部传值。</p><p>因为内容不变，导航栏使用<code>StatelessWidget</code>，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAppBar</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  MyAppBar(&#123;<span class="keyword">this</span>.titleStr, <span class="keyword">this</span>.leftIcon, <span class="keyword">this</span>.rightIcon&#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> titleStr;<span class="comment">//标题</span></span><br><span class="line">  <span class="keyword">final</span> IconData leftIcon;<span class="comment">//左边的icon</span></span><br><span class="line">  <span class="keyword">final</span> IconData rightIcon;<span class="comment">//右边的icon</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(<span class="comment">//导航栏矩形背景</span></span><br><span class="line">      height: <span class="number">100</span>,</span><br><span class="line">      padding: EdgeInsets.only(top:<span class="number">30</span>),</span><br><span class="line">      color: Colors.red,</span><br><span class="line">      child: Row(<span class="comment">//采用横向的Row布局</span></span><br><span class="line">        children: &lt;Widget&gt; [</span><br><span class="line">          IconButton(</span><br><span class="line">            icon: Icon(leftIcon, color: Colors.white,),</span><br><span class="line">            onPressed: <span class="keyword">null</span>,<span class="comment">//点击事件</span></span><br><span class="line">          ),</span><br><span class="line">          Expanded(<span class="comment">//标题填充展示</span></span><br><span class="line">            child: Text(</span><br><span class="line">              titleStr,</span><br><span class="line">              style: Theme.of(context).primaryTextTheme.title,<span class="comment">//标题的style</span></span><br><span class="line">              textAlign: TextAlign.center,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          IconButton(</span><br><span class="line">            icon: Icon(rightIcon, color: Colors.white,),</span><br><span class="line">            onPressed: <span class="keyword">null</span>,</span><br><span class="line">          ),</span><br><span class="line">        ]</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展示内容部分比较简单，文本填充，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContent</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  MyContent(&#123;<span class="keyword">this</span>.contentStr&#125;);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> contentStr;<span class="comment">//显示内容外部传参</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Expanded(<span class="comment">//填充显示</span></span><br><span class="line">      child: Center(</span><br><span class="line">        child: Text(</span><br><span class="line">          contentStr,</span><br><span class="line">          style: TextStyle(</span><br><span class="line">            color: Colors.red,</span><br><span class="line">            fontSize: <span class="number">50</span>,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两部分组合在一个Widget中，使用<code>Column</code>布局，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStateless</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Material(</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          MyAppBar(titleStr: <span class="string">'Hello World'</span>, leftIcon: Icons.menu, rightIcon: Icons.track_changes),<span class="comment">//导航栏，传递参数</span></span><br><span class="line">          MyContent(contentStr: <span class="string">'Hello Flutter'</span>),<span class="comment">//显示内容部分，传递参数</span></span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>demo的完整代码见工程中的 <a href="https://github.com/mxdios/flutter-demo" target="_blank" rel="noopener">flutter_widgets</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flutter核心思想：用Widget构建UI界面、万物皆Widget。&lt;/p&gt;
&lt;p&gt;Flutter渲染思想：Widget描述UI，当Widget的状态改变，会重新构建UI。flutter会比对前后两者的差异，确定底层渲染树的最小更改。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://markmiao.com/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://markmiao.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter笔记4-UI框架</title>
    <link href="http://markmiao.com/2020/03/18/flutter4/"/>
    <id>http://markmiao.com/2020/03/18/flutter4/</id>
    <published>2020-03-18T06:30:50.000Z</published>
    <updated>2020-03-18T06:32:08.613Z</updated>
    
    <content type="html"><![CDATA[<p>flutter是跨平台的UI框架，非UI层面的任务，通过插件机制与iOS或Android通讯。</p><a id="more"></a><h2 id="UIView-与-Widget"><a href="#UIView-与-Widget" class="headerlink" title="UIView 与 Widget"></a>UIView 与 Widget</h2><p>UIView是iOS中最常用的视图控件，Widget并不完全等同于UIView，它可以被称为“声明和构造 UI 的方法”。UIView是可变的，直接对UIView修改并不会导致重新创建实例。Widget不可变，只能通过修改Widget的state来使其改变。</p><p>两种Widget：有状态的 <code>StatefulWidget</code> 和无状态的<code>StatelessWidget</code>， <code>StatefulWidget</code>有一个<code>State</code>对象，用来存储状态。</p><p>示例：Text，Text继承自无状态Widget：<code>class Text extends StatelessWidget</code>，只能渲染初始化时的内容。想变更Text内容，需要放到<code>StatefulWidget</code>中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangedText</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;<span class="comment">//有状态的StatefulWidget</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ChangedTextState createState() =&gt; _ChangedTextState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ChangedTextState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ChangedText</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> titleText = <span class="string">'hello world'</span>;<span class="comment">//初始化</span></span><br><span class="line">  <span class="keyword">void</span> _textBtnClik() &#123;  </span><br><span class="line">    setState(() &#123;</span><br><span class="line">      titleText = <span class="string">'hello flutter'</span>;<span class="comment">//修改变量</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Widget _changedTextView() &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Column (</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(titleText),<span class="comment">//Text赋值变量</span></span><br><span class="line">          FloatingActionButton(</span><br><span class="line">            onPressed: _textBtnClik, <span class="comment">//点击按钮修改变量</span></span><br><span class="line">            child: Icon(Icons.add_circle),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    ); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'home'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: _changedTextView()</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改变量要在<code>setState()</code>方法中修改，会为State对象触发<code>build()</code>方法，会让UI更新。如果不在该方法中，直接更改变量值，可更改变量，UI不会更新。</p><p><em>VS Code支持代码块，输入state时能快速创建自定义StatefulWidget</em></p><h2 id="布局约束"><a href="#布局约束" class="headerlink" title="布局约束"></a>布局约束</h2><p>iOS中有storybody和xib布局，直接对视图设置约束，或者用代码设置约束，来适配屏幕。在flutter中也可以通过代码设置约束。</p><p>比如自定义按钮可以添加padding：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">  color: Colors.blue,</span><br><span class="line">  padding: EdgeInsets.only(top:<span class="number">10</span>,bottom: <span class="number">10</span>, left: <span class="number">60</span>, right: <span class="number">60</span>),</span><br><span class="line">  child: Text(<span class="string">'Btn'</span>),</span><br><span class="line">  onPressed: _textBtnClik, </span><br><span class="line">),</span><br></pre></td></tr></table></figure><h2 id="添加移除组件"><a href="#添加移除组件" class="headerlink" title="添加移除组件"></a>添加移除组件</h2><p>在iOS原生开发中，可以使用 <code>addSubview()</code>和<code>removeFromSuperview()</code> 添加移除控件，flutter中没有这类方法。flutter的视图添加移除可以动态解决，在Widget中动态添加视图，未添加上的便是移除了。Widget不可变，更改State后会重绘一个Widget代替原来的Widget，所以动态添加便完成了添加移除组件操作。</p><p>示例代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ChangedTextState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ChangedText</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">String</span> text = <span class="string">'hello wrold'</span>;</span><br><span class="line">  <span class="built_in">bool</span> textBool = <span class="keyword">true</span>;</span><br><span class="line">  _textBtnClik() &#123;  </span><br><span class="line">    setState(() &#123;</span><br><span class="line">      index ++;</span><br><span class="line">      textBool = !textBool;<span class="comment">//bool值控制添加组件</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  _viewShow() &#123;<span class="comment">//返回不同的组件</span></span><br><span class="line">    <span class="keyword">if</span> (textBool) &#123;</span><br><span class="line">      <span class="keyword">return</span> Text(text);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Text(<span class="string">'<span class="subst">$index</span>'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Widget _changedTextView() &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: </span><br><span class="line">      Column (</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          _viewShow(),<span class="comment">//添加组件</span></span><br><span class="line">          FlatButton(</span><br><span class="line">            color: Colors.blue,</span><br><span class="line">            padding: EdgeInsets.only(top:<span class="number">10</span>,bottom: <span class="number">10</span>, left: <span class="number">60</span>, right: <span class="number">60</span>),</span><br><span class="line">            child: Text(<span class="string">'Btn'</span>),</span><br><span class="line">            onPressed: _textBtnClik, <span class="comment">//按钮控制bool值</span></span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    ); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="声明式UI"><a href="#声明式UI" class="headerlink" title="声明式UI"></a>声明式UI</h2><p>通过上面的组件添加移除可以看出flutter的UI操作和原生iOS的区别，原生iOS对UI操作，是对UI组件直接进行命令操作，比如：执行<code>addSubview()</code>和<code>removeFromSuperview()</code> 添加移除UI。</p><p>在flutter中Widget是不可变的，只有调用<code>setState()</code>方法触发Widget重建，这时是构造了一个新的Widget实例。</p><blockquote><p>框架使用 RenderObjects 管理传统 UI 对象的职责（比如维护布局的状态）。 RenderObjects 在帧之间保持不变， Flutter 的轻量级 widget 通知框架在状态之间修改 RenderObjects， Flutter 框架则处理其余部分。</p></blockquote><p>这就是flutter中的声明式UI</p><p><strong>demo的完整代码见工程中的 <a href="https://github.com/mxdios/flutter-demo" target="_blank" rel="noopener">flutter_ios</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;flutter是跨平台的UI框架，非UI层面的任务，通过插件机制与iOS或Android通讯。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://markmiao.com/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://markmiao.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter笔记3-收藏交互</title>
    <link href="http://markmiao.com/2020/03/12/flutter3/"/>
    <id>http://markmiao.com/2020/03/12/flutter3/</id>
    <published>2020-03-12T08:02:50.000Z</published>
    <updated>2020-03-12T08:10:58.948Z</updated>
    
    <content type="html"><![CDATA[<p>demo的功能如下：对词组列表加收藏功能，跳转到收藏夹页面，更改整个APP的主题。</p><ul><li>添加交互</li><li>页面跳转</li><li>更改主题</li></ul><a id="more"></a><h2 id="添加收藏图标"><a href="#添加收藏图标" class="headerlink" title="添加收藏图标"></a>添加收藏图标</h2><p>所有动态功能的实现还是在 <code>State</code> 中去做，找到 <code>ListTile</code>在后面增加收藏图标，类似iOS中UITableViewCell中的accessoryView，但添加方法不一样。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Widget _cellView(WordPair name) &#123;</span><br><span class="line">  <span class="keyword">return</span> ListTile(</span><br><span class="line">    title: Text(</span><br><span class="line">      name.asPascalCase</span><br><span class="line">    ),</span><br><span class="line">    trailing: Icon( <span class="comment">//在trailing上添加Icon，Icons的图标很多，favorite是个心形</span></span><br><span class="line">      Icons.favorite,</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样便为每一个Tile增加了收藏图标，收藏图标有两种状态——已收藏、未收藏。需要有个bool值去控制，要得到这个bool值就要对每个Tile的title判断，判断这个title是否被收藏。</p><p>这时需要有个数组专门存放已收藏的词组：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">Set</span>&lt;WordPair&gt;_likeNameArray = <span class="built_in">Set</span>&lt;WordPair&gt;();</span><br></pre></td></tr></table></figure><p>这是存放收藏词组的数组，存放的类型是 `WordPair，用Set而不用List的原因是：Set中不允许有重复元素。更适合收藏操作。</p><p><code>_likeNameArray</code> 中存放了收藏词组，在创建<code>ListTile</code>的方法中将每个<code>WordPair</code>值跟这个数组比对即可得到bool值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">bool</span> isLike = _likeNameArray.contains(name);</span><br></pre></td></tr></table></figure><p>有了bool值便可修改收藏图标的状态：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trailing: Icon(</span><br><span class="line">    isLike ? Icons.favorite : Icons.favorite_border, <span class="comment">//支持三目元算符，赋值不同收藏图标</span></span><br><span class="line">color: isLike ? Colors.red : <span class="keyword">null</span>, <span class="comment">//为已收藏的心形设置红色，未收藏的不设置颜色</span></span><br><span class="line">),</span><br></pre></td></tr></table></figure><h2 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h2><p>有了收藏图标，需要增加收藏的点击交互。也是在创建<code>ListTile</code>的方法中为其添加点击事件<code>onTap</code>，在点击事件中操作收藏数据：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onTap: () &#123;<span class="comment">//点击事件</span></span><br><span class="line">  setState(() &#123;<span class="comment">//setState()方法</span></span><br><span class="line">    <span class="keyword">if</span> (isLike) &#123;</span><br><span class="line">      _likeNameArray.remove(name);<span class="comment">//移除收藏</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _likeNameArray.add(name);<span class="comment">//收藏</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>flutter是响应式框架，<code>setState()</code>方法会为State对象触发<code>build()</code>方法，会让UI更新。点击的时候还有水波特效，是Material Design自带的。</p><p>至此，便能完成点击收藏和取消收藏的操作了。</p><h2 id="导航栏按钮"><a href="#导航栏按钮" class="headerlink" title="导航栏按钮"></a>导航栏按钮</h2><p>在导航栏添加一个收藏夹按钮，点击收藏夹按钮跳转收藏夹页面。</p><p>在 <code>appBar</code> 中添加收藏夹按钮：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Scaffold(</span><br><span class="line">    appBar: AppBar(</span><br><span class="line">      title: Text(<span class="string">'home'</span>),</span><br><span class="line">      actions: &lt;Widget&gt;[<span class="comment">//actions需要一个Widget组</span></span><br><span class="line">        <span class="keyword">new</span> IconButton(icon: Icon(Icons.list), onPressed: _pushVc),</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">    body: _listView(),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些widget需要单个widget属性，<code>actions</code>需要一个widget组，可以添加多个IconButton，会把title挤到一边。类似iOS中的<code>rightBarButtonItems</code>。</p><p>数组中是<code>IconButton</code>，设置了Icon，和点击事件<code>_pushVc</code>，这个方法中完成页面跳转操作。</p><h2 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h2><p>页面跳转在iOS中是控制器跳转，常用push，页面称为控制器。在flutter中页面称为路由<code>route</code>，从主路由切换到新路由，就是页面跳转。</p><p>flutter中也是push和pop控制路由跳转，将路由push到导航器的栈中就是跳转新页面，将路由pop出导航器，就会返回上一个路由。</p><p>在<code>_pushVc</code>方法中创建路由，并将其push到导航器的栈中。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _pushVc() &#123;</span><br><span class="line">    Navigator.push(context, route);<span class="comment">//路由入栈的push方法，route处创建一个新路由</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建路由"><a href="#创建路由" class="headerlink" title="创建路由"></a>创建路由</h2><p>在 <code>MaterialPageRoute</code> 中创建要显示的收藏夹列表：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Navigator.push(context, </span><br><span class="line">  <span class="keyword">new</span> MaterialPageRoute(</span><br><span class="line">    builder: (contex) &#123;<span class="comment">//1.在builder方法中构建路由，builder方法是匿名函数</span></span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Iterable</span>&lt;ListTile&gt; tiles = _likeNameArray.map(</span><br><span class="line">        (WordPair name) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> ListTile (<span class="comment">//2. 创建ListTile：tiles</span></span><br><span class="line">            title: Text(</span><br><span class="line">              name.asPascalCase</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;Widget&gt; divided = ListTile <span class="comment">//6. divided最后含有分割线的列表</span></span><br><span class="line">      .divideTiles(<span class="comment">//3. ListTile的divideTiles()方法在每个tile之间添加1像素分割线，不用像之前判断奇偶添加Divider()</span></span><br><span class="line">        context: context,</span><br><span class="line">        tiles: tiles,<span class="comment">//4. 这是上面根据收藏数组创建的ListTile</span></span><br><span class="line">      )</span><br><span class="line">      .toList();<span class="comment">//5. 转换成列表显示</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上述方法创建了收藏夹，还未结束，<code>builder</code>返回一个<code>Scaffold</code>，在这里将上面创建的列表添加到body，形成整个要push的路由</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _pushVc() &#123;</span><br><span class="line">  Navigator.push(context, </span><br><span class="line">    <span class="keyword">new</span> MaterialPageRoute(</span><br><span class="line">      builder: (contex) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">Iterable</span>&lt;ListTile&gt; tiles = _likeNameArray.map(</span><br><span class="line">          (WordPair name) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ListTile (</span><br><span class="line">              title: Text(</span><br><span class="line">                name.asPascalCase</span><br><span class="line">              ),</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">List</span>&lt;Widget&gt; divided = ListTile</span><br><span class="line">        .divideTiles(</span><br><span class="line">          context: context,</span><br><span class="line">          tiles: tiles,</span><br><span class="line">        )</span><br><span class="line">        .toList();<span class="comment">//创建收藏夹列表</span></span><br><span class="line">        <span class="keyword">return</span> Scaffold(</span><br><span class="line">          appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">'like'</span>),<span class="comment">//路由标题</span></span><br><span class="line">          ),</span><br><span class="line">          body: ListView(children: divided), <span class="comment">//路由内容</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，完成路由跳转的工作。跳转之后在新路由页面自动添加返回按钮，点击会返回，不用额外添加pop。这点和iOS很像，而且也支持手势右滑返回页面。</p><h2 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h2><p>在flutter中，使用theme控制APP主题，可更改颜色修改主题：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">  primaryColor: Colors.white,<span class="comment">//白色主题</span></span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>这里有个小坑，VSCode新建项目时，这个字段默认是<code>primarySwatch</code>，在设置白色时会报错。因为white和black是<code>Color</code>类型，不是<code>MaterialColor</code>。像yellow、blue等颜色属于<code>MaterialColor</code>。</p><p>或者直接使用<code>dark()</code>，设置暗黑主题：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: <span class="keyword">new</span> ThemeData.dark(),</span><br></pre></td></tr></table></figure><p><strong>demo的完整代码见工程中的 <a href="https://github.com/mxdios/flutter-demo" target="_blank" rel="noopener">flutter_listview</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;demo的功能如下：对词组列表加收藏功能，跳转到收藏夹页面，更改整个APP的主题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加交互&lt;/li&gt;
&lt;li&gt;页面跳转&lt;/li&gt;
&lt;li&gt;更改主题&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://markmiao.com/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://markmiao.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter笔记2-第一个Flutter Demo</title>
    <link href="http://markmiao.com/2020/03/12/flutter2/"/>
    <id>http://markmiao.com/2020/03/12/flutter2/</id>
    <published>2020-03-12T02:02:50.000Z</published>
    <updated>2020-03-12T02:04:41.004Z</updated>
    
    <content type="html"><![CDATA[<p>第一个flutter demo—— 无限滚动的列表应用</p><p>Material Design （质感设计），Google开发的设计语言，拓展于Google即时的卡片设计。</p><p>flutter提供了丰富的质感设计风格的widgets，在flutter中，几乎所有都是widget，</p><a id="more"></a><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>; <span class="comment">//导入Material Design</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dart中的单行函数，main()是应用程序的主函数，执行结果是runApp(MyApp()), MyApp()就是下面自定义的函数。</span></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp()); </span><br><span class="line"></span><br><span class="line"><span class="comment">//MyApp继承自StatelessWidget</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Welcome to Flutter'</span>,</span><br><span class="line">      home: Scaffold(<span class="comment">//Scaffold是material提供的widget，具有默认导航栏，标题，主屏幕的body属性</span></span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Welcome to Flutter'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Text(<span class="string">'Hello World'</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知，一个App是由widget组成的。widget可以一层层嵌套，它的最终显示样式，由它嵌套的子widget决定</p><p>示例中，body是一个widget，里面包含了Center widget，Center widget又包含了Text widget，Center widget决定了子widget以居中样式呈现，所以body的呈现样式是居中显示了文本 <code>Hello World</code></p><h2 id="引入开源包"><a href="#引入开源包" class="headerlink" title="引入开源包"></a>引入开源包</h2><p>使用 <a href="https://pub.flutter-io.cn/packages/english_words" target="_blank" rel="noopener">english_words</a> 资源包，英文单词数据资源</p><p>项目中 <code>pubspec.yaml</code> 是资源管理包，类似iOS开发中使用cocopads的 <code>Podfile</code>。</p><p>在 <code>dependencies</code> 栏下添加资源包名：<code>english_words: ^3.1.5</code> （3.1.5 或更高版本）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">    </span><br><span class="line">  <span class="attr">cupertino_icons:</span> <span class="string">^0.1.2</span></span><br><span class="line">  <span class="attr">english_words:</span> <span class="string">^3.1.5</span></span><br></pre></td></tr></table></figure><p>添加之后，在VSCode右上角，有一个方块加向下箭头的图标 <code>Get Packages</code>，点击便可安装资源包，控制台会打印安装结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[first_demo] flutter packages get</span><br><span class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> first_demo...                          <span class="number">0.4</span>s</span><br><span class="line"><span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>同时会在 <code>pubspec.lock</code> 文件中增加了添加的包名和版本信息：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">english_words:</span></span><br><span class="line"><span class="symbol">    dependency:</span> <span class="string">"direct main"</span></span><br><span class="line"><span class="symbol">    description:</span></span><br><span class="line"><span class="symbol">      name:</span> english_words</span><br><span class="line"><span class="symbol">      url:</span> <span class="string">"https://pub.flutter-io.cn"</span></span><br><span class="line"><span class="symbol">    source:</span> hosted</span><br><span class="line"><span class="symbol">    version:</span> <span class="string">"3.1.5"</span></span><br></pre></td></tr></table></figure><h2 id="使用资源包English-words"><a href="#使用资源包English-words" class="headerlink" title="使用资源包English words"></a>使用资源包English words</h2><p>示例代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:english_words/english_words.dart'</span>; <span class="comment">//引入english_words，写类WordPair时，会自动引入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> name = WordPair.random(); <span class="comment">//english_words中的随机词对，final是定义不变更的变量的关键字</span></span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Welcome to Flutter'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Text(name.asPascalCase), <span class="comment">//asPascalCase是大驼峰命名法，每个单次首字母大写，相应的还有asCamelCase等，可以尝试。</span></span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击 <code>command + s</code> （也可点击VSCode上悬浮栏的闪电按钮）会热重载，APP中的文字会不断变化。</p><h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><p>上述demo中，是用的StatelessWidget，这是不可变的widget，属性不能改变，都是final的。</p><p>StatefulWidget是可变的widget，它本身不可变，但它有一个 <code>State</code> 状态类，这个在widget整个生命周期一直存在，是可变的。</p><p>创建一个StatefulWidget，和创建StatelessWidget一样，示例代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomWorld</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  WorldState createState() =&gt; WorldState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中 <code>WorldState</code> 是StatefulWidget的 State 类，这个类通过createState()方法创建，后跟创建 State类的自定义方法 <code>WorldState()</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorldState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RandomWorld</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> name = WordPair.random();</span><br><span class="line">    <span class="keyword">return</span> Text(name.asPascalCase);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是创建State的实现方法，WorldState集成自State，<code>&lt;RandomWords&gt;</code> 代表着专门用于<code>RandomWorld</code> 的State泛型类。里面的build方法比较容易理解，就是创建widget的build方法，里面返回了一个动态的Text。这说明State也是一个widget。</p><p><em>万物皆widget啊！</em></p><p>剩下的就是使用StatefulWidget，在MyApp中使用StatefulWidget的自定义RandomWorld，动态name用不到了，直接使用<code>RandomWorld()</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// final name = WordPair.random();</span></span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Welcome to Flutter'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: RandomWorld()</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，跟之前别无二致，还是APP中的英文词组在变化。但变化从由<code>StatelessWidget</code>里的一个widget控制，变为由<code>StatefulWidget</code> 的 <code>State</code>控制。</p><h2 id="无限滚动列表"><a href="#无限滚动列表" class="headerlink" title="无限滚动列表"></a>无限滚动列表</h2><p>无限滚动是动态的，在上述demo中开发无限滚动列表，需要在State类 <code>WorldState</code> 中操作。</p><p>无限滚动列表，需要有个无限的数组数据源，所以首先在 <code>WorldState</code> 创建一个数组，用于存放数据源：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorldState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RandomWorld</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _worldArray = &lt;WordPair&gt;[]; <span class="comment">//创建数组，存放内容是WordPair。在Dart中，使用_前缀，会强制使其变为私有</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了数据源，开始创建一个ListView，这是列表widget：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Widget _listView() &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.builder( <span class="comment">//ListView类的builder方法</span></span><br><span class="line">      itemBuilder: (context, i) &#123; <span class="comment">//itemBuilder 是ListView的builder属性，是匿名回调函数，接收两个参数BuildContext和 i，i从0开始自增</span></span><br><span class="line">        <span class="keyword">if</span> (i.isOdd) &#123; <span class="comment">//在奇数行添加分割线</span></span><br><span class="line">          <span class="keyword">return</span> Divider();<span class="comment">//分割线</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> index = i ~/ <span class="number">2</span>; <span class="comment">// i/2向下取整，能得到偶数列按照0、1、2、3……的index</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _worldArray.length) &#123;</span><br><span class="line">          _worldArray.addAll(generateWordPairs().take(<span class="number">10</span>)); <span class="comment">//当index是数组长度时，数组最后一位了，再生成10个词组添加到数组中。generateWordPairs()是WordPairs的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _buildRow(_worldArray[index]); <span class="comment">//偶数行，向列表中添加文本</span></span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>向列表中添加文本也是个私有方法 <code>_buildRow</code> :</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget _buildRow(WordPair name) &#123; <span class="comment">//传参，数组中的元素WordPair</span></span><br><span class="line">    <span class="keyword">return</span> ListTile( <span class="comment">//返回列表的Tile，类似于iOS中的cell</span></span><br><span class="line">      title: Text(</span><br><span class="line">        name.asPascalCase,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至此，无限列表已经创建完了。要将无限列表添加到 <code>WorldState</code> 中，替换原来赋值词组的方法 ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold( <span class="comment">//将整个Scaffold 都放到这里处理</span></span><br><span class="line">      appBar: AppBar (</span><br><span class="line">        title: Text(<span class="string">'Home'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: _listView(), <span class="comment">//body存放自定义的无限列表。</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后再更改MyApp的方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: RandomWorld() <span class="comment">//home直接赋值自定义的动态widget即可。</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行便呈现了无限滚动列表！</p><p><strong>demo的完整代码见工程中的 <a href="https://github.com/mxdios/flutter-demo" target="_blank" rel="noopener">first_demo</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一个flutter demo—— 无限滚动的列表应用&lt;/p&gt;
&lt;p&gt;Material Design （质感设计），Google开发的设计语言，拓展于Google即时的卡片设计。&lt;/p&gt;
&lt;p&gt;flutter提供了丰富的质感设计风格的widgets，在flutter中，几乎所有都是widget，&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://markmiao.com/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://markmiao.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter笔记1-搭建开发环境</title>
    <link href="http://markmiao.com/2020/03/12/flutter1/"/>
    <id>http://markmiao.com/2020/03/12/flutter1/</id>
    <published>2020-03-12T01:35:50.000Z</published>
    <updated>2020-03-12T02:01:38.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在macOS上搭建flutter开发环境"><a href="#在macOS上搭建flutter开发环境" class="headerlink" title="在macOS上搭建flutter开发环境"></a>在macOS上搭建flutter开发环境</h2><h3 id="获取flutter-sdk"><a href="#获取flutter-sdk" class="headerlink" title="获取flutter sdk"></a>获取flutter sdk</h3><p>官网地址：<a href="https://flutter.dev/docs/development/tools/sdk/releases?tab=macos#macos" target="_blank" rel="noopener">https://flutter.dev/docs/development/tools/sdk/releases?tab=macos#macos</a></p><p>github：<a href="https://github.com/flutter/flutter/releases" target="_blank" rel="noopener">https://github.com/flutter/flutter/releases</a></p><a id="more"></a><p>查看flutter SDK版本号：解压后 flutter/version</p><p>添加flutter到path中，’pwd’是解压后flutter的文件路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=`pwd`/flutter/bin:$PATH</span><br></pre></td></tr></table></figure><p>export命令文件所在：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.bash_profile</span><br></pre></td></tr></table></figure><p>至此，只能在当前路径下使用flutter命令</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>运行 <code>flutter doctor</code> 命令，查看是否需要安装其他依赖。根据提醒安装缺少的环境依赖。</p><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Doctor</span> <span class="selector-tag">summary</span> (<span class="selector-tag">to</span> <span class="selector-tag">see</span> <span class="selector-tag">all</span> <span class="selector-tag">details</span>, <span class="selector-tag">run</span> <span class="selector-tag">flutter</span> <span class="selector-tag">doctor</span> <span class="selector-tag">-v</span>):</span><br><span class="line"><span class="selector-attr">[✓]</span> <span class="selector-tag">Flutter</span> (<span class="selector-tag">Channel</span> <span class="selector-tag">stable</span>, <span class="selector-tag">v1</span><span class="selector-class">.12</span><span class="selector-class">.13</span>+<span class="selector-tag">hotfix</span><span class="selector-class">.8</span>, <span class="selector-tag">on</span> <span class="selector-tag">Mac</span> <span class="selector-tag">OS</span> <span class="selector-tag">X</span> 10<span class="selector-class">.15</span><span class="selector-class">.2</span> 19<span class="selector-tag">C57</span>, <span class="selector-tag">locale</span> <span class="selector-tag">zh-Hans-CN</span>)</span><br><span class="line"><span class="selector-attr">[✓]</span> <span class="selector-tag">Android</span> <span class="selector-tag">toolchain</span> <span class="selector-tag">-</span> <span class="selector-tag">develop</span> <span class="selector-tag">for</span> <span class="selector-tag">Android</span> <span class="selector-tag">devices</span> (<span class="selector-tag">Android</span> <span class="selector-tag">SDK</span> <span class="selector-tag">version</span> 28<span class="selector-class">.0</span><span class="selector-class">.3</span>)</span><br><span class="line"><span class="selector-attr">[✓]</span> <span class="selector-tag">Xcode</span> <span class="selector-tag">-</span> <span class="selector-tag">develop</span> <span class="selector-tag">for</span> <span class="selector-tag">iOS</span> <span class="selector-tag">and</span> <span class="selector-tag">macOS</span> (<span class="selector-tag">Xcode</span> 11<span class="selector-class">.3</span><span class="selector-class">.1</span>)</span><br><span class="line"><span class="selector-attr">[✓]</span> <span class="selector-tag">Android</span> <span class="selector-tag">Studio</span> (<span class="selector-tag">version</span> 3<span class="selector-class">.3</span>)</span><br><span class="line"><span class="selector-attr">[!]</span> <span class="selector-tag">IntelliJ</span> <span class="selector-tag">IDEA</span> <span class="selector-tag">Ultimate</span> <span class="selector-tag">Edition</span> (<span class="selector-tag">version</span> 2019<span class="selector-class">.2</span><span class="selector-class">.3</span>)</span><br><span class="line">    ✗ <span class="selector-tag">Flutter</span> <span class="selector-tag">plugin</span> <span class="selector-tag">not</span> <span class="selector-tag">installed</span>; <span class="selector-tag">this</span> <span class="selector-tag">adds</span> <span class="selector-tag">Flutter</span> <span class="selector-tag">specific</span> <span class="selector-tag">functionality</span>.</span><br><span class="line">    ✗ <span class="selector-tag">Dart</span> <span class="selector-tag">plugin</span> <span class="selector-tag">not</span> <span class="selector-tag">installed</span>; <span class="selector-tag">this</span> <span class="selector-tag">adds</span> <span class="selector-tag">Dart</span> <span class="selector-tag">specific</span> <span class="selector-tag">functionality</span>.</span><br><span class="line"><span class="selector-attr">[✓]</span> <span class="selector-tag">VS</span> <span class="selector-tag">Code</span> (<span class="selector-tag">version</span> 1<span class="selector-class">.42</span><span class="selector-class">.1</span>)</span><br><span class="line"><span class="selector-attr">[!]</span> <span class="selector-tag">Connected</span> <span class="selector-tag">device</span></span><br><span class="line">    ! <span class="selector-tag">No</span> <span class="selector-tag">devices</span> <span class="selector-tag">available</span></span><br></pre></td></tr></table></figure><p>问题：</p><p>执行 <code>flutter doctor</code> 命令时，提示“无法打开“idevice_id”，因为无法验证开发者”。</p><p>去Mac的“系统偏好设置–&gt;安全隐私–&gt;通用–&gt;允许idevice_id”，重新运行 <code>flutter doctor</code> 命令，弹窗会出现打开按钮。</p><h3 id="全局可用flutter命令"><a href="#全局可用flutter命令" class="headerlink" title="全局可用flutter命令"></a>全局可用flutter命令</h3><ol><li><p>获取flutter SDK路径，用在第2步中添加的路径。</p></li><li><p>不同系统文件目录可能会不相同，以 <code>.bashrc</code> 为例。在 <code>.bashrc</code> 文件中添加路径。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="string">"<span class="variable">$PATH</span>:/Users/inspiry/Desktop/work/flutter/bin"</span></span><br></pre></td></tr></table></figure></li><li><p>运行 <code>source $HOME/.bash_profile</code> 刷新命令行</p></li><li><p>使用 <code>echo $PATH</code> 命令查看SDK路径是否已添加</p></li><li><p>使用 <code>which flutter</code> 查找flutter，验证是否可用全局命令</p></li></ol><p>至此，开发环境配置完成。</p><h2 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h2><h3 id="VS-Code配置"><a href="#VS-Code配置" class="headerlink" title="VS Code配置"></a>VS Code配置</h3><ol><li>安装flutter插件，在Extension中搜索flutter插件，安装，重启VSCode</li><li>验证flutter，在命令面板 <code>command + shift + p</code> 中输入doctor，选择 <code>Flutter: Run Flutter Doctor</code> 运行。查看输出是否有问题。打印结果和命令行中doctor命令结果一致。</li></ol><h3 id="VS-Code新建项目"><a href="#VS-Code新建项目" class="headerlink" title="VS Code新建项目"></a>VS Code新建项目</h3><ol><li>命令面板运行 <code>Flutter:New Project</code></li><li>输入项目名称，回车，选择项目存放目录</li></ol><p>简单的两步便创建了一个flutter项目，项目所需代码在 <code>lib/main.dart</code> </p><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>在vscode最下面的状态栏中选择模拟器，点击 <code>运行 - 启动调试</code>，demo会运行到模拟器中</p><p>flutter支持热重载，直接修改 <code>lib/main.dart</code> 中的代码，保存后即刻呈现在APP上。</p><p>问题：</p><ol><li>找不到状态栏：<code>查看 - 外观 - 勾选显示状态栏</code></li><li>提醒在flutter SDK中找不到Dart，要求在命令行中运行 <code>flutter doctor</code> 命令重试，运行命令则无反应。解决办法：在进程中找到 dart 关闭，重启vscode重试。</li></ol><p>至此，开发环境搭建完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;在macOS上搭建flutter开发环境&quot;&gt;&lt;a href=&quot;#在macOS上搭建flutter开发环境&quot; class=&quot;headerlink&quot; title=&quot;在macOS上搭建flutter开发环境&quot;&gt;&lt;/a&gt;在macOS上搭建flutter开发环境&lt;/h2&gt;&lt;h3 id=&quot;获取flutter-sdk&quot;&gt;&lt;a href=&quot;#获取flutter-sdk&quot; class=&quot;headerlink&quot; title=&quot;获取flutter sdk&quot;&gt;&lt;/a&gt;获取flutter sdk&lt;/h3&gt;&lt;p&gt;官网地址：&lt;a href=&quot;https://flutter.dev/docs/development/tools/sdk/releases?tab=macos#macos&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://flutter.dev/docs/development/tools/sdk/releases?tab=macos#macos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;github：&lt;a href=&quot;https://github.com/flutter/flutter/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/flutter/flutter/releases&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://markmiao.com/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://markmiao.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>mRemind 使用条款</title>
    <link href="http://markmiao.com/2018/12/26/shiyongtiaokuan/"/>
    <id>http://markmiao.com/2018/12/26/shiyongtiaokuan/</id>
    <published>2018-12-26T12:09:00.000Z</published>
    <updated>2020-05-07T09:17:20.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用条款"><a href="#使用条款" class="headerlink" title="使用条款"></a>使用条款</h2><p>在购买 mRemind 高级版之前，您应当阅读并遵守以下使用条款。</p><a id="more"></a><h2 id="订阅服务"><a href="#订阅服务" class="headerlink" title="订阅服务"></a>订阅服务</h2><p>我们使用订阅制来管理 mRemind 高级版的用户权益，采用月度订阅和年度订阅。</p><p>确认购买订阅服务后，将向您的Apple ID账户收款。购买连续包年项目，除非您在当前计费周期结束前至少24小时取消订单，否则项目会自动续订，您的账户将在当前计费周期结束前24小时内收取续订费用。</p><p>任何时候，您都可在App Store的账户设置中进行订阅管理。</p><h2 id="订阅服务内容"><a href="#订阅服务内容" class="headerlink" title="订阅服务内容"></a>订阅服务内容</h2><ul><li>添加多条mRemind提醒</li><li>日期选择功能</li><li>自定义时间功能</li></ul><p>这三项为 mRemind 高级版所具备的功能，未购买 mRemind 高级版，也可以使用 mRemind 提供的基础服务：</p><ul><li>添加不超过3条的mRemind提醒</li><li>5、10、20、30分钟的倒计时提醒</li><li>全部提醒的勾选/删除操作</li><li>以及其他 mRemind 提供的服务</li></ul><h2 id="功能可用性"><a href="#功能可用性" class="headerlink" title="功能可用性"></a>功能可用性</h2><p>mRemind 采用订阅制来管理高级功能服务，当订阅过期未续费时，mRemind 将不提供高级版的服务。具体细节如下：</p><ul><li>将无法新增超过3条的 mRemind 提醒</li><li>将无法添加自定义的倒计时时间</li><li>添加 mRemind 提醒时，将无法使用日期选择功能</li></ul><p>但您处在订阅期间所添加的 mRemind 提醒和自定义时间都会保留，继续供您使用。</p><h2 id="退款"><a href="#退款" class="headerlink" title="退款"></a>退款</h2><p>如果您对 mRemind 所提供的服务不满意，请优先考虑通过联系方式联系我们，将您的不满意告知我们，我们会认真考虑您的意见或建议，对 mRemind 作出调整更改，为您提供更好的服务。</p><p>如果您依旧有退款的需求，对此我们表示遗憾，但应用的内购退款流程并不受开发者掌握，您可以通过邮件反馈您的诉求，但还是建议您联系 Apple 的支持团队来进行退款操作处理，具体可查看：<a href="https://support.apple.com/zh-cn/HT204084" target="_blank" rel="noopener">针对从 Apple 购买的 App 或内容申请退款</a>。</p><h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>我们有权根据 mRemind 产品计划和运营情况，独立决定会员订阅服务的具体内容，并有权根据电子内容的版权情况新增或移除电子内容或暂停、终止提供会员订阅服务的部分服务。</p><p>我们也会不时更新本使用条款，我们建议您定期查看该协议，了解变更内容。</p><p>前述更改在此页面上发布立即生效，你同意我们对此免责。</p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a>联系我们</h2><p>mRemind 是独立开发项目，您的支持会让 mRemind 有更好的发展，感谢所有 mRemind 的用户。</p><p>如果您对 mRemind 或使用条款有任何疑问或建议，请随时通过 <a href="mailto:i@markmiao.com">i@markmiao.com</a> 与我们联系。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用条款&quot;&gt;&lt;a href=&quot;#使用条款&quot; class=&quot;headerlink&quot; title=&quot;使用条款&quot;&gt;&lt;/a&gt;使用条款&lt;/h2&gt;&lt;p&gt;在购买 mRemind 高级版之前，您应当阅读并遵守以下使用条款。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://markmiao.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>隐私政策</title>
    <link href="http://markmiao.com/2018/12/25/yinsizhengce/"/>
    <id>http://markmiao.com/2018/12/25/yinsizhengce/</id>
    <published>2018-12-25T12:09:00.000Z</published>
    <updated>2020-05-07T08:28:05.283Z</updated>
    
    <content type="html"><![CDATA[<p>本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，我们会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。您在使用本应用及服务前，请您务必仔细阅读本政策。你在同意本应用服务使用协议之时，即视为您同意本《隐私政策》（含更新版本）全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。</p><a id="more"></a><ol><li><p>适用范围<br>(a) 在您注册本应用帐号时，您根据本应用要求提供的个人注册信息；<br>(b) 在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；<br>(c) 本应用通过合法途径从商业伙伴处取得的用户个人数据。 您了解并同意，以下信息不适用本隐私权政策：<br>(a) 您在使用本应用平台提供的搜索服务时输入的关键字信息；<br>(b) 违反法律规定或违反本应用规则行为及本应用已对您采取的措施。</p></li><li><p>信息使用<br>(a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。<br>(b) 本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。<br>(c) 为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。</p></li><li><p>信息披露<br>在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息：<br>(a) 经您事先同意，向第三方披露；<br>(b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息；<br>(c) 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；<br>(d) 如您出现违反中国或其他国家有关法律、法规或者本应用服务协议或相关规则的情况，需要向第三方披露；<br>(e) 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷；<br>(f) 在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。<br>(g) 其它本应用根据法律、法规或者网站政策认为合适的披露。</p></li><li><p>信息存储和交换<br>本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。</p></li><li><p>Cookie的使用<br>(a) 在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。<br>(b) 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。<br>(c) 通过本应用所设cookies所取得的有关信息，将适用本政策。</p></li><li><p>信息安全<br>(a) 本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。<br>(b) 在使用本应用网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是本应用用户名及密码发生泄露，请您立即联络本应用客服，以便本应用采取相应措施。<br>7.本隐私政策的更改<br>(a)如果决定更改隐私政策，我们会在本政策中、本公司网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。<br>(b)本公司保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，本公司会通过网站通知的形式告知。</p></li><li><p>联系我们</p><p>如果您对我们的隐私政策有任何疑问或建议，请随时通过 <a href="mailto:i@markmiao.com">i@markmiao.com</a> 与我们联系。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，我们会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。您在使用本应用及服务前，请您务必仔细阅读本政策。你在同意本应用服务使用协议之时，即视为您同意本《隐私政策》（含更新版本）全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://markmiao.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Runtime(1)：消息传递</title>
    <link href="http://markmiao.com/2018/03/16/runtime1/"/>
    <id>http://markmiao.com/2018/03/16/runtime1/</id>
    <published>2018-03-16T09:35:50.000Z</published>
    <updated>2018-03-16T09:37:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>OC是动态语言，只有在运行时才会根据方法名去调用方法，称为给方法发送消息，是因为当调用<code>[demoObj setTest]</code>方法时，编译器会转化为<code>objc_msgSend(demoObj, @selector(setTest))</code>。如果携带参数，如<code>[demoObj setTest:str]</code>，会转化为<code>objc_msgSend(demoObj, @selector(setTest), str)</code>。</p><a id="more"></a><h2 id="unrecognized-selector-sent-to-instance"><a href="#unrecognized-selector-sent-to-instance" class="headerlink" title="unrecognized selector sent to instance"></a>unrecognized selector sent to instance</h2><p><code>unrecognized selector sent to instance</code>是开发中经常遇到的异常，诸如点击事件没有实现，调用了只声明未实现的方法，向NSArray调用了NSMutableArray的方法等等。</p><p>我们定义类<code>DemoObject</code>，在<code>.h</code>中声明方法<code>- (void)setTest;</code>，<code>.m</code>中不写方法实现。然后调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DemoObject *demoObj &#x3D; [[DemoObject alloc] init];</span><br><span class="line">[demoObj setTest];</span><br></pre></td></tr></table></figure><p>程序会很听话的崩掉，并抛出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[DemoObject setTest]: unrecognized selector sent to instance 0x60000000bda0</span><br></pre></td></tr></table></figure><p>在程序崩溃之前，消息会经过下面几个方法转发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    NSLog(@&quot;解析实例方法&quot;);</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    NSLog(@&quot;解析类方法&quot;);</span><br><span class="line">    return [super resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSLog(@&quot;转发目标选择器&quot;);</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSLog(@&quot;选择器方法签名&quot;);</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    NSLog(@&quot;转发调用&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSLog(@&quot;不识别选择器，崩溃&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息会经过上述方法传递，最终未果才会崩溃。在上述方法中我们有三次机会操作消息传递，防止崩溃。</p><ol><li>动态添加方法：<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>或<code>+ (BOOL)resolveClassMethod:(SEL)sel</code></li><li>方法重定向：<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code></li><li>消息转发：<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>和<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code></li></ol><h2 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h2><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>在类DemoObject中引入runtime：<code>#import &lt;objc/runtime.h&gt;</code>，使用<code>class_addMethod</code>动态添加方法实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void resolveTest(id self, SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;动态添加方法调用 &#x3D; %@&quot;, NSStringFromSelector(_cmd));</span><br><span class="line">&#125;</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(setTest)) &#123;</span><br><span class="line">        class_addMethod([self class], sel, (IMP)resolveTest, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法<code>class_addMethod</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT BOOL</span><br><span class="line">class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, </span><br><span class="line">                const char * _Nullable types) </span><br><span class="line">    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</span><br></pre></td></tr></table></figure><p>参数意义如下：</p><ul><li>cls：消息接收者</li><li>name：SEL方法名</li><li>imp：要动态添加方法的IMP指针</li><li>types：参数和返回值的符号字符串，<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">查看格式文档</a></li></ul><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>解析类方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(setTestClass)) &#123;</span><br><span class="line">        class_addMethod(object_getClass(self), sel, (IMP)resolveTest, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的区别在于cls：消息接收者，解析实例方法使用的<code>[self class]</code>，解析类方法使用的<code>object_getClass(self)</code>。</p><p>当self为实例对象时，<code>[self class]</code>与<code>object_getClass(self)</code>等价，因为前者会调用后者。<code>object_getClass([self class])</code>得到元类。</p><p>当self为类对象时，<code>[self class]</code>返回值为自身，还是self，所以上面解析实例方法将<code>[self class]</code>换成<code>self</code>也可以。<code>object_getClass(self)</code>与<code>object_getClass([self class])</code>等价。</p><h2 id="方法重定向"><a href="#方法重定向" class="headerlink" title="方法重定向"></a>方法重定向</h2><h3 id="实例方法-1"><a href="#实例方法-1" class="headerlink" title="实例方法"></a>实例方法</h3><p>重写<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>方法，可以将消息的接收者替换成其他对象。</p><p>新创建一个类<code>DemoNewObject</code>，将类<code>DemoObject</code>未实现的方法<code>- (void)setTest</code>，在<code>.m</code>中实现，无需在<code>.h</code>中暴露方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setTest &#123;</span><br><span class="line">    NSLog(@&quot;实例方法重定向&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法重定向操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(setTest)) &#123;</span><br><span class="line">        DemoNewObject *obj &#x3D; [[DemoNewObject alloc] init];</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类方法-1"><a href="#类方法-1" class="headerlink" title="类方法"></a>类方法</h3><p>类方法重定向需要重写<code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>方法，注意是<code>+</code>开头的类方法。</p><p>同样在新类<code>DemoNewObject</code>中实现类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (void)setTestClass &#123;</span><br><span class="line">    NSLog(@&quot;类方法重定向&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写重定向方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(setTestClass)) &#123;</span><br><span class="line">        return NSClassFromString(@&quot;DemoNewObject&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法重定向就是将当前类未实现的方法，重定向到一个实现该方法的新类中，调用新类中的方法实现。实例方法中返回实例对象，类方法中返回类对象。</p><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>消息转发是通过方法<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>实现的，它可以将不能处理的消息转发给其他对象处理，参数<code>anInvocation</code>是通过方法<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>产生的。</p><p>所以需要重写两个方法，<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>和<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature *signature &#x3D; [super methodSignatureForSelector:aSelector];</span><br><span class="line">    if (!signature) &#123;</span><br><span class="line">        if ([DemoNewObject instancesRespondToSelector:aSelector]) &#123;</span><br><span class="line">            signature &#x3D; [DemoNewObject instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    if ([DemoNewObject instancesRespondToSelector:anInvocation.selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:[[DemoNewObject alloc] init]];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考资料</strong></p><p><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a></p><p><a href="https://www.jianshu.com/p/60c251712df7" target="_blank" rel="noopener">iOS中的unrecognized selector sent to instance..</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OC是动态语言，只有在运行时才会根据方法名去调用方法，称为给方法发送消息，是因为当调用&lt;code&gt;[demoObj setTest]&lt;/code&gt;方法时，编译器会转化为&lt;code&gt;objc_msgSend(demoObj, @selector(setTest))&lt;/code&gt;。如果携带参数，如&lt;code&gt;[demoObj setTest:str]&lt;/code&gt;，会转化为&lt;code&gt;objc_msgSend(demoObj, @selector(setTest), str)&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Runtime" scheme="http://markmiao.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发笔记三</title>
    <link href="http://markmiao.com/2018/03/02/ios3/"/>
    <id>http://markmiao.com/2018/03/02/ios3/</id>
    <published>2018-03-02T06:31:49.000Z</published>
    <updated>2018-03-02T06:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NSInterger-to-NSData"><a href="#NSInterger-to-NSData" class="headerlink" title="NSInterger to NSData"></a>NSInterger to NSData</h2><p>NSInterger to NSData，数字转化为Data，打印出来以十六进制形式展示</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (NSData *)getDataWithInt:(NSInteger)interger &#123;</span><br><span class="line">    Byte b1&#x3D;interger &amp; 0xff;</span><br><span class="line">    Byte b2&#x3D;(interger&gt;&gt;8) &amp; 0xff;</span><br><span class="line">    Byte b3&#x3D;(interger&gt;&gt;16) &amp; 0xff;</span><br><span class="line">    Byte b4&#x3D;(interger&gt;&gt;24) &amp; 0xff;</span><br><span class="line">    if (interger &lt;&#x3D; 255) &#123;</span><br><span class="line">        Byte byte[] &#x3D; &#123;b1&#125;;</span><br><span class="line">        return [NSData dataWithBytes:byte length:sizeof(byte)];</span><br><span class="line">    &#125; else if (interger &lt;&#x3D; 65535) &#123;</span><br><span class="line">        Byte byte[] &#x3D; &#123;b2,b1&#125;;</span><br><span class="line">        return [NSData dataWithBytes:byte length:sizeof(byte)];</span><br><span class="line">    &#125; else if (interger &lt;&#x3D; 16777215) &#123;</span><br><span class="line">        Byte byte[] &#x3D; &#123;b3,b2,b1&#125;;</span><br><span class="line">        return [NSData dataWithBytes:byte length:sizeof(byte)];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Byte byte[] &#x3D; &#123;b4,b3,b2,b1&#125;;</span><br><span class="line">        return [NSData dataWithBytes:byte length:sizeof(byte)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SHA1加密"><a href="#SHA1加密" class="headerlink" title="SHA1加密"></a>SHA1加密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)SHA1Encrypt:(NSString *)string&#123;</span><br><span class="line">    const char *cstr &#x3D; [string UTF8String];</span><br><span class="line">    NSData *data &#x3D; [NSData dataWithBytes:cstr length:string.length];</span><br><span class="line">    uint8_t digest[CC_SHA1_DIGEST_LENGTH];</span><br><span class="line">    CC_SHA1(data.bytes, (CC_LONG)data.length, digest);</span><br><span class="line">    NSMutableString *output &#x3D; [NSMutableString stringWithCapacity:CC_SHA1_DIGEST_LENGTH *2];</span><br><span class="line">    for (int i &#x3D; 0; i&lt;CC_SHA1_DIGEST_LENGTH; i++) &#123;</span><br><span class="line">        [output appendFormat:@&quot;%02x&quot;,digest[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iPhone屏幕单位"><a href="#iPhone屏幕单位" class="headerlink" title="iPhone屏幕单位"></a>iPhone屏幕单位</h2><p>ios开发中设置的size为pt，pt是绝对长度，等于1/72英寸，等于1/72*25.4毫米。</p><p>px是像素，像素点的密度代表着屏幕清晰度。这就是开发中@1x、@2x、@3x的区别。</p><p>iPhone 3GS是@1x像素级，分辨率为480px * 320px，iPhone4是@2x像素级，分辨率为960px * 640px。这两者尺寸是一样的，所以pt是一样的，在同样大的范围内，iPhone 4的像素点比iPhone 3GS的多一倍。</p><h2 id="QR码的一些知识点"><a href="#QR码的一些知识点" class="headerlink" title="QR码的一些知识点"></a>QR码的一些知识点</h2><p>QR码有40个版本，版本1是21 x 21个小方块组成，版本2是25 x 25个小方块，每增加1版本，二维码长宽各增加4个方块。所以最高版本40，方块数为177 * 177。计算公式是：(V-1) * 4 + 21</p><p>使用CIFilter生成QR码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生码Objective-C</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)markCode:(<span class="built_in">NSString</span> *)code &#123;</span><br><span class="line">    <span class="built_in">CIFilter</span> *filter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIQRCodeGenerator"</span>];</span><br><span class="line">    [filter setDefaults];</span><br><span class="line">    <span class="built_in">NSData</span> *data = [code dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    [filter setValue:data forKey:<span class="string">@"inputMessage"</span>];</span><br><span class="line">    [filter setValue:<span class="string">@"L"</span> forKey:<span class="string">@"inputCorrectionLevel"</span>]; <span class="comment">//二维码的纠错级别 L &lt; H &lt; Q &lt; M</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CIColor</span> *color1 = [<span class="built_in">CIColor</span> colorWithCGColor:[<span class="built_in">UIColor</span> blackColor].CGColor];<span class="comment">//二维码颜色</span></span><br><span class="line">    <span class="built_in">CIColor</span> *color2 = [<span class="built_in">CIColor</span> colorWithCGColor:[<span class="built_in">UIColor</span> whiteColor].CGColor];<span class="comment">//背景色</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *parameters = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: filter.outputImage ,<span class="string">@"inputImage"</span>, color1,<span class="string">@"inputColor0"</span>, color2,<span class="string">@"inputColor1"</span>,<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">CIFilter</span> *newFilter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIFalseColor"</span> withInputParameters:parameters];</span><br><span class="line">    <span class="built_in">CIImage</span> *outPutImage = [newFilter outputImage];</span><br><span class="line">    <span class="keyword">int</span> version = (<span class="keyword">int</span>)((outPutImage.extent.size.width - <span class="number">21</span>) / <span class="number">4.0</span> + <span class="number">1</span>); <span class="comment">//获取该二维码的版本号</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> createNonInterpolatedUIImageFormCIImage:outPutImage withSize:<span class="number">600</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让二维码变的清楚</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)createNonInterpolatedUIImageFormCIImage:(<span class="built_in">CIImage</span> *)image withSize:(<span class="built_in">CGFloat</span>) size &#123;</span><br><span class="line">    <span class="built_in">CGRect</span> extent = <span class="built_in">CGRectIntegral</span>(image.extent);</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = MIN(size/<span class="built_in">CGRectGetWidth</span>(extent), size/<span class="built_in">CGRectGetHeight</span>(extent));</span><br><span class="line">    size_t width = <span class="built_in">CGRectGetWidth</span>(extent) * scale;</span><br><span class="line">    size_t height = <span class="built_in">CGRectGetHeight</span>(extent) * scale;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> cs = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGContextRef</span> bitmapRef = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, cs, (<span class="built_in">CGBitmapInfo</span>)kCGImageAlphaPremultipliedLast);</span><br><span class="line">    <span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">CGImageRef</span> bitmapImage = [context createCGImage:image fromRect:extent];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextSetInterpolationQuality</span>(bitmapRef, kCGInterpolationNone);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(bitmapRef, scale, scale);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(bitmapRef, extent, bitmapImage);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGImageRef</span> scaledImage = <span class="built_in">CGBitmapContextCreateImage</span>(bitmapRef);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(bitmapRef); <span class="built_in">CGImageRelease</span>(bitmapImage);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *outputImage = [<span class="built_in">UIImage</span> imageWithCGImage:scaledImage];</span><br><span class="line">    <span class="keyword">return</span> outputImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;NSInterger-to-NSData&quot;&gt;&lt;a href=&quot;#NSInterger-to-NSData&quot; class=&quot;headerlink&quot; title=&quot;NSInterger to NSData&quot;&gt;&lt;/a&gt;NSInterger to NSData&lt;/h2&gt;&lt;p&gt;NSInterger to NSData，数字转化为Data，打印出来以十六进制形式展示&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://markmiao.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>2017我的年终总结</title>
    <link href="http://markmiao.com/2017/12/29/sum2017/"/>
    <id>http://markmiao.com/2017/12/29/sum2017/</id>
    <published>2017-12-29T05:44:30.000Z</published>
    <updated>2018-03-16T09:35:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>2016年的年终总结里写的愿望是：希望2017年的年终总结里没有懊悔。</p><p>回望2017，好像在原地踏步，像在风浪中打转的孤舟。混混沌沌算是过去了，这一晃又是一年。</p><a id="more"></a><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>没有跳槽，还是很平淡的敲代码，公司的代码敲的比较少了，一是没有什么技术难题，二是确实没有什么可敲的。这一年立志做自己的应用，写技术博客，开源项目。这几项都完成寥寥，没什么可总结的。独立项目，可看我上一篇文章<a href="http://markmiao.com/2017/12/26/kaifazhezongjietucao/">个人开发者的吐槽</a>；技术博客，没什么可说的；开源项目，呃……不丢人了……</p><p>明年还是想让自己的工作有一个大的改变，好几年都没有变化，做井底之蛙太久了。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>生活上比较跌宕起伏，有时间我会就这个大事件专门写一篇长文，吐槽一下整个2017年，我们的惊险奇遇。可以说见证了北京房价的疯狂，也见识到人性的卑劣，更体会到福祸相依的人生，还见识到不能说的黑暗。之所以现在还没写，是他妈的这件事还没完！！！</p><p>生活从不缺惊喜和惊吓，我会积极面对，不以物喜，不以己悲，佛系人生，看淡一切。WQNMLGB！</p><p>2017再见，2018你好。对2018的我说一句：再立志，别放弃！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016年的年终总结里写的愿望是：希望2017年的年终总结里没有懊悔。&lt;/p&gt;
&lt;p&gt;回望2017，好像在原地踏步，像在风浪中打转的孤舟。混混沌沌算是过去了，这一晃又是一年。&lt;/p&gt;
    
    </summary>
    
    
      <category term="记事" scheme="http://markmiao.com/categories/%E8%AE%B0%E4%BA%8B/"/>
    
    
      <category term="总结" scheme="http://markmiao.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="生活" scheme="http://markmiao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>个人开发者的吐槽</title>
    <link href="http://markmiao.com/2017/12/26/kaifazhezongjietucao/"/>
    <id>http://markmiao.com/2017/12/26/kaifazhezongjietucao/</id>
    <published>2017-12-26T08:35:13.000Z</published>
    <updated>2018-12-24T07:59:34.766Z</updated>
    
    <content type="html"><![CDATA[<p>按说到了该写年终总结的时候了，不仅没写，还浪浪荡荡的想再写一篇吐槽。我不是独立开发者，只是想尝试一下自己设计、自己开发一款APP是一种什么样的体验。本文偏吐槽，没有实质性的内容总结，以后有机会再写一篇详细的开发体验。</p><a id="more"></a><h2 id="年终总结"><a href="#年终总结" class="headerlink" title="年终总结"></a>年终总结</h2><p>今年年初注册了苹果个人开发者账号，4月10日发布了第一款个人应用：<a href="https://itunes.apple.com/cn/app/%E6%8E%92%E7%8F%AD-%E4%B8%8A%E7%8F%AD%E6%97%B6%E9%97%B4-%E4%B8%80%E7%9B%AE%E4%BA%86%E7%84%B6/id1221228242?mt=8" target="_blank" rel="noopener">排班 - 上班时间，一目了然</a>，然后就不负责任地再也没迭代过新版本，新版并不是没开发，而是改动比较多，步子迈大了，中途忙别的就给耽误了。（死不承认是三分钟热度过劲了）</p><p>8月份发布了第一款macOS应用：<a href="https://itunes.apple.com/cn/app/%E9%80%9F%E8%AE%B0-%E5%BF%AB%E9%80%9F%E8%AE%B0%E5%BD%95%E6%AF%8F%E4%B8%80%E6%AE%B5%E6%96%87%E5%AD%97/id1263819789?mt=12" target="_blank" rel="noopener">速记 - 快速记录每一段文字</a>，然后就臭不要脸地只迭代了一版。这是我学习macOS开发的试水项目，以后可能还会迭代新版本吧。其实年底又新开了一个macOS应用项目，开发了一半，明年发布。旧坑不填，新坑不断。</p><p>今年是我写个人项目的第一年，算起来做iOS开发也好几年了，现在才搞，也是后知后觉。年底了，集中吐槽一下做个人独立项目的经历和感触。</p><p>“利用业余时间，将自己的技术转化为产品，能帮助用户，并收获5星好评，感觉棒棒哒。”这冠冕堂皇的说辞是不是看的有点吐？不吹牛逼，扯点实际的。</p><p>其实是用一堆烂代码攒个烂app，祈求没bug，让用户购买，日夜盼望着销量多点，多赚点外快，攒点私房钱。再收获点好评和赞美邮件，跳槽时再能当个加分点，岂不是美滋滋？</p><p>一年时间快过去了，勉强把交给苹果的保护费赚回来了。最佳成绩是效率付费APP排行榜第19位。收获了二三十封邮件反馈，意见和建议都很好，我会慢慢加到APP里，明年就加，不吹牛逼。也有一两封邮件，开篇就骂，要求退款。App Store收获了21条评论，5星4星好评占大多数，也有说不好用给1星的，或者直接骂垃圾给1星。不论好坏，照单全收。</p><h2 id="付费机制"><a href="#付费机制" class="headerlink" title="付费机制"></a>付费机制</h2><p>我的两个APP都采用了最简单的付费模式——付费下载。一次性买断，享受永久的应用服务和后续所有新版本迭代。另一种付费模式是内购，可以免费安装使用部分功能，解锁全部功能需要内购付费，这类付费可以是买断（比如游戏解锁关卡），也可以是订阅式（比如会员服务）。</p><p>现在越来越多的应用开始采用内购订阅模式，对开发者来说，不仅仅依靠新增用户付费，老用户在享受应用服务和新版本迭代，也支付一些费用，这样有利于应用的长期发展。对用户来说，不用付费就能先体验一把，适不适合自己可以有个判断，再决定是否付费享受全部功能。这种缓冲策略，对于用户量增长也很有利。</p><p>当然，对于订阅模式的应用，如何界定免费功能和付费功能，还有很多需要探讨的地方。免费功能可以满足用户，便很少有用户会付费；免费功能太少，如同鸡肋，用户有可能会骂娘直接卸载。</p><p>其实最艰难的，当属付费应用转为免费+订阅式应用的转型。老用户当时狠心花钱买断了应用，你现在告诉人家要交年费，这不是坑人吗。著名的markdown编辑器Ulysses，日记应用Day One，密码存储应用1Password，这几款堪称神作的APP都经历了从付费应用到免费+订阅式应用的转变。然后在转型初期，无一例外的收获了大量的1星差评和骂娘评论。</p><p>也有公司干脆发布一款免费+订阅式的新应用，保留付费买断的旧应用。著名思维导图应用MindNode就是这么做的，新版MindNode5是免费+订阅，旧版MindNode4（macOS应用是MindNode2）是付费应用。但这样一来，就会出现用户导流的新问题，同时维护两个应用也增加了开发成本。</p><p>未来的付费应用，使用订阅式这类持续付费的会越来越多，毕竟软件公司需要维持发展，开发者也得活着吃饭，仅靠新增用户，收益只会越来越少，饿死是迟早的事。其实这也符合自然法则，你购买APP是享受它带来的持续服务，还包括新版本新功能，这又不是一次性的。不像买根黄瓜，吃完了事。</p><p>所以明年上架的macOS应用，我打算尝试一下付费订阅模式。</p><h2 id="收益分成"><a href="#收益分成" class="headerlink" title="收益分成"></a>收益分成</h2><p>App Store上所有的付费应用，苹果公司都要抽成30%，不论是付费下载还是内购（订阅式内购第一年抽成30%，第二年抽成15%）。想想让腾讯赚个盆满钵满的王者荣耀，苹果已经拿走了30%，App Store可不止一个王者荣耀。一个APP卖1块钱，苹果会拿走3毛，1分钱交税，开发者得6毛9分钱，还是人家做平台的牛逼啊。</p><p>曾经有一个用户给我发邮件，说APP不好用，要我退他1块钱。我满腔苦水无人诉说，我这省吃俭用攒了688块钱，向苹果爸爸买了个摊位，辛辛苦苦开发了个应用，求苹果爸爸高抬贵手通过审核，终于摆上摊位。你花1块钱买了，转头说不好用，让我退钱。我哪有钱呐，别说你这1块了，该分成给我的6毛9也没到我手里啊！</p><p>这里我想说的是，买错的或者用着不满意的APP可以退款，但你不应该找开发者，应该去找苹果公司。购买90天内，你可以在已购APP里申请退款，苹果会根据你的使用情况和理由酌情考虑会不会给你退钱。即使退款成功，APP也不会从你手机里卸载，你还能继续使用。如果退款不成功，那你要考虑下为什么了，一个游戏你都玩通关了，再去申请退款，肯定没戏。所以，要退款，请出门左转找苹果。</p><p>用户购买APP的钱并不会实时转账到开发者的账户，我只能看到下载量和预计收益，收益到账？不存在的。每月苹果会下发上月的财务报告，但并不代表着会给开发者打钱。只有收益累计超过150美元，苹果才会给开发者汇款。如果收益达不到150美元，会自动累计到下个月。也就是说，我靠着6毛9、6毛9、6毛9……这个赚法，一直赚到1000块钱，苹果才会给我转账。你张口就让我退你1块钱，我哪有啊！</p><h2 id="艰难入账"><a href="#艰难入账" class="headerlink" title="艰难入账"></a>艰难入账</h2><p>终于有一天，我的收益超过了150美元，苹果要给我打钱了。这些年净是给苹果送钱了，终于要见到回头钱了。然而中国银行还横插了一杠子。</p><p>上架付费应用需要绑定银行卡，不然苹果无法给开发者汇款收益，我绑定了一张中国银行的储蓄卡。苹果汇款那天我接到了中国银行给我打的电话：“您有一笔美元汇款，请问这笔钱是做什么用的？”</p><p>我有点懵，我说：“是苹果公司给我的付费应用分成收益，是合法的。”我特意强调合法，我心里还嘀咕，中国银行认为我走私了？</p><p>对方说：“收益？是劳务报酬吗？”</p><p>我想我又不是苹果员工，这算劳务报酬吗？其实这就是劳务报酬，在苹果的App Store上发布应用获取收益，也属于参与了苹果提供的工作岗位。</p><p>我问：“为什么要问这笔钱是做什么用的？”</p><p>对方说：“这是境外公司对个人的汇款，您必须提供对方为什么给你汇这笔钱的说明资料，然后我们才能给您入账。”</p><p>我明白了，钱是我的，我还得证明这钱为什么是我的。我说：“我怎么给你说明资料？”</p><p>对方说：“您什么时候方便，可以来柜台办理一下。”</p><p>我说：“我没时间过去，我这也只有电子版的，邮件发你吧。”</p><p>对方纠结了半天，还是同意了，说先发过去看看。然后给我发了一封只有标题，内容全是甩锅的邮件，让我在回复邮件中提供说明资料。</p><p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/WX20171226-155140.png" alt="甩锅邮件"></p><p>我将苹果的付费应用协议《Paid Applications Agreement》PDF文件发过去了，这份协议有36页，全是英文。我在网上搜索，好多开发者都遇到过这个问题，被银行刁难必须提供汇款说明资料。有一个最悲催的开发者，被银行要求将这36页的付费应用协议翻译成中文打印出来。</p><p>我本以为这就可以了，过了两天，中国银行又给我打电话，说我必须得去签字，同意美元入账。我说那人民币入账吧，对方说人民币入账我得带着身份证去做汇率转换。说到底我还得跑一趟。</p><p>在柜台签字入账的时候，我发现那36页的付费应用协议被打印出来了，厚厚的一摞，中国银行真牛！</p><p>我咨询了一下，这家中国银行支行只收到我这一例苹果公司给开发者汇款的业务，以后汇款入账，还得去柜台办理，我准备换银行卡了，谁知道哪家银行可以直接入账？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按说到了该写年终总结的时候了，不仅没写，还浪浪荡荡的想再写一篇吐槽。我不是独立开发者，只是想尝试一下自己设计、自己开发一款APP是一种什么样的体验。本文偏吐槽，没有实质性的内容总结，以后有机会再写一篇详细的开发体验。&lt;/p&gt;
    
    </summary>
    
    
      <category term="程序人生" scheme="http://markmiao.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="短文" scheme="http://markmiao.com/tags/%E7%9F%AD%E6%96%87/"/>
    
      <category term="AppStore" scheme="http://markmiao.com/tags/AppStore/"/>
    
  </entry>
  
  <entry>
    <title>吐槽苹果APP审核</title>
    <link href="http://markmiao.com/2017/12/22/tucaoappshenhe/"/>
    <id>http://markmiao.com/2017/12/22/tucaoappshenhe/</id>
    <published>2017-12-22T08:55:11.000Z</published>
    <updated>2017-12-22T08:58:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天看图神发了一篇文章<a href="https://imtx.me/archives/2399.html" target="_blank" rel="noopener">谈谈 Apple 的「审核玄学」</a>，看完之后深以为然，苹果的APP上架审核堪称不可捉摸的玄学秘术。我也曾就这个问题吐槽过：<a href="http://markmiao.com/2017/08/12/talkingtoapple/">被苹果爸爸完全碾压的通话记录</a>，也记录过因各种问题被拒的经历：<a href="http://markmiao.com/2016/11/10/%E6%8F%90%E4%BA%A4%E5%BA%94%E7%94%A8%E5%88%B0AppStore%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/#%E4%B9%8B%E5%89%8D%E4%B8%8D%E5%B9%B8%E8%B8%A9%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%EF%BC%8C%E8%A2%ABAppStore%E6%8B%92%E4%BA%86">之前不幸踩过的一些坑，被AppStore拒了</a>、<a href="http://markmiao.com/2017/07/27/macosapprejected/">macOS应用上架被拒</a>。</p><a id="more"></a><p>细数这些年我被苹果审核拒绝的经历，貌似还没有离谱到玄学境地的（这个flag先立起来，等遇到了回来还愿）。虽然我没遇到，但其审核作风就是：“上联：说你行你就行，不行也行。下联：说不行就不行，行也不行。横批：不服不行。“</p><p>曾经一个app上架，被苹果以不支持IPv6-only为理由，拒绝了七八次。最后苹果警告，再不修复该问题，等待审核时间会加倍延长。我各种测试在IPv6-only网络环境下，APP网络访问完全没问题，当时在想是不是服务器接口被墙了？苹果审核时访问不了。给苹果拍视频，写邮件解释，换来的还是拒绝。</p><p>真实情况是根本不存在不支持IPv6-only的问题，而是苹果审核时未允许地理位置获取，导致某个接口缺少位置参数，结果返回网络连接失败。我和服务端都忽略了这个问题。其实只有这一个接口访问不了，其他接口完全没问题。但是苹果只给我截了这一页的截图，说接口访问失败，不支持IPv6-only。当时只顾着死怼IPv6-only，完全搞错了方向。</p><p>曾经还因为APP太简单被拒绝，苹果给的理由是应用过于简单，建议用HTML网页实现。其实APP界面跳转挺多的，只是意见反馈和教程讲解占了大部分功能，苹果认为这两个功能应用性太低，所以将其归类于太简单。然而你却没有权利反驳。</p><p>App Store上应用繁多，有好多APP的内容或功能违反了苹果审核条例，比如：盛名列车时刻就存在软件更新功能。但是这些并不是你可以这么做的理由。我曾经因APP被拒，向苹果审核人员抱怨：“有的应用就是这么做的。”结果被直接怼回来了：“如果你认为有应用存在违规，可以举报，但你的应用违反审核条例，不能上架。”</p><p>其实苹果也有宽宏大量的时候，我曾上架过一款TCP通讯的APP，需要和Windows客户端配合使用。APP打开只有一个登录界面，需要Windows客户端配合生成登录校验码，才能登录。使用时也需要开启Windows客户端，并输入Windows的IP和端口进行TCP通讯。</p><p>上架前曾绞尽脑汁考虑，怎么让苹果使用并审核APP呢？最后我拍了一段500M的视频，详细记录了使用过程，在提交APP的备注里加上视频地址。结果是APP审核通过，顺利上架。那一刻简直想高呼苹果万岁。</p><p>好人多吐槽过苹果的审核时间，APP上架会经历这几种状态：准备提交，等待审核，审核中，审核通过或被拒。APP提交后，等待审核这个阶段是最漫长的，平均一周左右。苹果审核太慢也是导致JSPatch等热更新技术兴起的一大原因。今年苹果明令禁止上架APP采用热更新技术，同时审核速度有所提高，运气好的话通常一两天就可以审核完成，运气不好就没准了。</p><p>我经历的APP审核绝大多数是在晚上，通常半夜睡觉前会收到进入审核状态的通知，第二天会收到通过或被拒的通知。而且发现周五晚上进入审核状态的几率比较高。感觉macOS应用比iOS应用审核快，我经历过最快的一次macOS应用审核，从APP提交到审核通过只用了2小时16分。</p><p>苹果的应用审核机构神秘莫测，鲜为人知；审核手段大道无形，难以捉摸。惹不起，惹不起。</p><p>做iOS开发，你不仅惹不起，还躲不起。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天看图神发了一篇文章&lt;a href=&quot;https://imtx.me/archives/2399.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;谈谈 Apple 的「审核玄学」&lt;/a&gt;，看完之后深以为然，苹果的APP上架审核堪称不可捉摸的玄学秘术。我也曾就这个问题吐槽过：&lt;a href=&quot;http://markmiao.com/2017/08/12/talkingtoapple/&quot;&gt;被苹果爸爸完全碾压的通话记录&lt;/a&gt;，也记录过因各种问题被拒的经历：&lt;a href=&quot;http://markmiao.com/2016/11/10/%E6%8F%90%E4%BA%A4%E5%BA%94%E7%94%A8%E5%88%B0AppStore%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/#%E4%B9%8B%E5%89%8D%E4%B8%8D%E5%B9%B8%E8%B8%A9%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%EF%BC%8C%E8%A2%ABAppStore%E6%8B%92%E4%BA%86&quot;&gt;之前不幸踩过的一些坑，被AppStore拒了&lt;/a&gt;、&lt;a href=&quot;http://markmiao.com/2017/07/27/macosapprejected/&quot;&gt;macOS应用上架被拒&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="程序人生" scheme="http://markmiao.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="短文" scheme="http://markmiao.com/tags/%E7%9F%AD%E6%96%87/"/>
    
      <category term="AppStore" scheme="http://markmiao.com/tags/AppStore/"/>
    
      <category term="应用" scheme="http://markmiao.com/tags/%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>macOS开发笔记(1)</title>
    <link href="http://markmiao.com/2017/12/07/macosdevelnote1/"/>
    <id>http://markmiao.com/2017/12/07/macosdevelnote1/</id>
    <published>2017-12-07T08:05:19.000Z</published>
    <updated>2018-12-24T07:59:56.615Z</updated>
    
    <content type="html"><![CDATA[<p>旧坑不填，喜开新坑。这两天又计划开发一款macOS应用，之前开发的<a href="http://markmiao.com/2017/07/26/stenonote/">速记</a>完全是练手，反正现在是不想填坑了，索性再开一个。实际做一个项目，是学习的最佳途径。本文记录了我在开发中遇到的各种问题，以及找到的解决办法，权当以后查阅的笔记。如果能给某位朋友带来帮助，是我的荣幸。如果发现问题，敬请评论吐槽。</p><a id="more"></a><p>开发环境：<strong>Xcode 9.1 + Swift4</strong></p><h2 id="StatusBar"><a href="#StatusBar" class="headerlink" title="StatusBar"></a>StatusBar</h2><h3 id="设置按钮"><a href="#设置按钮" class="headerlink" title="设置按钮"></a>设置按钮</h3><p>在<code>applicationDidFinishLaunching</code>方法中调用下面代码，设置StatusBar按钮</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createButtonStatusBar</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">let</span> statusBar = <span class="type">NSStatusBar</span>.system</span><br><span class="line">   <span class="keyword">let</span> item = statusBar.statusItem(withLength: <span class="type">NSStatusItem</span>.squareLength)</span><br><span class="line">   item.button?.target = <span class="keyword">self</span></span><br><span class="line">   item.button?.action = #selector(itemActionShowView(<span class="number">_</span>:))</span><br><span class="line">   <span class="keyword">let</span> image:<span class="type">NSImage</span> = <span class="type">NSImage</span>(named: <span class="type">NSImage</span>.<span class="type">Name</span>(rawValue: <span class="string">"mremindbaricon"</span>))!</span><br><span class="line">   image.isTemplate = <span class="literal">true</span></span><br><span class="line">   item.button?.image = image</span><br><span class="line">   statusItem = item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">itemActionShowView</span><span class="params">(<span class="number">_</span> sender: NSStatusBarButton)</span></span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"点击"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>itemActionShowView</code>是实现的点击方法，Swift4.0之后，必须增加<code>@objc</code>修饰符，是因为Swift4.0之后去掉了Swift3.x对隐式类型推断的特性，必须手动管理<code>@objc</code>，保证oc和Swift代码能互相调用。</p><h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><p>在<code>Main.storyboard</code>的<code>Application Scene</code>中拖入<code>NSMenu</code>，将<code>NSMenu</code>拖线到<code>AppDelegate</code>中。如同上面设置statusBar按钮一样，不需要设置按钮的<code>target</code>和<code>action</code>，需要设置<code>menu</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> toolMenu: <span class="type">NSMenu!</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">item.menu = toolMenu</span><br></pre></td></tr></table></figure><p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-12-04-15-48-40.png" alt="添加NSMenu"></p><p>添加<code>NSMenu</code>的点击事件，直接拖线<code>action</code>即可。</p><h2 id="Dock和Window"><a href="#Dock和Window" class="headerlink" title="Dock和Window"></a>Dock和Window</h2><h3 id="隐藏Dock上的应用图标"><a href="#隐藏Dock上的应用图标" class="headerlink" title="隐藏Dock上的应用图标"></a>隐藏Dock上的应用图标</h3><p>开发statusBar应用，不需要弹出Window界面，可以在<code>Main.storyboard</code>中的<code>Window Controller Scene</code>中取消<code>Is Initial Controller</code>的勾选。</p><p>不需要在Dock上出现应用图标，<code>Info.plist</code>中添加Key - Value：<code>Application is agent (UIElement)</code> - <code>YES</code></p><h3 id="Window居中"><a href="#Window居中" class="headerlink" title="Window居中"></a>Window居中</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.center()<span class="comment">//居中</span></span><br></pre></td></tr></table></figure><h3 id="Window的层级关系"><a href="#Window的层级关系" class="headerlink" title="Window的层级关系"></a>Window的层级关系</h3><p>Window有一个<code>level</code>属性，标识Window的层级关系。设置Window的<code>level</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.window?.level = .floating <span class="comment">//Window设置为浮动的</span></span><br></pre></td></tr></table></figure><p>还有好多其他层级关系，诸如<code>normal</code>、<code>submenu</code>、<code>tornOffMenu</code>……</p><h3 id="启动Window"><a href="#启动Window" class="headerlink" title="启动Window"></a>启动Window</h3><p>弹出一个Window页面，并将其设置为<code>keyWindow</code>（第一响应者的Window窗口）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将addWindowController.window启动，并设置为keyWindow</span></span><br><span class="line">addWindowController.window!.makeKeyAndOrderFront(<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure><p>有时候该方法只能将Window显示出来，并不能设置为keyWindow，如果是<code>normal</code>层级的Window，Window都不能覆盖其他应用窗口，只会在其他应用窗口下面显示。特别是statusBar应用，在其他应用窗口为<code>keyWindow</code>时，点击工具条上的statusBar，启动Window，无法完成<code>keyWindow</code>设置。</p><p>需要调用下面代码，将其他应用都取消<code>keyWindow</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSApp</span>.activate(ignoringOtherApps: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h2 id="NSTextField"><a href="#NSTextField" class="headerlink" title="NSTextField"></a>NSTextField</h2><h3 id="输入时隐藏蓝色边框"><a href="#输入时隐藏蓝色边框" class="headerlink" title="输入时隐藏蓝色边框"></a>输入时隐藏蓝色边框</h3><p><code>xib</code>中在<code>Focus Ring</code>中选择<code>None</code></p><p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-12-05-10-45-36.png" alt="隐藏蓝色边框"></p><p>或者在代码中执行：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textField.focusRingType = .<span class="keyword">none</span></span><br></pre></td></tr></table></figure><h3 id="文本框第一响应者"><a href="#文本框第一响应者" class="headerlink" title="文本框第一响应者"></a>文本框第一响应者</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.window?.makeFirstResponder(textField)<span class="comment">//设置为第一响应者</span></span><br><span class="line"><span class="keyword">self</span>.window?.makeFirstResponder(<span class="literal">nil</span>) <span class="comment">//取消第一响应者</span></span><br></pre></td></tr></table></figure><h2 id="获取版本号"><a href="#获取版本号" class="headerlink" title="获取版本号"></a>获取版本号</h2><h3 id="macOS版本号"><a href="#macOS版本号" class="headerlink" title="macOS版本号"></a>macOS版本号</h3><p>macOS10.10及以上，使用下面的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> version = <span class="type">ProcessInfo</span>.processInfo.operatingSystemVersion</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(version.majorVersion).\(version.minorVersion).\(version.patchVersion)"</span>)</span><br></pre></td></tr></table></figure><p>还有如下方式（已弃用）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;CoreServices/CoreServices.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">SInt32</span> major, minor, bugfix;</span><br><span class="line"><span class="type">Gestalt</span>(gestaltSystemVersionMajor, &amp;major);</span><br><span class="line"><span class="type">Gestalt</span>(gestaltSystemVersionMinor, &amp;minor);</span><br><span class="line"><span class="type">Gestalt</span>(gestaltSystemVersionBugFix, &amp;bugfix);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(major).\(minor).\(bugfix)"</span>)</span><br></pre></td></tr></table></figure><p>其他方式请见：<a href="https://stackoverflow.com/questions/6492038/find-mac-os-x-version-number-in-objective-c" target="_blank" rel="noopener">查找Mac OS X版本号</a></p><h3 id="app版本号"><a href="#app版本号" class="headerlink" title="app版本号"></a>app版本号</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> version = <span class="type">Bundle</span>.main.object(forInfoDictionaryKey: <span class="string">"CFBundleShortVersionString"</span>)</span><br><span class="line"><span class="keyword">let</span> bundle = <span class="type">Bundle</span>.main.object(forInfoDictionaryKey: <span class="string">"CFBundleVersion"</span>)</span><br></pre></td></tr></table></figure><h2 id="设置快捷键和关闭退出应用"><a href="#设置快捷键和关闭退出应用" class="headerlink" title="设置快捷键和关闭退出应用"></a>设置快捷键和关闭退出应用</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>xib或storyboard设置快捷键很方便，直接在<code>Key Equivalend</code>输入快捷键即可。</p><p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-12-07-15-42-28.png" alt="设置快捷键"></p><h3 id="退出应用"><a href="#退出应用" class="headerlink" title="退出应用"></a>退出应用</h3><p>从<code>action</code>拖线到<code>Application</code>，选择<code>stop:</code>方法即可：</p><p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/WX20171207-154727.png" alt="拖线到Application"></p><p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-12-07-15-48-21.png" alt="选择stop:方法"></p><p>或者拖线到<code>First Responder</code>，选择<code>terminate:</code>方法</p><p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/WX20171207-155548.png" alt="拖线到First Responder"></p><p>或者调用代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSApplication</span>.shared().terminate(<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure><h3 id="关闭应用"><a href="#关闭应用" class="headerlink" title="关闭应用"></a>关闭应用</h3><p>拖线到<code>First Responder</code>，选择<code>performClose:</code>方法</p><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><p>使用<code>NSSharingService</code>调用macOS邮件应用，发送邮件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emailService = <span class="type">NSSharingService</span>(named: <span class="type">NSSharingService</span>.<span class="type">Name</span>.composeEmail)!</span><br><span class="line">emailService.recipients = [<span class="string">"i@markmiao.com"</span>]</span><br><span class="line">emailService.subject = <span class="string">"邮件内容"</span></span><br><span class="line"><span class="keyword">if</span> emailService.canPerform(withItems: [<span class="string">"邮件内容"</span>]) &#123;</span><br><span class="line">  emailService.perform(withItems: [<span class="string">"邮件内容"</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"没配置邮件账户"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在浏览器中打开网页"><a href="#在浏览器中打开网页" class="headerlink" title="在浏览器中打开网页"></a>在浏览器中打开网页</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSWorkspace</span>.shared.<span class="keyword">open</span>(<span class="type">URL</span>(string: <span class="string">"http://markmiao.com"</span>)!)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;旧坑不填，喜开新坑。这两天又计划开发一款macOS应用，之前开发的&lt;a href=&quot;http://markmiao.com/2017/07/26/stenonote/&quot;&gt;速记&lt;/a&gt;完全是练手，反正现在是不想填坑了，索性再开一个。实际做一个项目，是学习的最佳途径。本文记录了我在开发中遇到的各种问题，以及找到的解决办法，权当以后查阅的笔记。如果能给某位朋友带来帮助，是我的荣幸。如果发现问题，敬请评论吐槽。&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS开发" scheme="http://markmiao.com/categories/macOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="macOS" scheme="http://markmiao.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>APP国际化</title>
    <link href="http://markmiao.com/2017/12/01/duoyuyan/"/>
    <id>http://markmiao.com/2017/12/01/duoyuyan/</id>
    <published>2017-12-01T06:53:14.000Z</published>
    <updated>2018-12-24T07:58:27.089Z</updated>
    
    <content type="html"><![CDATA[<p>旧文新录，好多主流app都支持多语言(或者叫本地化/国际化)，有的是自动适应系统语言，有的是用户选择修改。比如微信支持如下语言，可以根据系统自适应，也可以用户更改。</p><a id="more"></a><p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161117-0.png?raw=true" alt="微信支持的语言环境"></p><h2 id="创建多语言文件"><a href="#创建多语言文件" class="headerlink" title="创建多语言文件"></a>创建多语言文件</h2><p>在工程中<code>command + n</code>创建文件，选择<code>iOS</code> -&gt; <code>Resource</code> -&gt; <code>Strings File</code>文件，自定义文件名，创建完成。</p><h2 id="添加多语言"><a href="#添加多语言" class="headerlink" title="添加多语言"></a>添加多语言</h2><p>选中新创建的多语言文件，展开右侧的侧边栏，在侧边栏里，点击<code>Localization</code>下的<code>Localize...</code>按钮，选择<code>English</code>，点击<code>Localize</code>。</p><p>选中工程在<code>PROJECT</code>里面的<code>Localizations</code>，添加语言。</p><p>每添加一个，在新建的多语言文件下就会多一个以<code>.strings</code>为后缀名的文件，这就是每个语言对应的语言文件。里面存放的语言文字是以<code>key - value</code>形式保存，每个文件中<code>key</code>是一样的，<code>value</code>对应着该语言下的文字。比如：</p><p>中文简体文件<code>File.strings(Chinese(Simplified))</code>里面存放的是：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"text"</span>=<span class="string">"世界，你好。"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>英文文件<code>File.strings(English)</code>里存放的是：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"text"</span>=<span class="string">"hello,world."</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p><code>key</code>值保持一致<code>text</code>，<code>value</code>对应该处文本的每种语言翻译。</p><h2 id="适应系统语言"><a href="#适应系统语言" class="headerlink" title="适应系统语言"></a>适应系统语言</h2><p>访问语言文件的宏定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define NSLocalizedString(key, comment) \</span><br><span class="line">    [NSBundle.mainBundle localizedStringForKey:(key) value:@&quot;&quot; table:nil]</span><br><span class="line">#define NSLocalizedStringFromTable(key, tbl, comment) \</span><br><span class="line">    [NSBundle.mainBundle localizedStringForKey:(key) value:@&quot;&quot; table:(tbl)]</span><br><span class="line">#define NSLocalizedStringFromTableInBundle(key, tbl, bundle, comment) \</span><br><span class="line">    [bundle localizedStringForKey:(key) value:@&quot;&quot; table:(tbl)]</span><br><span class="line">#define NSLocalizedStringWithDefaultValue(key, tbl, bundle, val, comment) \</span><br><span class="line">    [bundle localizedStringForKey:(key) value:(val) table:(tbl)]</span><br></pre></td></tr></table></figure><p>使用<code>NSLocalizedStringFromTable(key, tbl, comment)</code>宏定义赋值显示多语言的控件，<code>key</code>是多语言文件里的<code>key</code>值，<code>tbl</code>是多语言文件名，<code>comment</code>是注释，可空填nil。使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_label.text &#x3D; NSLocalizedStringFromTable(@&quot;text&quot;, @&quot;File&quot;, nil);</span><br></pre></td></tr></table></figure><p>还可以使用宏<code>NSLocalizedString(key, comment)</code>，没有<code>tbl</code>文件名参数，这时工程里的多语言文件名必须为<code>Localizable</code>。</p><h2 id="手动设定语言"><a href="#手动设定语言" class="headerlink" title="手动设定语言"></a>手动设定语言</h2><p>语言文件在工程内是以<code>.lproj</code>格式存储的，比如简体中文是<code>zh-Hans.lproj</code>，繁体中文是<code>zh-Hant.lproj</code>，英文是<code>en.lproj</code>。</p><p>手动设定语言就是让工程访问哪个文件。要保留app的语言设置，下次打开app还是上次设置好的语言环境。语言设置属于偏好设置，一般用<code>NSUserDefaults</code>存储。</p><p>保存环境设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *userd &#x3D; [NSUserDefaults standardUserDefaults];</span><br><span class="line">[userd setObject:@&quot;zh-Hans&quot; forKey:@&quot;appLanguage&quot;];&#x2F;&#x2F;以简体中文为例</span><br><span class="line">[userd synchronize];</span><br></pre></td></tr></table></figure><p>设置语言环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *lanType &#x3D;[NSString stringWithFormat:@&quot;%@&quot;, [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;appLanguage&quot;]];</span><br><span class="line">NSString *path &#x3D; [[NSBundle mainBundle] pathForResource:lanType ofType:@&quot;lproj&quot;];</span><br><span class="line">NSString *showValue &#x3D; [[NSBundle bundleWithPath:path] localizedStringForKey:@&quot;showTxt&quot; value:nil table:@&quot;File&quot;];</span><br><span class="line">_label.text &#x3D; showValue;</span><br></pre></td></tr></table></figure><h2 id="第一次打开app"><a href="#第一次打开app" class="headerlink" title="第一次打开app"></a>第一次打开app</h2><h3 id="手动设置默认语言"><a href="#手动设置默认语言" class="headerlink" title="手动设置默认语言"></a>手动设置默认语言</h3><p>第一次打开app，本地UserDefaults没有存储语言信息，这时可以代码存入一个，后续即可正常访问。</p><p>在<code>didFinishLaunchingWithOptions</code>里简单判断一下即可。如果没有，即存入简体中文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *userd &#x3D; [NSUserDefaults standardUserDefaults];</span><br><span class="line">if (![userd objectForKey:@&quot;appLanguage&quot;]) &#123; </span><br><span class="line">     [userd setObject:@&quot;zh-Hans&quot; forKey:@&quot;appLanguage&quot;];</span><br><span class="line">     [userd synchronize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显示系统语言设置"><a href="#显示系统语言设置" class="headerlink" title="显示系统语言设置"></a>显示系统语言设置</h3><p>首先要获取系统环境的语言，然后与app支持的语言做比较，如果app支持的语言里有目前系统语言，则显示该语言，如果没有则显示默认语言。</p><p>获取系统环境语言：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *language &#x3D; [[NSLocale preferredLanguages] objectAtIndex:0];</span><br></pre></td></tr></table></figure><p>具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *userd &#x3D; [NSUserDefaults standardUserDefaults];</span><br><span class="line">if (![userd objectForKey:@&quot;appLanguage&quot;]) &#123;&#x2F;&#x2F;如果本地没有设置语言</span><br><span class="line">    NSString *language &#x3D; [[NSLocale preferredLanguages] objectAtIndex:0];&#x2F;&#x2F;获取系统语言环境</span><br><span class="line">    if ([language hasPrefix:@&quot;zh-Hans&quot;]) &#123;&#x2F;&#x2F;简体中文</span><br><span class="line">        [userd setObject:@&quot;zh-Hans&quot; forKey:@&quot;appLanguage&quot;];&#x2F;&#x2F;设置为简体中文</span><br><span class="line">    &#125; else if ([language hasPrefix:@&quot;zh-TW&quot;] || [language hasPrefix:@&quot;zh-HK&quot;] || [language hasPrefix:@&quot;zh-Hant&quot;]) &#123;&#x2F;&#x2F;台湾繁体，香港繁体和繁体</span><br><span class="line">        [userd setObject:@&quot;zh-Hant&quot; forKey:@&quot;appLanguage&quot;];&#x2F;&#x2F;设置为繁体</span><br><span class="line">    &#125; else if ([language hasPrefix:@&quot;en&quot;]) &#123;&#x2F;&#x2F;英文</span><br><span class="line">        [userd setObject:@&quot;en&quot; forKey:@&quot;appLanguage&quot;];&#x2F;&#x2F;设置为英文</span><br><span class="line">    &#125;else&#123;&#x2F;&#x2F;没有支持的语言</span><br><span class="line">        [userd setObject:@&quot;zh-Hans&quot; forKey:@&quot;appLanguage&quot;];&#x2F;&#x2F;设置为简体中文</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多语言开发的坑"><a href="#多语言开发的坑" class="headerlink" title="多语言开发的坑"></a>多语言开发的坑</h2><p><code>LaunchScreen</code>不支持多语言开发，苹果建议不要对启动页进行多语言开发。在<code>LaunchScreen.strings</code>文件中更改不同语言环境下的字符串，并没有效果。</p><p>解决办法：删除这些没用的<code>LaunchScreen.strings</code>文件</p><p>每种语言添加一个<code>LaunchScreen.storyboard</code>。比如英文对应：<code>LaunchScreen_en.storyboard</code>，繁体中文对应<code>LaunchScreen_zhHant.storyboard</code>。</p><p>在<code>InfoPlish.strings</code>下面对应的语言文件中，分别添加如下字段：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">UILaunchStoryboardName</span> = <span class="string">"LaunchScreen_en"</span><span class="comment">;//英文文件下添加的</span></span><br></pre></td></tr></table></figure><p>其实这样做也有局限性，在首次安装启动时能选择正确的语言显示，手动更改手机语言环境，重新打开app则无法显示更改后的语言。—— 在模拟器上测试</p><h2 id="storyboard和xib多语言"><a href="#storyboard和xib多语言" class="headerlink" title="storyboard和xib多语言"></a>storyboard和xib多语言</h2><p><code>storyboard</code>和<code>xib</code>多语言只支持跟随系统，不支持手动切换。</p><p>选中<code>storyboard</code>或<code>xib</code>文件，在右侧面板的<code>Localization</code>中添加语言文件，语言文件会自动检测该<code>storyboard</code>或<code>xib</code>文件中哪些地方进行多语言化。并在文件中给出类似下面的内容，只需要在相应语言文件中修改<code>&quot;title&quot;</code>文本即可</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* <span class="keyword">Class</span> = <span class="string">"NSMenuItem"</span>; title = <span class="string">"Item 1"</span>; ObjectID = <span class="string">"sxW-84-y91"</span>; */</span><br><span class="line"><span class="string">"sxW-84-y91.title"</span> = <span class="string">"title"</span>;</span><br></pre></td></tr></table></figure><p><code>storyboard</code>和<code>xib</code>的多语言化是根据<code>ObjectID</code>来区分的。</p><p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-12-05-11-49-56.png" alt="ObjectID"></p><h3 id="国际化自动脚本"><a href="#国际化自动脚本" class="headerlink" title="国际化自动脚本"></a>国际化自动脚本</h3><p>有一个很大的问题是多语言文本不能实时更新，当你新拖入一个控件，多语言文件中并不会更新该控件的<code>ObjectID</code>。添加脚本，实现编译工程多语言文件实时更新。</p><ol><li><p>Xcode中添加脚本，脚本地址和添加脚本的方法：<a href="https://github.com/onezens/AutoLocalization" target="_blank" rel="noopener">AutoLocalization</a></p></li><li><p>终端运行脚本，首先更改脚本文件中的<code>filePath</code></p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果在终端运行，注意要修改自己需要国际化的项目文件夹的路径！</span></span><br><span class="line">filePath = <span class="string">'/Users/inspiry/Desktop/work/workCode/XDProject/mremind/mremind'</span></span><br></pre></td></tr></table></figure><p>然后在终端中执行Python文件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python <span class="module-access"><span class="module"><span class="identifier">AutoGenStrings</span>.</span></span>py</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;旧文新录，好多主流app都支持多语言(或者叫本地化/国际化)，有的是自动适应系统语言，有的是用户选择修改。比如微信支持如下语言，可以根据系统自适应，也可以用户更改。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://markmiao.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习笔记(1)</title>
    <link href="http://markmiao.com/2017/11/24/rxswiftlearn1/"/>
    <id>http://markmiao.com/2017/11/24/rxswiftlearn1/</id>
    <published>2017-11-24T06:32:44.000Z</published>
    <updated>2017-11-24T07:29:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>，是Swift的函数响应式编程框架，以函数为工具，绑定数据联动，数据改变实时反映到结果呈现。这对我来说是一种全新的编程思想，我想去了解，学习。</p><p>本文记录了我学习RxSwift的历程，包含遇到的各种问题和我的一些理解。</p><a id="more"></a><h2 id="运行官方示例"><a href="#运行官方示例" class="headerlink" title="运行官方示例"></a>运行官方示例</h2><p>从github上克隆RxSwift项目</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>@github.com:ReactiveX/RxSwift.git</span><br></pre></td></tr></table></figure><p>双击打开<code>Rx.xcworkspace</code>，在工程中选择<code>RxExample-iOS</code>或<code>RxExample-macOS</code>，选择模拟器或真机，运行。</p><h2 id="项目集成RxSwift"><a href="#项目集成RxSwift" class="headerlink" title="项目集成RxSwift"></a>项目集成RxSwift</h2><p>将RxSwift集成到项目中，推荐使用CocoaPods的方式，pod版本<code>1.3.1</code>亲测有效：</p><ul><li><p>创建项目时勾选<code>Include Unit Tests</code>，包含单元测试。</p></li><li><p>创建<code>Podfile</code>文件，输入如下内容：</p></li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Podfile</span></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target <span class="string">'工程名字'</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">'RxSwift'</span>,    <span class="string">'~&gt; 4.0'</span></span><br><span class="line">    pod <span class="string">'RxCocoa'</span>,    <span class="string">'~&gt; 4.0'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RxTests 和 RxBlocking 将在单元/集成测试中起到重要作用</span></span><br><span class="line">target <span class="string">'单元测试文件夹名字'</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">'RxBlocking'</span>, <span class="string">'~&gt; 4.0'</span></span><br><span class="line">    pod <span class="string">'RxTest'</span>,     <span class="string">'~&gt; 4.0'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>将工程名和单元测试名换成自己的，执行命令：</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="keyword">install</span></span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>问题1. 可能由于CocoaPods版本过低，pod失败，建议更新后重试，执行更新命令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem <span class="keyword">install</span> cocoapods</span><br></pre></td></tr></table></figure><p>问题2. </p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">None of your spec sources contain a spec satisfying the dependency:</span> `RxSwift (~&gt; <span class="number">4.0</span>)`.</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="built_in">setup</span></span><br></pre></td></tr></table></figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>RxSwift的本质是观察者模式，时刻观察者一个序列，当序列达到预定条件，执行某种操作。比如钟表时间是一个序列，当到6点时就下班。时间是一个被观察的序列，6点是预定条件，下班是操作。</p><p>Rx中用<code>observable</code>表示变化序列，也就是被观察者。到达预定条件的操作用<code>subscribe</code>表示，被称为订阅。订阅完成之后，要对其进行清理，清理方式是丢掉处理袋<code>DisposeBag</code>中。</p><p>这是一个基本的Rx执行流程。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>用RxSwift写一个基本的按钮点击事件。在<code>ViewController</code>中引入头文件：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br></pre></td></tr></table></figure><p>在<code>Main.storyboard</code>中拖入按钮，并连线到<code>ViewController</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> button: <span class="type">UIButton!</span></span><br></pre></td></tr></table></figure><p>创建全局变量处理袋：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br></pre></td></tr></table></figure><p>给按钮添加点击事件：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button.rx.tap</span><br><span class="line">.subscribe(onNext: &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"点击"</span>)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> button: <span class="type">UIButton!</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        button.rx.tap</span><br><span class="line">            .subscribe(onNext: &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"按钮点击"</span>)</span><br><span class="line">            &#125;).disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>demo地址：<a href="https://github.com/mxdios/XDRxSwiftLearn" target="_blank" rel="noopener">XDRxSwiftLearn</a></p><p>学习资料：</p><p><a href="http://t.swift.gg/d/2-rxswift" target="_blank" rel="noopener">靛青K神出品RxSwift 学习指导索引</a></p><p><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/" target="_blank" rel="noopener">RxSwift中文本文档</a></p><p><a href="https://darkhandz.com/categories/iOS/Swift/" target="_blank" rel="noopener">RxSwift入门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxSwift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RxSwift&lt;/a&gt;，是Swift的函数响应式编程框架，以函数为工具，绑定数据联动，数据改变实时反映到结果呈现。这对我来说是一种全新的编程思想，我想去了解，学习。&lt;/p&gt;
&lt;p&gt;本文记录了我学习RxSwift的历程，包含遇到的各种问题和我的一些理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="swift" scheme="http://markmiao.com/tags/swift/"/>
    
      <category term="RxSwift" scheme="http://markmiao.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>用apiDoc写接口文档</title>
    <link href="http://markmiao.com/2017/11/13/apidoc/"/>
    <id>http://markmiao.com/2017/11/13/apidoc/</id>
    <published>2017-11-13T09:44:16.000Z</published>
    <updated>2018-12-24T07:58:01.455Z</updated>
    
    <content type="html"><![CDATA[<p>作为移动端开发，接口文档看得多，写得少。最近对已开发完成的app进行接口文档整理，发现了<a href="http://apidocjs.com/" target="_blank" rel="noopener">apiDoc</a>这款神器。见识到接口文档也可以写的这么高大上，之前用markdown写弱爆了，用word的自杀吧。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在安装<code>npm</code>的基础上，执行命令安装apiDoc</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> apidoc -g</span><br></pre></td></tr></table></figure><p>安装完成，Mac上便具备apiDoc环境，可以开始写文档了。用apiDoc写接口文档就是写注释，支持各种语言的注释，比如：C#、Go、Java、JavaScript、PHP等等。</p><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p>在任意位置创建存放文档的文件夹，在该文件夹内创建文件<code>apidoc.json</code>，这是apiDoc的配置文件。内容示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"文档名称"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"文档描述"</span>,</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"文档网页标题"</span>,</span><br><span class="line">  <span class="attr">"url"</span> : <span class="string">"https://api.github.com/v1"</span>,</span><br><span class="line">  <span class="attr">"sampleUrl"</span>: <span class="string">"https://api.github.com/v1"</span>,</span><br><span class="line">  <span class="attr">"header"</span>: &#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"页眉"</span>,</span><br><span class="line">    <span class="attr">"filename"</span>: <span class="string">"header.md"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"footer"</span>: &#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"页脚"</span>,</span><br><span class="line">    <span class="attr">"filename"</span>: <span class="string">"footer.md"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"template"</span>: &#123;</span><br><span class="line">   <span class="attr">"withCompare"</span>: <span class="literal">true</span>,</span><br><span class="line">   <span class="attr">"withGenerator"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段解释：</p><ul><li><code>version</code>：文档版本号。</li><li><code>url</code>：域名的主地址，接口中不变的那一块。</li><li><code>sampleUrl</code>：测试API方法接口，如果设置，在每个接口下都有一个测试接口的表单。如果不想显示测试表单，需要在接口文档中增加<code>@apiSampleRequest off</code>。</li><li><code>header</code>、<code>footer</code>：页眉、页脚，可以不写。里面分别跟着页眉页脚的标题和markdown文件路径，markdown文件和<code>apidoc.json</code>同级目录。</li><li><code>withCompare</code>：版本比较，默认开启，<code>withGenerator</code>：生成器，页面底部显示apiDoc，默认开启。</li></ul><h2 id="创建接口源文档"><a href="#创建接口源文档" class="headerlink" title="创建接口源文档"></a>创建接口源文档</h2><p>我是以<code>js</code>文件写的接口文档，在配置文件<code>apidoc.json</code>统计目录下创建接口文件<code>接口.js</code>，文件名称自定义。</p><p>apiDoc最大的亮点是可以版本比较，接口更改过，可以通过接口右侧的版本号选择进行变化比较。</p><p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-11-14-09-36-28.png" alt="版本比较"></p><p>这需要在源文档中保留每个历史版本，所以每个接口都可能对应N个历史版本，所以建议一个接口用一个文件。</p><h3 id="内容示例"><a href="#内容示例" class="headerlink" title="内容示例"></a>内容示例</h3><p>创建一个<code>编辑资料.js</code>文件，并输入以下内容：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"><span class="meta">@api</span> &#123;POST&#125; users/userinfo.asp [编辑资料]</span><br><span class="line"><span class="meta">@apiVersion</span> <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line"><span class="meta">@apiName</span> userinfo</span><br><span class="line"><span class="meta">@apiGroup</span> users</span><br><span class="line"><span class="meta">@apiSampleRequest</span> off</span><br><span class="line"><span class="meta">@apiDescription</span> 编辑用户资料</span><br><span class="line"></span><br><span class="line"><span class="meta">@apiParam</span> &#123;<span class="built_in">String</span>&#125; userid 用户id</span><br><span class="line"><span class="meta">@apiParam</span> &#123;<span class="built_in">String</span>&#125; username 用户名</span><br><span class="line"><span class="meta">@apiParam</span> &#123;<span class="built_in">String</span>&#125; usersex 性别</span><br><span class="line"><span class="meta">@apiParam</span> &#123;<span class="built_in">String</span>&#125; token token</span><br><span class="line"></span><br><span class="line"><span class="meta">@apiSuccess</span> &#123;Object&#125;   data  对象数据</span><br><span class="line"><span class="meta">@apiSuccess</span> &#123;<span class="built_in">String</span>&#125;   data.userheadimg     头像</span><br><span class="line"><span class="meta">@apiSuccess</span> &#123;<span class="built_in">String</span>&#125;   data.username     用户名</span><br><span class="line"><span class="meta">@apiSuccess</span> &#123;<span class="built_in">String</span>&#125;   data.userphone     手机号</span><br><span class="line"><span class="meta">@apiSuccess</span> &#123;<span class="built_in">String</span>&#125;   data.usersex     性别</span><br><span class="line"><span class="meta">@apiSuccess</span> &#123;<span class="built_in">String</span>&#125;   errorcode  错误码</span><br><span class="line"><span class="meta">@apiSuccess</span> &#123;<span class="built_in">String</span>&#125;   errormessage  信息</span><br><span class="line"></span><br><span class="line"><span class="meta">@apiExample</span> 返回示例</span><br><span class="line">HTTP/<span class="number">1.0</span> <span class="number">0</span> ok</span><br><span class="line">&#123;</span><br><span class="line">    data =     &#123;</span><br><span class="line">        userheadimg = <span class="string">"http://xxxxxxx/api/user/2017/11/13/5EC93450A72741FA92AB4E08D4A96710.jpg"</span>;</span><br><span class="line">        username = markmiao;</span><br><span class="line">        userphone = <span class="number">13000000000</span>;</span><br><span class="line">        usersex = <span class="string">"男"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    errorcode = <span class="number">0</span>;</span><br><span class="line">    errormessage = <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-11-14-09-52-10.png" alt="部署完成后的显示样式"></p><h3 id="字段解释"><a href="#字段解释" class="headerlink" title="字段解释"></a>字段解释</h3><p>文档中所有内容是包含在<code>/**   */</code>注释中的，用apiDoc写接口文档就是写注释。</p><p><code>@api {POST} users/userinfo.asp [编辑资料]</code> </p><ul><li>必需，<code>{}</code>内是接口请求方式，GET、POST、PUT等，后面的是接口地址改变部分，会与<code>apidoc.json</code>中的<code>&quot;url&quot;</code>组成完整接口地址显示。<code>[]</code>内是接口标题。</li></ul><p><code>@apiVersion 0.1.0</code></p><ul><li>接口版本号，如果接口改变了，需要将上面内容复制一份，修改版本号，修改接口内容，就可以在文档中进行版本内容比对。</li></ul><p><code>@apiName userinfo</code></p><ul><li>接口名称，不会显示在文档中，是每个接口的唯一标识，以此来区别接口。</li></ul><p><code>@apiGroup users</code></p><ul><li>接口组名，接口可以分组存放，将一类接口放到一组总，组名相同的会被归到一组。</li></ul><p><code>@apiSampleRequest off</code></p><ul><li>隐藏测试表单</li></ul><p><code>@apiDescription 编辑用户资料</code></p><ul><li>接口描述</li></ul><p><code>@apiParam {String} userid 用户id</code></p><ul><li>接口请求参数，<code>{}</code>内是参数类型，后面跟着参数字段名和字段描述。</li></ul><p><code>@apiSuccess {Object}   data  对象数据</code></p><ul><li>接口返回值，<code>{}</code>内是返回值类型，后面跟着返回值字段名和字段描述。要想出现返回值表格中缩进的样式，以<code>data.userheadimg</code>这种形式写，<code>userheadimg</code>会在<code>data</code>下面缩进，表示属于<code>data</code>对象中的元素。</li></ul><p><code>@apiExample 返回示例</code></p><ul><li>接口返回的数据结构示例</li></ul><h2 id="生成接口文档"><a href="#生成接口文档" class="headerlink" title="生成接口文档"></a>生成接口文档</h2><p><code>cd</code>到接口文件夹，使用命令：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apidoc -i . -o <span class="meta">doc</span>/</span><br></pre></td></tr></table></figure><p>意思是使用当前文件夹(<code>. 代表当前文件夹</code>)下的所有文件，生成apiDoc文档放到<code>doc/</code>文件夹下。</p><p>命令执行完毕，在<code>doc/</code>目录下点击<code>index.html</code>，便可本地浏览用apiDoc写成的接口文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为移动端开发，接口文档看得多，写得少。最近对已开发完成的app进行接口文档整理，发现了&lt;a href=&quot;http://apidocjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;apiDoc&lt;/a&gt;这款神器。见识到接口文档也可以写的这么高大上，之前用markdown写弱爆了，用word的自杀吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTML5" scheme="http://markmiao.com/categories/HTML5/"/>
    
    
      <category term="文档" scheme="http://markmiao.com/tags/%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>被苹果爸爸完全碾压的通话记录</title>
    <link href="http://markmiao.com/2017/08/12/talkingtoapple/"/>
    <id>http://markmiao.com/2017/08/12/talkingtoapple/</id>
    <published>2017-08-12T08:14:28.000Z</published>
    <updated>2017-08-12T08:17:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>私情是介个样子滴~</p><p>最近公司开发了一款APP，是面向大众化的工具类应用。在上架App Store时遇到了阻挠，这对我来说都习以为常了，没有阻挠才奇怪呢。</p><a id="more"></a><p>这次被拒的原因之前没遇到过，但我大概预测到了：因为APP内容是属于大众化的工具类，核心功能与账户没有直接关系，所以不能在没使用APP之前强制用户登录，违反了App Store审核指南的第5.1.1条。</p><p>其实这条规则我也知道，并且知道如果给出了强制用户登录的原因，且原因具有说服力的话是可以这么做的。所以我在提交应用审核的备注里长篇大论的写了一百多字的说明，如此如此这般这般，所以我们采用了用户强制登录机制。</p><p>事实证明，这些都是废话，半毛钱说服力都没有。苹果爸爸直接拒绝，第5.1.1条规则打脸甩过来了。我还不死心，将原来备注里一多百字的说明扩充到两百字，详详细细的阐述了我们之所以这么搞，是有原因滴，然后给苹果发过去了。</p><p>苹果的回复是：你违反了第5.1.1条规则，后面分别用英文、简体中文、繁体中文说：“如果你不服，留下联系方式，来信砍。”当然苹果爸爸是用很文雅的语言描述了这个意思。我岂能示弱，留就留！</p><p>其实之前与苹果开发者客服电话联系过几次，都是些账号或应用的小问题，关于应用审核还是开天辟地头一遭。App Store应用上架审核一直是一个很神秘的机构，他们具体的工作流程和审核方法都鲜为人知。听说这个机构都在美国本土，还听说在中国台湾有个部门负责亚洲市场的应用审核。这些都是我听过的传言。之前与应用审核人员沟通都是用iTunesConnect里面的邮件，或者在Developer里面选择一项“我想干嘛”，给应用审核组发信息。从来没有电话或即时通讯这些快速的沟通途径，我曾经问过苹果开发者客服应用审核组的客服电话是多少，他直接告诉我没有。</p><p>没想到这次能电话联系到应用审核组！想想还有些小激动呢。</p><p>在我留下联系方式的三天后，也就是今天早上，我遛完狗回来接到了来自美国加利福尼亚圣何塞的电话。我清了清嗓子：“喂，您好。”</p><p>“喂，请问是xxx先生吗？”是一位普通话明显生硬的妹子，这样让我有些惊讶。</p><p>为了今天的通话，我是做了准备的。在经过友好的问候和审核问题确认之后，我率先发招：“我们的应用是有专门的用户群体，我们需要为每位使用者创建用户ID，便于后期工作展开。”我并没有在第一招就阐明这个后期工作，是希望在后面对方反驳后，再行祭出，已达到首尾呼应，加大谈判力度，我是多么的睿智。</p><p>“我们发现您的应用并不具备独立用户群的特性，因此在使用前不能强制用户登录，这违反了我们审核规则的第5.1.1条。”对方明显没get到我说的应用独特性，依旧强调规则。</p><p>“是这样的，我们会统计用户登录后使用的工具模板数量，后台大数据分析该用户经常使用哪几类，后期会对该用户着重推送这几类的工具模板。这是为用户提供更好的服务和更优质的体验，这些都是基于用户登录的。”以用户服务为向导，一切都是为了用户，有这么高大上的理由为依据，区区强制用户登录不会有问题啦，都是为了用户体验嘛。我都为我的机智和逻辑思维能力感到赞叹。</p><p>“不是不允许用户登录。对于针对普通用户群体的应用，在用户了解应用之前不可以强制用户注册登录，强制搜集用户信息。这违反了我们的应用审核规则。应用必须开放用户未登录时也可以使用部分功能，当使用涉及账号的功能时，再请求用户登录。否则无法上架。”对方如是说。</p><p>听不听爸爸的话？不听话你就别想上架。我有点委屈了，完全没考虑过人家的感受嘛。我做了一些妥协：“那这样吧，我们可以提供用户不登录的游客模式，但是只能浏览，不能使用工具模板。在使用时需要登录，这样便于我们后期有针对性的内容推送。”</p><p>“不可以，iOS是有本地存储机制的，用户不登录可以将工具模板保存到本地。如果用户想要将使用记录保存到服务器，同步到其他设备，这时可以让用户登录。”我的让步完全没有换来理解，反而换来了她的步步紧逼。太欺负人了！</p><p>“那这样一来很大一部分核心功能在用户未登录状态下都能使用，用户的登录欲望会大大降低，这不利于我们后期对用户进行有针对性的工具模板推送。”我还在做最后的挣扎，用户针对性内容是我自以为有力的筹码，我以此一再强调我们后期准备对用户的付出，想换来苹果爸爸的理解。</p><p>“当你们应用做得足够好，推广到位，我相信用户是会愿意主动注册登录的。”这分明是胜利后的嘲讽啊！听到她这句话时，我知道我说错话了，败得彻底，再也没有缓和的余地了。怎么让用户愿意登录不是苹果爸爸该考虑的，是我们该考虑的，想以强制用户登录来达到目的，苹果爸爸可不答应。别看她普通话略显生硬，欺负起我来，我竟毫无反驳的余地，稍微挣扎一点即被拍死。</p><p>“那好吧，我们对应用修改后再行上架。”我如一只斗败的公鸡，完全没有了开始时的底气和自信。这明显就不是一场势均力敌的谈判，而是爸爸教育儿子的完虐。一开始我就搞错了自己的身份地位，妄图说服苹果爸爸，这哪是胳膊拧大腿，简直是腿毛想扎大动脉，还妄图给苹果放血，太不自量力了。</p><p>君不见中国两大微——微信和微博，一个为了打赏，一个为了问答。微信关了iOS客户端的打赏功能，微博妥协了问答付费走内购。</p><p>我还是图样图森破。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;私情是介个样子滴~&lt;/p&gt;
&lt;p&gt;最近公司开发了一款APP，是面向大众化的工具类应用。在上架App Store时遇到了阻挠，这对我来说都习以为常了，没有阻挠才奇怪呢。&lt;/p&gt;
    
    </summary>
    
    
      <category term="程序人生" scheme="http://markmiao.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="短文" scheme="http://markmiao.com/tags/%E7%9F%AD%E6%96%87/"/>
    
      <category term="应用" scheme="http://markmiao.com/tags/%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>那些年用过的Mac</title>
    <link href="http://markmiao.com/2017/08/03/mymacbooks/"/>
    <id>http://markmiao.com/2017/08/03/mymacbooks/</id>
    <published>2017-08-03T01:27:01.000Z</published>
    <updated>2020-03-19T06:54:13.994Z</updated>
    
    <content type="html"><![CDATA[<p>旧文新录，这篇文是去年写的，一直放在简书上。今天把他放到blog里，日后翻出来看看也挺有意思。</p><a id="more"></a><p>记得是2014年年初接触iOS开发，作为一个资深穷逼，自然没有money去买Mac这种高端电子产品。说实话，在做iOS开发之前，我只在电视上见过MacBook，银白色金属质感，亮白的苹果logo灯，一切尽显高贵奢华。</p><p>多渴望拥有一台MacBook，哪怕摸摸也好啊。现在呢，每到秋冬季节，我碰都不愿碰它，静电把我快电出神经质了。但在那时候，MacBook就是我心中的白富美，让我摸摸，我可能会忍不住用舌头去舔它。</p><p>我一直认为MacBook是有钱人玩得起的，直到我晒出这张所谓的炫富图时，我发现自己并没有成为有钱人，依然是一个资深穷逼，真应了那句亘古不变的名言：穷玩车、富玩表、屌丝玩电脑。</p><p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG99.jpeg?raw=true" alt="炫富图"></p><h2 id="ThinkPad上装的黑苹果"><a href="#ThinkPad上装的黑苹果" class="headerlink" title="ThinkPad上装的黑苹果"></a>ThinkPad上装的黑苹果</h2><p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/20110913030805516.jpg?raw=true" alt="小黑本"></p><p>没有白富美的MacBook，但我有一台跟了我三年的小黑本ThinkPad E40。不能体验苹果本，体验一把苹果系统也不错，狠(fēi)下(cháng)心(yú)来(kuài)的给小黑本装黑苹果。</p><p>不知是我的小黑本菜，还是我菜，什么五国语言错误、驱动安装失败全让我遇到了，最后去中关村花了100大洋找人安装的(看起来还是我菜)。安装了OS X 10.9，这是Mac系统最后一代拟物化系统，10.10开始扁平化。此时的iOS7已经开始扁平化了。用黑苹果最大的问题就是卡，运行Xcode的时候简直卡的要死。</p><p>垂垂老矣的小黑本，本来运行win7都有些卡，现在硬塞进去一套Mac OS，还是Mac OS和Windows并存双系统，每次启动选择系统启动项。小黑本跟了我也算是遇人不淑，老了老了还被我这么糟蹋。</p><p>黑苹果玩了差不多半年，在我已经用iMac的时候。有一天晚上开着小黑本里的黑苹果系统，用迅雷下电影（强调是正经电影），勾选了迅雷上的下载完毕自动关机。以前也常这么搞，可见小黑本真是遇人不淑。第二天，无论如何都开不了机了，小黑本死了……</p><p>我眼前仿佛闪过小黑本跟我在一起的一幕幕，陪我上大学，陪我敲代码，陪我在宿舍看片，陪我在教室下电影……我的眼睛模糊了，终于忍不住了，我操！可以买MacBook了！</p><p>其实我还是想挽救小黑本的，想重装系统只安装一个win7，平时浏览网页，看看电影就行了，让它能安度晚年，寿终正寝。去ThinkPad售后服务点，当然保修期肯定过了，我想自费修一下也行。“主板坏了，修修1200，换一个1800”，其实让小黑本就此长眠，也不失为一种壮烈。</p><p>后来小黑本扔回了老家，老爸花了200块修了一下，能开机了。还没等我给它重装系统，在某次关机之后再也没打开过，就此长眠吃土。</p><h2 id="2012款iMac-21-5英寸"><a href="#2012款iMac-21-5英寸" class="headerlink" title="2012款iMac 21.5英寸"></a>2012款iMac 21.5英寸</h2><p>iMac是我上班后用的第一台Mac，就是第一张图中中间的那台iMac，其实当时的我是强烈期望公司给我配一台MacBook的。经过这几年频繁的换Mac电脑，我觉得就单纯开发体验来说，还是iMac用着舒服，想体验一把27英寸 Retina 5K屏的iMac开发，可惜目前为止还没有体验过。</p><p>之前对一体机没什么好感，我觉得要么用笔记本，要么用台式机，一体机算怎么回事？iMac改变了我的看法，银白色金属质感，深黑色屏幕边框，有笔记本只插一根电源线的简约，又有台式机大屏的酸爽。相比这些，我最爱的还是配备的原装Mac鼠标和Mac键盘。</p><p>Mac鼠标配备Mac系统的平面触摸、页面滑动、多点触碰，以及反Windows鼠标的页面滑动方向，甚至电池安装正负极同向都是这么的反正统。但是，用起来很爽。Mac键盘和MacBook上键盘一样，除了键盘灯。Mac键盘和普通键盘差别不大，除了独有的Command键。感觉Mac键盘用硬币拧开的电池盖设计很赞。</p><p>还有鼠标键盘与iMac的蓝牙连接，没有USB线的纠缠。我曾试验过用鼠标关了iMac的蓝牙，一瞬间鼠标键盘失效了，没办法控制iMac。那怎么打开蓝牙啊？有同事建议我找个普通USB鼠标连上打开蓝牙，其实用不着，过一会iMac会自动开启蓝牙，连接鼠标键盘。还发现当用普通USB鼠标连接Mac的时候，Mac里所有滚动条会一直显示，而用Mac鼠标时，滚动条会隐藏。Mac系统是有多讨厌普通鼠标？</p><p>Mac鼠标键盘唯一感觉不好的是电池用的太快，键盘鼠标各两节带聚能环的南孚电池，显然聚能环也抵挡不了压榨，电池用不了多久就用光了，键盘还好些，鼠标太费电。后来Apple发布了可充电鼠标键盘，键盘充电还好，鼠标充电的时候总感觉怪怪的，像是把充电线插入了不可描述的部位。</p><h2 id="MacBook-Pro-15英寸"><a href="#MacBook-Pro-15英寸" class="headerlink" title="MacBook Pro 15英寸"></a>MacBook Pro 15英寸</h2><p>2014年圣诞节前，购买了一台15英寸的MacBook Pro，就是第一张图中左侧的那台MacBook。也圆了我多年想拥有一台MacBook的愿望。买这台MacBook还得感谢下产品经理猫哥，以8折优惠价拿下了14288的MacBook Pro。</p><p>记得当时买了没多久就出了触摸板Touch ID功能和蝴蝶键盘的MacBook，对于电子产品，我从来都没有买了后出了新款会感觉亏了。就像2011年买的ThinkPad E40，当时也算中高配，现在成渣渣了。穷逼永远追不上电子产品的换代速度，索性坦然面对。要不然现在都出TouchBar的MacBook了，我能怎么样？</p><p>当时公司还是给我配备了iMac，但是刚入手MacBook的那种喜悦兴奋感，以至于让我每天背着4斤多的电脑从昌平到国贸上班，那台iMac当显示器用了。当时我还有个iPad Air，每天挤地铁拿着9.7英寸的iPad Air看&lt;行尸走肉&gt;，背上还有个4斤多的MacBook，现在想想真傻逼。以至于现在我十分抵触背电脑，给我电脑补助我也不背自己电脑上下班(其实还是给少了，一个月给我两千块，iMac我也背)。</p><p>MacBook用着虽然没有iMac大屏的酸爽(由于当时有台iMac当显示屏，完全没有MacBook小屏幕的憋屈感)，但是功能强大的触摸板，柔光闪亮的键盘灯，白光的苹果logo灯，和上就走、打开就用的便捷还是让我一用就倾心。2015年出的MacBook Air取消了logo灯，2016年出的MacBook Pro依旧没有了logo灯，白光的苹果logo灯也成了历史。MacBook越来越薄，删减的东西也越来越多，光驱没了，网线口没了，呼吸灯没了，logo灯没了，USB没了，功能键没了……以后会不会变为光影键盘和触摸板合一，无线充电取消全部接口，可以折叠放在皮鼓兜里呢？</p><p>入手MacBook后，是我用苹果产品最多的时候，MacBook Pro是主要编程工具，iMac作为显示器在旁边辅助，iPad Air上下班看视频和做测试，用了多年的Android机也丢掉换成iPhone6了，还有一台iPhone5s测试机。当时作为一个没有女朋友的屌丝，这些奢华的设备配置填补了我内心的小空虚。然而，一切并没有什么卵用。</p><p>后来我用一台2011年的Mac mini也没感觉有什么心理落差，我还是一个程序猿，还是敲代码。区别的是我有女朋友了，啊哈哈哈哈……</p><h2 id="MacBook-Pro-13英寸"><a href="#MacBook-Pro-13英寸" class="headerlink" title="MacBook Pro 13英寸"></a>MacBook Pro 13英寸</h2><p>后来离职去了另一家公司，当时我已经不愿背电脑上下班了。公司给我配了一台全新的13英寸MacBook Pro，之所以说全新，是因为包装都是我拆的。当时对电脑没有太大要求，给我台mini也可以(黑苹果就算了吧)，新旧就更不会太在乎了。好在我已经坦然了，上家公司那种Apple设备环绕的情景直至现在都没再现过，而且配备的设备越来越老旧，越来越次。</p><p>用习惯了15英寸，用13英寸感觉好小。Xcode全屏都感觉放不开，而且公司没有配备外接显示器，这就有点憋屈的尴尬了。好在Mac系统可以加多个桌面，切换起来也十分方便。其实编程有个外接显示器真挺重要，至少我看原型图不用切换桌面。</p><p>13英寸跟15英寸的一大设计区别就是音响位置，15英寸的在键盘两边，13英寸的在电脑底部。尴尬的是躺床上看电影，把电脑放腿上容易堵住音响口。</p><p>自我感觉，敲代码和商务办公来说MacBook比普通Windows好些。有人吐槽Mac的office软件兼容垃圾，可应用软件少，浏览器兼容差，Mac AppStore软件价格昂贵等等。其实都是事在人为，有钱的买正版，没钱的找破解版，Mac软件并不少，少的是你知道的搜索渠道。但对于那些只支持IE浏览器而你又不得不用的网站(比如某些官方考试报名网站)，我只能说：你个垃圾！说完之后默默地打开虚拟机用IE登录。不得不说Mac的系统性能体验，操作方式的独特化简约，超强的续航能力，这些都是选择Mac的原因，当然还有绝不可忽视的装逼体验。</p><p>买iPhone玩游戏是上策，iOS的游戏数量、质量、游戏体验都很不错。但是买Mac玩游戏那可算是失策了，Mac AppStore上的游戏不仅少而且贵，好多单机没有Mac版，一些网游都没有Mac版支持。我电脑游戏玩的少，这方面没什么体验。记得我同学当时换了MacBook玩DNF，没有国服只能玩美服，后来为了玩国服怒装虚拟机。</p><h2 id="2011款Mac-mini"><a href="#2011款Mac-mini" class="headerlink" title="2011款Mac mini"></a>2011款Mac mini</h2><p>那台13英寸的MacBook Pro我用了没多久就不用了，因为我离职了，公司不让带走，我就没再用。新公司如愿以偿的给我配了台mini(所以说flag不能随便立)，值得称赞的是显示器比较大，是28英寸的(我也是能习惯性的从不幸中找到幸运)。</p><p>第一次用mini不习惯，一时间差点没找到开机键在哪。还有隐藏在后面的各种插孔，每次连接手机数据线USB插口转三次才能摸索着插进去。插耳机总是不小心插进旁边的话筒插孔里，而且耳机孔太紧，位置又在后面，手滑的话根本拔不出来。我还比较庆幸，mini电源插头是国标的，我一个同事用的mini的电源线是英标插头，那硕大的插头，四四方方铜脚，都快把插排撑裂了才插上。</p><p>开始连接mini的键盘是普通键盘，没有command键只能用Ctrl，以前是拇指按command配合使用快捷键，现在小指按Ctrl配合使用快捷键，每次都是按完之后发现不对再改。后来实在受不了，在公司找了一个Mac键盘替换了。但是鼠标自始至终都是普通鼠标，不但所有的页面滚动条都一直显示，而且没办法用鼠标快速切换桌面或排列显示桌面所有打开应用，只能control + 方向键。还有一种方法设置桌面触发角，将鼠标移动到桌面某个角，会实现某种操作，这个太不方便了，鼠标总会不小心的移动到某个角落触发某个操作。</p><h2 id="2010款MacBook-Pro-17英寸"><a href="#2010款MacBook-Pro-17英寸" class="headerlink" title="2010款MacBook Pro 17英寸"></a>2010款MacBook Pro 17英寸</h2><p>后来因为工作需要，公司台式机统一换本。我换了台17英寸的MacBook Pro，这是我第一次见17英寸的MacBook Pro，有光驱，有呼吸灯，有网线接口，那么厚、那么大、那么重。这台17英寸的MacBook Pro是2010年年末出的，当时售价1.7万，有6斤重，现在已经停产了。给我的时候还没有硬盘，开了半天没开开，我以为坏了。安了个硬盘装了系统，用起来还是蛮不错的。</p><p>天真的我以为不用自己电脑就不用背电脑上下班了，现实给了我一个大耳光，醒醒吧，背着公司的本上下班，回家随叫随到敲代码！我就呵呵了，4斤的不想背，现在让我背6斤的，而且没有电脑补贴，因为你没用自己的本。好在上班离家近，不用挤地铁。但是每天背上贴着一个6斤的金属板蹬自行车，到公司内裤都湿了，时间一长说出大天来我也不想背了。再说了，我家里有本，公司都用git，哪个本不能敲代码，把本当爹了？天天背着上下班。</p><p>17英寸的MacBook分辨率比Retina屏的小，但是17英寸的MacBook上显示的内容比较小，这样一来屏幕中容纳的内容就比较多。虽然17英寸的屏幕不是很大(在笔记本里还是很大的)，但是用起来感觉不到憋屈，内容显示还是很宽松的。</p><p>虽然这个MacBook厚重些，但是相比用mini，感觉用本还是好点。毕竟键盘+触摸板比键盘+普通鼠标体验强太多了。MacBook的光驱是吸入式光驱，键盘右上角的键是推出光驱用的，开机键独立在右上角金属板上，后来去掉了光驱，开机键也取代了推出光驱键的位置。</p><p>虽然有光驱，但是我从来没用过，即便是我第一台电脑ThinkPad上的光驱也没用过几次。后来的MacBook去掉了光驱和网线口可谓明智之举，现在光盘几乎退出历史舞台，无线网遍布世界。为啥呼吸灯也去掉了？睡眠的时候一闪一闪挺有睡眠的样子的。</p><p>2016款MacBook去掉了USB3和Thunderbolt2接口，全换成了USB-C接口，不知道这次大刀阔斧的改进，在未来会有什么样的历史评价。但是现在最新款iPhone7不能直接连接到MacBook上，这到底几个意思？</p><h2 id="2011款MacBook-Pro-13英寸"><a href="#2011款MacBook-Pro-13英寸" class="headerlink" title="2011款MacBook Pro 13英寸"></a>2011款MacBook Pro 13英寸</h2><p>后来因为工作原因，17英寸MacBook Pro换成了13英寸的MacBook Pro。虽然尺寸变小了，但是厚度没变，因为这款MacBook还是2011款带光驱的。</p><p>iOS开发环境没有什么可配置的，安装一个Xcode基本就搞定一多半了。麻烦的是证书配置，要想真机测试，打包发布应用，必须经历一系列的证书配置。像我这种电脑里有3+以上个开发者账号，个人企业公司级全有，配置起来下一步下一步下一步，真是烦透了。可喜的是在换电脑的同时，硬盘也换了。我把17英寸MacBook上的硬盘拆下来，装在了13英寸的MacBook上了，亲测证明，系统还是原来的系统，证书还是原来的配方，一切都不用重新配置。只是在打包app的时候验证一下开发者账号密码即可。</p><p>细数这些年用过的Mac，几经变换，从未重复用过一款。落魄时用过黑苹果、Mac mini，辉煌时桌子上摆过苹果N件套，堂堂iMac当显示器用。一切皆浮云，我依旧是个玩电脑的穷逼程序猿。一直以来陪伴我的是15英寸那款MacBook Pro(因为是我掏腰包买的)，以前陪着我，现在陪着我，将来还会陪着我，我不会像糟蹋小黑本那样糟蹋你，其他的都是工具，而你是我朋友(自己掏钱买的就是不一样)。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>从去年写这篇文章到现在，我一直用着这款13英寸的MacBook Pro，区别的是外接了一台Dell显示器，外加媳妇送的HHKB键盘和Magic Mouse 2鼠标。这台老破小Mac连接这些外设也算梅开二度、老木逢春。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;旧文新录，这篇文是去年写的，一直放在简书上。今天把他放到blog里，日后翻出来看看也挺有意思。&lt;/p&gt;
    
    </summary>
    
    
      <category term="程序人生" scheme="http://markmiao.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="macOS" scheme="http://markmiao.com/tags/macOS/"/>
    
  </entry>
  
</feed>
