<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mark Miao</title>
  <subtitle>Mark’s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://markmiao.com/"/>
  <updated>2016-12-31T04:23:34.000Z</updated>
  <id>http://markmiao.com/</id>
  
  <author>
    <name>Mark</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2016我的年终总结</title>
    <link href="http://markmiao.com/2016/12/31/2016%E6%88%91%E7%9A%84%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://markmiao.com/2016/12/31/2016我的年终总结/</id>
    <published>2016-12-31T04:19:49.000Z</published>
    <updated>2016-12-31T04:23:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉2016年结束了，离梦想又远了一步。在微博上看到一句话：“十年前并不是九几年而是零六年！”那一瞬间感觉自己真的老了。90后已不再是年轻的标签，奔三也奔的那么马不停蹄。三十而立，到现在依旧晃晃悠悠，到三十那天我真能立住吗？怎么立？金鸡独立？又或者是静静地坐着敲代码，平凡的度过本以为不平凡的那一天。</p>
<a id="more"></a>
<p>来北京四年了，每年都有不一样的事，每年都遇到不一样的人。谈不到精彩，相对于平淡总有一些波澜，可以厚颜无耻的说一句：我还年轻没到平淡的年纪。回头看看这一年，总觉得这是我最忙碌、变化最大的一年。具体想想有哪些变化，貌似也没什么。是虚度了时光，还是矫情了岁月？</p>
<h2 id="工作和技术"><a href="#工作和技术" class="headerlink" title="工作和技术"></a>工作和技术</h2><p>工作方面没有多大改变，依旧敲代码。2015年国庆假期结束入职现在这家公司，app开发了一堆，拿的出手的却没有。工作相对于在以前公司的时候清闲多了，几乎没加过班。一方面是工作经验多了的原因，对于工作中遇到的问题，也不像初入行时那么手忙脚乱了。另一方面是项目周期长，时间充裕。记得我刚入行时的第一家公司，项目周期短，需求变化大，迭代迅速，差不多一两周出一版。就是赶着AppStore的审核时间，等待审核期间新需求就出来了，审核通过上架了，新版本也开发的差不多了，继续提交。快速增长期的创业公司就是这个节奏，那段时间经常通宵加班，睡在公司。我的上一辆自行车停在地铁口，通宵加班两天，第三天回来的时候不见了。那段时间真是加班加的快吐了，简直是张口就要骂娘的状态，那时最大的愿望就是下班时能看到夕阳。但那段时间也是我技术提升最快的时候，现在闲下来了，反而有些怀念当时受虐的日子，人真是有些贱骨头。</p>
<p>技术方面没有大的提升，作为本职工作的iOS开发，钻研的还不够，好多深层次的东西都不懂。有时候看到和我差不多时间入行，甚至比我入行还晚的人写的技术博客，令我惭愧不已。我不但写不出来，甚至都看不懂，我都不好意思说比别人早入行。前段时间在微博上看到一段话，是面试官对面试者说的话：你不是有N年经验，你是一年经验用了N年。当时感觉被狠狠抽了一个大嘴巴子，这他妈不就是说的我吗？安逸的工作环境使人颓废，多少次励志，多少次放弃，间歇性踌躇满志，持续性混吃等死。感觉膝盖狠狠地中了一箭，长跪不起。客观来说，技术还是有些提升，虽然提升幅度不值一哂。swift、Mac、git、Python、h5、JavaScript……这些多少有些涉猎，嗯……好吧，目前还停留在涉猎层面。一直十分佩服那些能按部就班沉下心了学习一门技术的人，能让自己不断学习的人，就是所谓成功的一类人吧，即使目前不成功，成功的那天总不会很远。</p>
<h2 id="生活和爱情"><a href="#生活和爱情" class="headerlink" title="生活和爱情"></a>生活和爱情</h2><p>生活方面算是变化最大的了，2016年春节过后，和女朋友搬到现在居住的地方，脱离了以前合租的窘境。6月份头脑一热养了一只金毛，现在他已经有九个月了。硕大的体型、对人忘我般的热情，每当遛他的时候，总担心他扑向陌生人。虽然他性情温顺，但毕竟体型太大，对人又热情，喜欢闹腾。除了了解金毛、喜欢狗狗的人能和他玩玩，其他人即便喜欢也不敢靠近。养过狗狗才知道，养狗真的挺麻烦的，特别是养一只大狗。烦透了的时候忍不住揍一顿，揍完又感觉他好可怜。我对晓说：他就像是个意外怀孕的孩子，讨人厌又惹人怜。晓说：也是一个家庭成员，好好养着吧。有时上班不在家，透过摄像头看到他静静地坐在窗前，看窗外车来车往，感觉他好想出去玩，像个孩子……</p>
<p>晓是和我在2016年元旦之前去我家的，那也是她第一次去我家，第一次见我父母。我见她父母是在3月份，和她一家人去了一趟西安。晓美其名曰旅行见父母，其实就想出去浪一下。最终圆满，我父母对晓非常喜欢，晓的父母对我也十分满意。7月份，我父母来北京，双方父母进行了亲切友好的会谈，对我们的终身大事交换意见，并达成一致协议。10月份，在晓的父母的陪同下，晓和我在我家举行了订婚仪式，亲朋好友献上真诚祝福。在北京，我从一个通宵加班两天、自行车丢了都没人问的单身狗，变成了一个有小窝、有爱人、有孩子(目前是宠物)的程序猿。这一波虐狗得负刑事责任了……</p>
<h2 id="读书和旅行"><a href="#读书和旅行" class="headerlink" title="读书和旅行"></a>读书和旅行</h2><p>都说读万卷书，行万里路。这两者缺一不可。一直以来，我都是喜欢看旧书，不愿去翻开一本新书。有的书我都读过十几二十几遍了，想读书的时候还会去读那些，当然都不是什么技术型书籍。读书确实是提升自己最有效的方式，读书破万卷，下笔如有神，古人诚不欺我。当然我离这个境界还差十万八千里，但我希望我能向着这个目标不断前进。年底看了一本新书，吴晓波写的《腾讯传》，讲述了腾讯的发展史，记录了一个互联网巨型企业一路走来的跌宕坎坷，我看到了任何成功都容不得半点侥幸，腾讯的崛起也绝非偶然。</p>
<p>旅行是费钱的，但长久看来收益大于付出。2015年有过一次旅行，和晓去四川成都，去了宽窄巷子、大熊猫培育基地、九寨沟，最终由于我发高烧仓促返京。2016年有过两次远途旅行，第一次是和晓的家人去西安，第二次是和晓去香港。每次旅行或多或少都会有遗憾，或许根本不可能存在完美的旅行，有不完美才会有下一次的追求完美。明年还会去旅行，目的地还没想好，我会为了完美的旅行做更多的准备，虽然肯定还会有不完美。</p>
<p>前几天看到一段话：如果不读书，行万里路也不过是个邮差。仔细想想蛮有道理的，庐山瀑布有亿万人望过，也只有李白写出了“飞流直下三千尺，疑是银河落九天”的绝句。有多少文化底蕴才能读出美景的多少韵味，看到草原，牛想到的是饱餐一顿，诗人想的是天苍苍，野茫茫，风吹草低见牛羊。打住！这段话纯属吹牛逼，我也不相信一个程序猿到一个地方首先想到的是美景而不是美食。我是一个爱吃的俗人，不是爱景诗人，但我知道多读书能多挣钱，多挣钱能多旅行，多旅行才能吃到更好的美食。</p>
<h2 id="大环境和小愿望"><a href="#大环境和小愿望" class="headerlink" title="大环境和小愿望"></a>大环境和小愿望</h2><p>2016年，互联网行业历经寒冬，从波澜翻滚变成了暗潮涌动。记得前几年，互联网创业随处可见，创业门槛低到有台电脑就行，到处都能听到风投融资的故事。雷军说：站在风口上，猪都会飞。今年风小了，好多猪摔死了。光我认识的同学朋友圈子里，就有五六家公司关门大吉，我这个小圈子都如此，可见这个大行业的动荡。互联网行业从疯狂渐渐趋向沉稳，从互联网行业招聘就可以看出来，程序员找工作难，iOS更是难于上青天。有AppStore上架作品已不再是加分项，而是基本技能。网上有人说：招Android和iOS两个职位，Android一天收到十几份简历，iOS能收到几百份简历！多少iOS开发者抱着简历海投，只求一份工作。有人抱怨iOS不行了，转投H5。相信过不了多久你又会抱怨H5不行了，那时候你转投什么呢？在一篇博文里看到这么一段话：不是这个行业不行，而是你不行。事实如此，无数iOS开发者找不到工作的同时，也有无数企业招不到合适的iOS开发。需求和供应有时就是这么尴尬的不对等，作为程序员，职责就是实现各种需求，不是等着适合自己的需求再去实现。好了，牛逼吹完了，我该去给老板的iPhone7 Plus贴膜了。</p>
<p>2016年，技术爆发的一年。层出不穷的新技术令人眼花缭乱，swift出到3.0，每一版都像是一门新的语言；JavaScript和h5也日益繁荣，就像几年前的iOS；Python、PHP老牌语言和新秀Go语言也火的不要不要的了；iOS开发的热更新也花样繁多，JSPatch，今年年底滴滴的DynamicCocoa；跨平台的方式也越来越多，Facebook的React Native，阿里的Weex；还有年底微信横空出世的小程序……</p>
<p>我是一头赶上风口飓风的猪，压迫着骨子里的惰性努力瘦身，希望在风停的时候不至于摔死。2016年年底做的最正确的事就是购买域名搭建了自己的博客，这件本应早几年就做的事，一直拖到了现在。有了自己的博客和订阅号，还有github的小绿格子，在这些面子工程的倒逼下或许不会那么容易就轻言放弃。</p>
<p>2016再见，2017你好。新年愿望是：希望2017年的年终总结里没有懊悔。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉2016年结束了，离梦想又远了一步。在微博上看到一句话：“十年前并不是九几年而是零六年！”那一瞬间感觉自己真的老了。90后已不再是年轻的标签，奔三也奔的那么马不停蹄。三十而立，到现在依旧晃晃悠悠，到三十那天我真能立住吗？怎么立？金鸡独立？又或者是静静地坐着敲代码，平凡的度过本以为不平凡的那一天。&lt;/p&gt;
    
    </summary>
    
      <category term="记事" scheme="http://markmiao.com/categories/%E8%AE%B0%E4%BA%8B/"/>
    
    
      <category term="总结" scheme="http://markmiao.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="生活" scheme="http://markmiao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>私有API的使用</title>
    <link href="http://markmiao.com/2016/12/28/%E7%A7%81%E6%9C%89API%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://markmiao.com/2016/12/28/私有API的使用/</id>
    <published>2016-12-28T09:42:20.000Z</published>
    <updated>2016-12-28T09:45:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>私有API是指苹果未公开的一些方法，通常情况下这些方法不允许开发者使用，通常情况是指上架AppStore。私有API可以实现一些开放API不能实现的效果，功能强大，效果非凡。苹果不允许使用，是因为有些私有API会侵犯用户隐私，但使用私有API也并非一定会侵犯用户隐私，这要看开发者怎么用了。</p>
<a id="more"></a>
<p>企业级账号发布供内部人使用的APP，可以使用私有API。发布到其他APP平台供越狱手机下载的APP，也有可能使用了私有API。这两者没有苹果审核把关，私有API可以随便使用。<strong>苹果明令禁止使用私有API的APP上架AppStore！</strong>但凡事无绝对，AppStore上也不乏使用私有API的应用，使用办法有很多，比如热更新。不被苹果发现就行，发现了轻者下架，重者封号。</p>
<p>我想看看私有API到底能干些啥，写了一个测试私有API的小项目，涉及到的知识点大多数来源于网络，在此感谢大神们的知识共享。项目很小，知识很浅，欢迎拍砖吐槽。</p>
<p>项目代码: <a href="https://github.com/mxdios/privateApiApps" target="_blank" rel="external">privateApiApps</a></p>
<p>开发环境: Xcode 8.2.1，iPhone 6，iOS 10.2</p>
<p>项目截图:</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="http://oalg33nuc.bkt.clouddn.com/WechatIMG241.jpeg" alt="获取iPhone上的所有APP"></th>
<th style="text-align:center"><img src="http://oalg33nuc.bkt.clouddn.com/WechatIMG242.jpeg" alt="APP相关信息"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>参考资料:</p>
<ol>
<li><a href="https://github.com/nst/iOS-Runtime-Headers" target="_blank" rel="external">iOS-Runtime-Headers</a></li>
<li><a href="http://octree.me/2016/08/01/get-installed-apps/" target="_blank" rel="external">获取iOS设备上安装的应用列表</a></li>
</ol>
<h2 id="获取iPhone中安装的APP列表"><a href="#获取iPhone中安装的APP列表" class="headerlink" title="获取iPhone中安装的APP列表"></a>获取iPhone中安装的APP列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class LSAppClass = objc_getClass(&quot;LSApplicationWorkspace&quot;);</div><div class="line">NSObject *workspace = [LSAppClass performSelector:@selector(defaultWorkspace)];</div><div class="line">NSArray *appsArray = [workspace performSelector:@selector(allApplications)];</div></pre></td></tr></table></figure>
<p>这里面使用了runtime的方法<code>- (id)performSelector:(SEL)aSelector;</code>，需要引入<code>&lt;objc/runtime.h&gt;</code>。该方法的作用是给接收者传递进去一个方法，返回值就是这个方法执行后的返回值。</p>
<p>由于调用的是私有API，传入的方法相当于一个字符串，编译器不会检测该方法是否正确，相反会一直报警告。例如上面传递的方法<code>defaultWorkspace</code>，这是个私有API的方法。通常还有另一种调用<code>performSelector</code>方法的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSObject *workspace = [LSAppClass performSelector:NSSelectorFromString(@&quot;defaultWorkspace&quot;)];</div></pre></td></tr></table></figure>
<p>如果传递进去的私有API方法名写错了，程序就会找不到该方法而崩溃。所以通常会通过下面方法检测接收者或接收者的父类是否实现了传递进去的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)respondsToSelector:(SEL)aSelector;</div></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ([LSAppClass respondsToSelector:@selector(defaultWorkspace)]) &#123;</div><div class="line">   	NSObject *workspace = [LSAppClass performSelector:@selector(defaultWorkspace)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>真实情况中，该方法并非必要。传入的私有API方法名都是固定的，程序崩溃了说明方法名写错了，改成正确的即可。使用该方法不会崩溃，反而不易发现错误。</p>
<h2 id="获取每个APP的相关信息"><a href="#获取每个APP的相关信息" class="headerlink" title="获取每个APP的相关信息"></a>获取每个APP的相关信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[appsArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;   </div><div class="line">	AppsObject *appsObj = [[AppsObject alloc] init];</div><div class="line">	appsObj.appName = [obj performSelector:@selector(localizedName)];</div><div class="line">	appsObj.version = [obj performSelector:@selector(shortVersionString)];</div><div class="line">	appsObj.bundleId = [obj performSelector:@selector(applicationIdentifier)];</div><div class="line">	appsObj.appFullName = [obj performSelector:@selector(itemName)];</div><div class="line">	appsObj.appType = [obj performSelector:@selector(applicationType)];</div><div class="line">	appsObj.appVendorName = [obj performSelector:@selector(vendorName)];</div><div class="line">	appsObj.appRating = [obj performSelector:@selector(ratingLabel)];</div><div class="line">	[_appsObjArray addObject:appsObj];</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<p>遍历获取的APP列表，通过私有API获取每个app的各种信息：</p>
<table>
<thead>
<tr>
<th style="text-align:left">私有API方法名</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">localizedName</td>
<td style="text-align:left">app名字</td>
</tr>
<tr>
<td style="text-align:left">shortVersionString</td>
<td style="text-align:left">版本号</td>
</tr>
<tr>
<td style="text-align:left">applicationIdentifier</td>
<td style="text-align:left">Bundle Identifier</td>
</tr>
<tr>
<td style="text-align:left">itemName</td>
<td style="text-align:left">app在AppStore显示的名字</td>
</tr>
<tr>
<td style="text-align:left">applicationType</td>
<td style="text-align:left">app类型,分为:System和User</td>
</tr>
<tr>
<td style="text-align:left">vendorName</td>
<td style="text-align:left">app供应商</td>
</tr>
<tr>
<td style="text-align:left">ratingLabel</td>
<td style="text-align:left">app评级</td>
</tr>
</tbody>
</table>
<h2 id="获取APP图标"><a href="#获取APP图标" class="headerlink" title="获取APP图标"></a>获取APP图标</h2><p>上述中并没有获取APP图标的方法，获取app图标比较麻烦。</p>
<h3 id="获取APP图标路径"><a href="#获取APP图标路径" class="headerlink" title="获取APP图标路径"></a>获取APP图标路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSDictionary *dict = [object performSelector:@selector(boundIconsDictionary)];</div><div class="line">NSString *appIconPath = [NSString stringWithFormat:@&quot;%@/%@.png&quot;,[[object performSelector:@selector(resourcesDirectoryURL)] path],[[[dict objectForKey:@&quot;CFBundlePrimaryIcon&quot;] objectForKey:@&quot;CFBundleIconFiles&quot;] lastObject]];</div></pre></td></tr></table></figure>
<p>iOS10.2亲测，该方法只能获取模拟器上的APP图标，真机无效。</p>
<h3 id="获取图标data数据"><a href="#获取图标data数据" class="headerlink" title="获取图标data数据"></a>获取图标data数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appsObj.iconData = [obj performSelector:@selector(iconDataForVariant:) withObject:@(2)];</div></pre></td></tr></table></figure>
<p>该data数据并不能直接转为UIImage，需要对data数据进行截取转换，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+ (UIImage *)getAppIcon:(NSData *)iconData &#123;</div><div class="line">    NSInteger lenth = iconData.length;</div><div class="line">    NSInteger width = 87;</div><div class="line">    NSInteger height = 87;</div><div class="line">    uint32_t *pixels = (uint32_t *)malloc(width * height * sizeof(uint32_t));</div><div class="line">    [iconData getBytes:pixels range:NSMakeRange(32, lenth - 32)];</div><div class="line">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    CGContextRef ctx = CGBitmapContextCreate(pixels, width, height, 8, (width + 1) * sizeof(uint32_t), colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);</div><div class="line">    CGImageRef cgImage = CGBitmapContextCreateImage(ctx);</div><div class="line">    CGContextRelease(ctx);</div><div class="line">    CGColorSpaceRelease(colorSpace);</div><div class="line">    UIImage *icon = [UIImage imageWithCGImage: cgImage];</div><div class="line">    CGImageRelease(cgImage);</div><div class="line">    return icon;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="打开APP"><a href="#打开APP" class="headerlink" title="打开APP"></a>打开APP</h2><p>在iOS 9以后要想打开其他app需要添加URL Scheme，设置白名单，否则将无法打开，白名单的上限为50个。上文中我们可以获取APP的<code>Bundle Id</code>，依靠<code>Bundle Id</code>使用私有API可以打开其他APP，并没有数量限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class LSAppClass = NSClassFromString(@&quot;LSApplicationWorkspace&quot;);</div><div class="line">id workSpace = [(id)LSAppClass performSelector:@selector(defaultWorkspace)];</div><div class="line">[workSpace performSelector:@selector(openApplicationWithBundleID:) withObject:self.appsObj.bundleId];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;私有API是指苹果未公开的一些方法，通常情况下这些方法不允许开发者使用，通常情况是指上架AppStore。私有API可以实现一些开放API不能实现的效果，功能强大，效果非凡。苹果不允许使用，是因为有些私有API会侵犯用户隐私，但使用私有API也并非一定会侵犯用户隐私，这要看开发者怎么用了。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://markmiao.com/tags/iOS/"/>
    
      <category term="私有API" scheme="http://markmiao.com/tags/%E7%A7%81%E6%9C%89API/"/>
    
  </entry>
  
  <entry>
    <title>Quartz 2D（三）样式、阴影、渐变</title>
    <link href="http://markmiao.com/2016/12/21/Quartz2D3/"/>
    <id>http://markmiao.com/2016/12/21/Quartz2D3/</id>
    <published>2016-12-21T07:03:09.000Z</published>
    <updated>2016-12-21T07:04:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><p>Pattern可翻译为样式、模型。类似于iOS中自定义的view，可以重复多次把自定义的view添加到控制器的view上。样式(Pattern)是绘制操作的一个序列，可以重复的绘制到一个图形上下文上。</p>
<a id="more"></a>
<h3 id="样式单元格"><a href="#样式单元格" class="headerlink" title="样式单元格"></a>样式单元格</h3><p>样式单元格是样式的基本组件，在创建的时候就要定义单元格的边界，并在这个范围内进行绘制。在图形上下文上绘制单元格时，可以随意指定两个单元格之间上下左右间距，也可以指定负数，单元格重合而已。像极了添加view控件。</p>
<h3 id="着色样式和模板样式"><a href="#着色样式和模板样式" class="headerlink" title="着色样式和模板样式"></a>着色样式和模板样式</h3><p>着色样式是有固定颜色的，在创建样式单元格的时候就指定其颜色了，跟绘制流程没有关系。</p>
<p>模板样式即为非着色样式，在创建样式单元格的时候只指定了形状，并没有指定颜色，在绘制过程中指定颜色。</p>
<p>在Quartz 2D中可以使用这两种样式实现样式绘图，将创建好的样式绘制到page上的过程称为平铺，有三种平铺选项：1、没有失真，2、最小的失真的恒定间距，3、恒定间距。</p>
<h3 id="绘制着色样式"><a href="#绘制着色样式" class="headerlink" title="绘制着色样式"></a>绘制着色样式</h3><p>绘制着色样式一般需要下面几步：1、设置样式单元格的回调函数，2、设置着色模式单元格，3、绘制操作。下面是绘制着色样式的示例代码和运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    [super drawRect:rect];</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    clorePatternPaingting(context, CGRectMake(0, 0, 300, 500));</div><div class="line">&#125;</div><div class="line">void clorePatternPaingting(CGContextRef context, CGRect rect) &#123;</div><div class="line">    CGColorSpaceRef patternSpace = CGColorSpaceCreatePattern(NULL);</div><div class="line">    CGContextSetFillColorSpace(context, patternSpace);</div><div class="line">    CGColorSpaceRelease(patternSpace);</div><div class="line">    static const CGPatternCallbacks call = &#123;0, &amp;drawPattern, NULL&#125;;</div><div class="line">    CGPatternRef pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 30, 30), CGAffineTransformIdentity, 30, 30, kCGPatternTilingConstantSpacing, true, &amp;call);</div><div class="line">    CGFloat alpha = 1.0;</div><div class="line">    CGContextSetFillPattern(context, pattern, &amp;alpha);</div><div class="line">    CGPatternRelease(pattern);</div><div class="line">    CGContextFillRect(context, rect);</div><div class="line">&#125;</div><div class="line">void drawPattern(void *info, CGContextRef context) &#123;</div><div class="line">    CGContextSetRGBFillColor(context, 1, 0, 0, 1);</div><div class="line">    CGContextFillRect(context, CGRectMake(0, 0, 10, 10));</div><div class="line">    CGContextSetRGBFillColor(context, 0, 1, 0, 1);</div><div class="line">    CGContextFillRect(context, CGRectMake(10, 0, 10, 10));</div><div class="line">    CGContextSetRGBFillColor(context, 0, 0, 1, 1);</div><div class="line">    CGContextFillRect(context, CGRectMake(0, 10, 10, 10));</div><div class="line">    CGContextSetRGBFillColor(context, 0.5, 0, 0.5, 1);</div><div class="line">    CGContextFillRect(context, CGRectMake(10, 10, 10, 10));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161220-0.png" alt="绘制着色模式的运行结果"></p>
<p><strong>代码解释：</strong></p>
<p>上述代码块中第三个函数<code>drawPattern</code>的作用就是第1步：设置样式单元格的回调函数。参数<code>info</code>:是指向模式相关数据的指针，可以传<code>NULL</code>。<code>context</code>:是图形上下文。在该函数中指定了每个颜色块的大小和填充色。因为是着色样式，所以指定填充色。</p>
<p>第二个函数，也是在<code>drawRect</code>方法中调用的函数<code>clorePatternPaingting</code>，执行了第2步:设置着色模式单元格和第3步:绘制操作。下面对每块代码进行解释：</p>
<p><strong>清空基本颜色空间：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGColorSpaceRef patternSpace = CGColorSpaceCreatePattern(NULL);</div><div class="line">CGContextSetFillColorSpace(context, patternSpace);</div><div class="line">CGColorSpaceRelease(patternSpace);</div></pre></td></tr></table></figure>
<p>因为我们要使用着色样式里面的颜色，所以清空基本颜色空间，以确保着色样式上的颜色能显示。可以试一下把这段代码注释的结果，绘制着色样式的空间为黑色，因为基本颜色空间没清空也没着色，所以呈黑色。</p>
<p><strong>设置着色模式单元格：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static const CGPatternCallbacks call = &#123;0, &amp;drawPattern, NULL&#125;;</div><div class="line">CGPatternRef pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 30, 30), CGAffineTransformIdentity, 30, 30, kCGPatternTilingConstantSpacing, true, &amp;call);</div></pre></td></tr></table></figure>
<p>模式单元格的信息保存在<code>CGPatternRef</code>类型的<code>CGPattern</code>对象中，使用<code>CGPatternCreate</code>创建该对象。需要传入的参数依次解释为：</p>
<ol>
<li>info：是一个指针，指向我们要传递给绘制回调函数的数据。这里传的是<code>NULL</code></li>
<li>bound：指定模式单元格的大小</li>
<li>matrix：指定模式矩阵，它将模式坐标系统映射到图形上下文的默认坐标系统。如果希望两个坐标系统是一样的，则可以使用单位矩阵。</li>
<li>xStep, yStep：指定单元格之间的水平和竖直间距。</li>
<li>tiling：平铺模式，可以是kCGPatternTilingNoDistortion、kCGPatternTilingConstantSpacingMinimalDistortion、kCGPatternTilingConstantSpacing</li>
<li>isColored：指定模式单元格是着色模式(true)还是模板模式(false)</li>
<li>callbacks：是一个指向CGPatternCallbacks结构体的指针。格式如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct CGPatternCallbacks &#123;</div><div class="line">    unsigned int version;</div><div class="line">    CGPatternDrawPatternCallback __nullable drawPattern;</div><div class="line">    CGPatternReleaseInfoCallback __nullable releaseInfo;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>version</code>一般设置为<code>0</code>，<code>drawPattern</code>是指向设置样式单元格的回调函数，<code>releaseInfo</code>是指向回调函数，释放CGPattern对象时调用，以释放存储在我们传递给绘制回调的info参数中的数据。如果在这个参数中没有传递任何数据传<code>NULL</code>。</p>
<p>所以<code>CGPatternCallbacks</code>结构体定义为<code>static const CGPatternCallbacks call = {0, &amp;drawPattern, NULL};</code></p>
<p><strong>绘制着色样式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CGFloat alpha = 1.0;</div><div class="line">CGContextSetFillPattern(context, pattern, &amp;alpha);</div><div class="line">CGPatternRelease(pattern);</div><div class="line">CGContextFillRect(context, rect);</div></pre></td></tr></table></figure>
<p>调用函数<code>CGContextSetFillPattern</code>使用着色样式进行填充操作，或者调用函数<code>CGContextSetStrokePattern</code>进行描边操作。需要指定着色样式在填充或描边过程的透明度。</p>
<p>样式使用完毕后需要释放，调用函数：<code>CGPatternRelease</code></p>
<p>将定义的着色样式使用函数<code>CGContextFillRect</code>填充到指定<code>rect</code>的矩形中。</p>
<p>这一系列操作都放到函数<code>clorePatternPaingting</code>内，在<code>drawRect</code>方法中直接调用该函数即可完成着色样式的定义和绘制。</p>
<h3 id="绘制模板样式"><a href="#绘制模板样式" class="headerlink" title="绘制模板样式"></a>绘制模板样式</h3><p>绘制模板样式的步骤和绘制着色样式的一样：1、设置样式单元格的回调函数，2、设置模板模式单元格，3、绘制操作。下面是绘制模板样式的示例代码和运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    [super drawRect:rect];</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    stencilPatternPaingting(context, CGRectMake(0, 0, 300, 500));</div><div class="line">&#125;</div><div class="line">void stencilPatternPaingting(CGContextRef context, CGRect rect) &#123;</div><div class="line">    CGColorSpaceRef baseSpace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    CGColorSpaceRef patternSpace = CGColorSpaceCreatePattern(baseSpace);</div><div class="line">    CGContextSetFillColorSpace(context, patternSpace);</div><div class="line">    CGColorSpaceRelease(patternSpace);</div><div class="line">    CGColorSpaceRelease(baseSpace);</div><div class="line">    static const CGPatternCallbacks cell = &#123;0, &amp;drawStencilPattern, NULL&#125;;</div><div class="line">    CGPatternRef pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 30, 30), CGAffineTransformIdentity, 40, 40, kCGPatternTilingConstantSpacing, false, &amp;cell);</div><div class="line">    static const CGFloat color[] = &#123;1, 0, 0, 1&#125;;</div><div class="line">    CGContextSetFillPattern(context, pattern, color);</div><div class="line">    CGPatternRelease(pattern);</div><div class="line">    CGContextFillRect(context, rect);</div><div class="line">&#125;</div><div class="line">void drawStencilPattern(void *info, CGContextRef context) &#123;</div><div class="line">    CGContextAddEllipseInRect(context, CGRectMake(0, 0, 30, 30));</div><div class="line">    CGContextFillPath(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161220-1.png" alt="绘制模板样式的运行结果"></p>
<p>代码解释参考上文中着色样式的代码解释。区别1是用下述代码设置样式单元格的颜色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static const CGFloat color[] = &#123;1, 0, 0, 1&#125;;</div><div class="line">CGContextSetFillPattern(context, pattern, color);</div></pre></td></tr></table></figure>
<p>区别2是<code>CGPatternCreate</code>函数中传的参数是<code>false</code>。</p>
<h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>阴影有三个属性：x偏移量，y偏移量，模糊度</p>
<p>阴影通过函数<code>CGContextSetShadow</code>设置，指定图形上下文、x偏移量、y偏移量、模糊度。设置阴影后，绘制的对象都会有阴影，阴影的色值为0.3透明度的黑色，颜色RGBA值为{0, 0, 0, 0.3}。</p>
<p>也可以是使用函数<code>CGContextSetShadowWithColor</code>设置彩色阴影。</p>
<p>在调用<code>CGContextSetShadow</code>或<code>CGContextSetShadowWithColor</code>之前保存图形状态，可以通过恢复图形状态来关闭阴影。或者设置阴影颜色为<code>NULL</code>关闭阴影。</p>
<p>分别设置彩色阴影和普通阴影：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextSaveGState(context);</div><div class="line">CGContextSetShadowWithColor(context, CGSizeMake(10, 10), 2, [UIColor redColor].CGColor);</div><div class="line">CGContextSetRGBFillColor (context, 0, 1, 0, 1);</div><div class="line">CGContextAddEllipseInRect(context, CGRectMake(40, 40, 100, 100));</div><div class="line">CGContextFillPath(context);</div><div class="line">CGContextSetShadow(context, CGSizeMake(10, 10), 2);</div><div class="line">CGContextFillRect(context, CGRectMake(200, 40, 100, 100));</div><div class="line">CGContextRestoreGState(context);</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161220-2.png" alt="圆形的红色阴影和矩形的灰色阴影"></p>
<p>x偏移量正值在图形右边，负值在图形左边。y偏移量和坐标有关，在iOS中，UIKit坐标系y轴和Quartz 2D坐标系y轴相反，所以如果是由UIKit创建的图形上下文则正值在图形下面，负值在图形上面。macOS的坐标系和Quartz 2D坐标系一样，所以正值在图形上面，负值在图形下面。阴影绘制不受CTM影响。</p>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>可以使用函数<code>CGShadingRef</code>和<code>CGGradientRef</code>创建渐变。渐变分为轴向渐变和径向渐变。渐变的颜色变化有很多，可以是一种颜色到另一种颜色过度，也可以是多种颜色依次过度变化，还有是一种颜色的透明度<code>alpha</code>变化，但是这种无法绘制到PDF上，无法打印。</p>
<p><code>CGShading</code>和<code>CGGradient</code>的区别：</p>
<table>
<thead>
<tr>
<th style="text-align:left">CGGradient</th>
<th style="text-align:left">CGShading</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">可以使用同一对象绘制轴向和径向梯度</td>
<td style="text-align:left">需要创建单独的对象的轴向和径向梯度</td>
</tr>
<tr>
<td style="text-align:left">在绘图时设置渐变的几何体</td>
<td style="text-align:left">在对象创建时间设置渐变的几何体</td>
</tr>
<tr>
<td style="text-align:left">Quartz计算梯度中每个点的颜色</td>
<td style="text-align:left">需要提供一个回调函数，用来计算渐变中每个点的颜色</td>
</tr>
<tr>
<td style="text-align:left">可以定义两个以上的位置和颜色</td>
<td style="text-align:left">需要设计回调，使用两个以上的位置和颜色</td>
</tr>
</tbody>
</table>
<h3 id="CGGradient"><a href="#CGGradient" class="headerlink" title="CGGradient"></a>CGGradient</h3><p>使用CGGradient创建渐变。</p>
<ol>
<li>首先调用函数<code>CGGradientCreateWithColorComponents</code>创建<code>CGGradient</code>对象，参数含义分别是：颜色空间、颜色数组（采用RGBA颜色）、位置数组（0.0-1.0之间的数值，0.0为轴线起点，1.0为轴线终点。传递NULL默认0为起始位置，1为终点位置，相当于{0.0, 1.0}）、数组中元素个数。</li>
<li>调用<code>CGContextDrawLinearGradient</code>函数绘制轴向渐变或<code>CGContextDrawRadialGradient</code>函数绘制径向渐变，参数含义分别是：图形上下文、<code>CGGradient</code>对象、起始位置、终止位置、绘图选项。</li>
<li>绘制完毕后，释放颜色空间和<code>CGGradient</code>对象。</li>
</ol>
<p>绘制轴向渐变:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGFloat compoents[] = &#123;1,0,1,1, 0.3,0.5,1,1.0&#125;;</div><div class="line">CGFloat locations[] = &#123;0.0, 1.0&#125;;</div><div class="line">CGColorSpaceRef colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);</div><div class="line">CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, compoents, locations, 2);</div><div class="line">CGContextDrawLinearGradient(context, gradient, CGPointMake(0, 0), CGPointMake(0, 100), kCGGradientDrawsBeforeStartLocation);</div><div class="line">CGColorSpaceRelease(colorSpace);</div><div class="line">CGGradientRelease(gradient);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161221-0.png" alt="使用CGGradient绘制轴向渐变"></p>
<p>绘制径向渐变:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGFloat compoents[] = &#123;1,0,1,1, 0.3,0.5,1,1.0&#125;;</div><div class="line">CGFloat locations[] = &#123;0.0, 1.0&#125;;</div><div class="line">CGColorSpaceRef colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);</div><div class="line">CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, compoents, locations, 2);</div><div class="line">CGContextDrawRadialGradient(context, gradient, CGPointMake(200, 50), 20, CGPointMake(200, 400), 70, kCGGradientDrawsAfterEndLocation);</div><div class="line">CGColorSpaceRelease(colorSpace);</div><div class="line">CGGradientRelease(gradient);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161221-1.png" alt="使用CGGradient绘制径向渐变"></p>
<h3 id="CGShading"><a href="#CGShading" class="headerlink" title="CGShading"></a>CGShading</h3><p>绘制轴向渐变需要以下步骤：</p>
<ol>
<li>设置 CGFunction 对象来计算颜色值</li>
<li>创建轴向渐变的 CGShading 对象</li>
<li>裁减上下文</li>
<li>使用 CGShading 对象来绘制轴向渐变</li>
<li>释放对象</li>
</ol>
<p>绘制轴向渐变完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    [super drawRect:rect];</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    CGFunctionRef functionObj = getFunction(colorspace);</div><div class="line">    CGShadingRef shading = CGShadingCreateAxial(colorspace, CGPointMake(0, 0.5), CGPointMake(1, 0.5), functionObj, false, false);</div><div class="line">    CGAffineTransform myTransform = CGAffineTransformMakeScale(100, 100);</div><div class="line">    CGContextConcatCTM (context, myTransform);</div><div class="line">    CGContextSaveGState (context);</div><div class="line">    CGContextBeginPath(context);</div><div class="line">    CGContextAddArc(context,  .5, .5, .3, 0, M_PI, 0);</div><div class="line">    CGContextClosePath(context);</div><div class="line">    CGContextClip(context);</div><div class="line">    CGContextDrawShading(context, shading);</div><div class="line">    CGShadingRelease(shading);</div><div class="line">    CGColorSpaceRelease(colorspace);</div><div class="line">    CGFunctionRelease(functionObj);</div><div class="line">    CGContextRestoreGState (context);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static CGFunctionRef getFunction(CGColorSpaceRef colorspace) &#123;</div><div class="line">    size_t numComponents = 1 + CGColorSpaceGetNumberOfComponents(colorspace);</div><div class="line">    CGFloat input_value_range[] = &#123;0, 1&#125;;</div><div class="line">    CGFloat output_value_range[] = &#123;0, 1, 0, 0, 0,0,1,1&#125;;</div><div class="line">    CGFunctionCallbacks callbacks = &#123;0, &amp;calculateShadingValues, NULL&#125;;</div><div class="line">    return CGFunctionCreate((void *) numComponents, 1, input_value_range, numComponents, output_value_range, &amp;callbacks);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void calculateShadingValues(void *info, const CGFloat *in, CGFloat *out) &#123;</div><div class="line">    CGFloat v;</div><div class="line">    size_t k, compoents;</div><div class="line">    static const CGFloat c[] = &#123;1,0,0.5,1&#125;;</div><div class="line">    compoents = (size_t)info;</div><div class="line">    v = *in;</div><div class="line">    for (k = 0; k &lt; compoents - 1; k ++)</div><div class="line">        *out ++ = c[k] * v;</div><div class="line">    *out++ = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161221-2.png" alt="使用CGShading绘制轴向渐变"></p>
<p>绘制径向渐变，需要以下步骤：</p>
<ol>
<li>设置 CGFunction 对象来计算颜色值</li>
<li>创建径向渐变的 CGShading 对象</li>
<li>使用 CGShading 对象来绘制径向渐变</li>
<li>释放对象</li>
</ol>
<p>绘制径向渐变完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    [super drawRect:rect];</div><div class="line"></div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    </div><div class="line">    CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    CGFunctionRef functionObj = getFunction(colorspace);</div><div class="line">    CGShadingRef shading = CGShadingCreateRadial(colorspace, CGPointMake(0.25, 0.3), 0.1, CGPointMake(0.7, 0.7), 0.25, functionObj, false, false);</div><div class="line"></div><div class="line">    CGAffineTransform myTransform = CGAffineTransformMakeScale(100, 100);</div><div class="line">    CGContextConcatCTM (context, myTransform);</div><div class="line">    CGContextSaveGState (context);</div><div class="line">    </div><div class="line">    CGContextClipToRect (context, CGRectMake(0, 0, 1, 1));</div><div class="line">    CGContextSetRGBFillColor (context, 1, 1, 1, 1);</div><div class="line">    CGContextFillRect (context, CGRectMake(0, 0, 1, 1));</div><div class="line">    </div><div class="line">    CGContextDrawShading(context, shading);</div><div class="line">    </div><div class="line">    CGShadingRelease(shading);</div><div class="line">    CGColorSpaceRelease(colorspace);</div><div class="line">    CGFunctionRelease(functionObj);</div><div class="line">    CGContextRestoreGState (context);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static CGFunctionRef getFunction(CGColorSpaceRef colorspace) &#123;</div><div class="line">    size_t numComponents = 1 + CGColorSpaceGetNumberOfComponents(colorspace);</div><div class="line">    </div><div class="line">    CGFloat input_value_range[] = &#123;0, 1&#125;;</div><div class="line">    CGFloat output_value_range[] = &#123;0, 1, 0, 0, 0,0,1,1&#125;;</div><div class="line">    </div><div class="line">    CGFunctionCallbacks callbacks = &#123;0, &amp;calculateShadingValues, NULL&#125;;</div><div class="line">    return CGFunctionCreate((void *) numComponents, 1, input_value_range, numComponents, output_value_range, &amp;callbacks);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">static void calculateShadingValues(void *info, const CGFloat *in, CGFloat *out) &#123;</div><div class="line">    </div><div class="line">    size_t k, compoents;</div><div class="line">    double frequency[] = &#123;55, 220, 110, 0&#125;;</div><div class="line">    compoents = (size_t)info;</div><div class="line">    for (k = 0; k &lt; compoents - 1; k ++)</div><div class="line">        *out++ = (1 + sin(*in * frequency[k])) / 2;</div><div class="line">    *out++ = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161221-3.png" alt="使用CGShading绘制径向渐变"></p>
<hr>
<p>参考文章：<a href="http://southpeak.github.io/categories/translate/" target="_blank" rel="external">南峰子翻译的Quartz2D编程指南</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Pattern&quot;&gt;&lt;a href=&quot;#Pattern&quot; class=&quot;headerlink&quot; title=&quot;Pattern&quot;&gt;&lt;/a&gt;Pattern&lt;/h2&gt;&lt;p&gt;Pattern可翻译为样式、模型。类似于iOS中自定义的view，可以重复多次把自定义的view添加到控制器的view上。样式(Pattern)是绘制操作的一个序列，可以重复的绘制到一个图形上下文上。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Quartz2D" scheme="http://markmiao.com/tags/Quartz2D/"/>
    
  </entry>
  
  <entry>
    <title>Quartz 2D（二）颜色和颜色空间、变换</title>
    <link href="http://markmiao.com/2016/12/19/Quartz2D2/"/>
    <id>http://markmiao.com/2016/12/19/Quartz2D2/</id>
    <published>2016-12-19T02:51:34.000Z</published>
    <updated>2016-12-21T07:02:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="颜色和颜色空间"><a href="#颜色和颜色空间" class="headerlink" title="颜色和颜色空间"></a>颜色和颜色空间</h2><p>不同设备的颜色处理方式各不相同，每种设备都有各自的颜色值范围。就是使用指定函数解析一组数值组成的颜色信息，比如RGB颜色、CMYK颜色。</p>
<a id="more"></a>
<p>在不同颜色空间下，蓝色的色值</p>
<table>
<thead>
<tr>
<th style="text-align:left">颜色空间</th>
<th style="text-align:left">蓝色的色值</th>
<th style="text-align:left">色值对应的参数含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">HSB</td>
<td style="text-align:left">240度，100%，100%</td>
<td style="text-align:left">色相，饱和度，亮度</td>
</tr>
<tr>
<td style="text-align:left">RGB</td>
<td style="text-align:left">0，0，1</td>
<td style="text-align:left">红，绿，蓝</td>
</tr>
<tr>
<td style="text-align:left">CMYK</td>
<td style="text-align:left">1，1，0，0</td>
<td style="text-align:left">蓝绿、品红、黄、黑</td>
</tr>
<tr>
<td style="text-align:left">BGR</td>
<td style="text-align:left">1，0，0</td>
<td style="text-align:left">蓝，绿，红</td>
</tr>
</tbody>
</table>
<h2 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h2><p>使用函数<code>CGContextSetAlpha</code>设置全局透明度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextSetAlpha(context, 0.5);</div></pre></td></tr></table></figure>
<p>使用函数<code>CGContextClearRect</code>清除图形上下文的alpha通道。在创建透明遮罩或者窗口完全透明的时候使用。</p>
<h2 id="创建颜色空间"><a href="#创建颜色空间" class="headerlink" title="创建颜色空间"></a>创建颜色空间</h2><h3 id="设备依赖颜色空间"><a href="#设备依赖颜色空间" class="headerlink" title="设备依赖颜色空间"></a>设备依赖颜色空间</h3><p><strong>iOS不支持设备依赖颜色空间。</strong></p>
<ol>
<li>lba非线性转换，使用<code>CGColorSpaceCreateLab</code>创建</li>
<li>ICC颜色空间，国际色彩联盟定义的，使用<code>CGColorSpaceCreateICCBased</code>创建</li>
<li>标准化RGB颜色空间，使用<code>CGColorSpaceCreateCalibratedRGB</code>创建</li>
<li>标准化灰度颜色空间，使用<code>CGColorSpaceCreateCalibratedGray</code>创建</li>
</ol>
<h3 id="通用颜色空间"><a href="#通用颜色空间" class="headerlink" title="通用颜色空间"></a>通用颜色空间</h3><p><strong>iOS不支持通用颜色空间。</strong></p>
<p>但是macOS应用程序通常情况下使用通用颜色空间，而不使用设备颜色空间。</p>
<p>使用函数<code>CGColorSpaceCreateWithName</code>创建通用颜色空间，传入固定常量：</p>
<ol>
<li><code>kCGColorSpaceGenericGray</code>，指定通用灰色</li>
<li><code>kCGColorSpaceGenericRGB</code>，指定通用RGB</li>
<li><code>kCGColorSpaceGenericCMYK</code>，指定通用CMYK</li>
</ol>
<h3 id="设备颜色空间"><a href="#设备颜色空间" class="headerlink" title="设备颜色空间"></a>设备颜色空间</h3><p>设备颜色空间主要用于IOS应用程序。通过以下函数创建设备颜色空间：</p>
<p><code>CGColorSpaceCreateDeviceGray</code> 创建设备依赖灰度颜色空间。</p>
<p>快速设置依赖灰度颜色空间的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CGContextSetGrayStrokeColor(context, 0.5, 1);</div><div class="line">CGContextSetGrayFillColor(context, 0.5, 1);</div></pre></td></tr></table></figure>
<p>还可以使用该函数获取灰度图片，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)getGrayImage:(UIImage*)sourceImage &#123;</div><div class="line">    CGFloat width = sourceImage.size.width;</div><div class="line">    CGFloat height = sourceImage.size.height;</div><div class="line">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();</div><div class="line">    CGContextRef context = CGBitmapContextCreate(nil,width,height,8,0,colorSpace,kCGImageAlphaNone);</div><div class="line">    CGColorSpaceRelease(colorSpace);</div><div class="line">    if (context == NULL) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    CGContextDrawImage(context,CGRectMake(0, 0, width, height), sourceImage.CGImage);</div><div class="line">    UIImage *grayImage = [UIImage imageWithCGImage:CGBitmapContextCreateImage(context)];</div><div class="line">    CGContextRelease(context);</div><div class="line">    return grayImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161215-0.png" alt="正常图片和灰度处理的图片"></p>
<p><code>CGColorSpaceCreateDeviceRGB</code> 创建设备依赖RGB颜色空间，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGFloat colors[4] = &#123;0.3, 1.0, 0.9, 1.0&#125;;</div><div class="line">CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</div><div class="line">CGColorRef color = CGColorCreate(colorSpace, colors);</div><div class="line">CGContextSetFillColorWithColor(context, color);</div><div class="line">CGContextFillRect(context, CGRectMake(100, 50, 100, 50));</div><div class="line">CGColorSpaceRelease(colorSpace);</div><div class="line">CGColorRelease(color);</div></pre></td></tr></table></figure>
<p>以及快速设置设备依赖RGB颜色空间的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CGContextSetRGBStrokeColor(context, 0.3, 1.0, 0.9, 1.0);</div><div class="line">CGContextSetRGBFillColor(context, 0.3, 1.0, 0.9, 1.0);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161215-1.png" alt="设备依赖RGB颜色空间"></p>
<p><code>CGColorSpaceCreateDeviceCMYK</code> 创建设备依赖CMYK颜色空间，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGFloat colors[] = &#123;80, 100, 0, 0, 1.0&#125;;</div><div class="line">CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceCMYK();</div><div class="line">CGColorRef color = CGColorCreate(colorSpace, colors);</div><div class="line">CGContextSetFillColorWithColor(context, color);</div><div class="line">CGContextFillRect(context, CGRectMake(100, 50, 100, 50));</div><div class="line">CGColorSpaceRelease(colorSpace);</div><div class="line">CGColorRelease(color);</div></pre></td></tr></table></figure>
<p>以及快速设置设备依赖CMYK颜色空间的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CGContextSetCMYKStrokeColor(context, 80, 100, 0, 0, 1.0);</div><div class="line">CGContextSetCMYKFillColor(context, 80, 100, 0, 0, 1.0);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161215-2.png" alt="设备依赖CMYK颜色空间"></p>
<h2 id="设置和创建颜色"><a href="#设置和创建颜色" class="headerlink" title="设置和创建颜色"></a>设置和创建颜色</h2><p>通过函数<code>CGContextSetStrokeColorWithColor</code>和<code>CGContextSetFillColorWithColor</code>分别填充路径颜色和设置线框颜色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextSetLineWidth(context, 20);</div><div class="line">CGContextAddRect(context, CGRectMake(100, 50, 100, 50));</div><div class="line">CGContextSetStrokeColorWithColor(context, [UIColor blueColor].CGColor);</div><div class="line">CGContextStrokePath(context);</div><div class="line">CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor);    </div><div class="line">CGContextFillRect(context, CGRectMake(100, 50, 100, 50));</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161215-3.png" alt="填充路径设置线框"></p>
<h2 id="设置再现意图"><a href="#设置再现意图" class="headerlink" title="设置再现意图"></a>设置再现意图</h2><p>“再现意图”用于指定如何将源颜色空间的颜色映射到图形上下文的目标颜色空间的颜色范围内。调用函数<code>CGContextSetRenderingIntent</code>设置再现意图，传入枚举类型<code>CGColorRenderingIntent</code></p>
<ol>
<li>kCGRenderingIntentDefault：使用默认的渲染意图。</li>
<li>kCGRenderingIntentAbsoluteColorimetric：绝对色度渲染意图。将输出设备颜色域外的颜色映射为输出设备域内与之最接近的颜色。这可以产生一个裁减效果，因为色域外的两个不同的颜色值可能被映射为色域内的同一个颜色值。当图形使用的颜色值同时包含在源色域及目标色域内时，这种方法是最好的。常用于logo或者使用专色(spot color)时。</li>
<li>kCGRenderingIntentRelativeColorimetric：相对色度渲染意图。转换所有的颜色(包括色域内的)，以补偿图形上下文的白点与输出设备白点之间的色差。kCGRenderingIntentPerceptual：感知渲染意图。通过压缩图形上下文的色域来适应输出设备的色域，并保持源颜色空间的颜色之间的相对性。感知渲染意图适用于相片及其它复杂的高细度图片。</li>
<li>kCGRenderingIntentSaturation：饱和度渲染意图。把颜色转换到输出设备色域内时，保持颜色的相对饱和度。结果是包含亮度、饱和度颜色的图片。饱和度意图适用于生成低细度的图片，如描述性图表。</li>
</ol>
<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><p>变换是使用Quartz内置的变换函数对绘图进行平移、旋转和缩放变换。</p>
<h2 id="修改CTM"><a href="#修改CTM" class="headerlink" title="修改CTM"></a>修改CTM</h2><p>CTM是Current Transformation Matrix，当前变换矩阵。可以操作CTM来平移、旋转、缩放page，绘制对象在page上，自然也会变换。</p>
<p>通过<code>CGContextDrawImage</code>函数绘制图片到page上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextDrawImage(context, CGRectMake(20, 40, 100, 150), [UIImage imageNamed:@&quot;img&quot;].CGImage);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161215-4.png" alt="将图片绘制到page上"></p>
<p>可以看到，图片是上下颠倒的。是因为iOS的UIKit坐标是以左上角为原点，y轴向下，Quartz 2D的图形绘制引擎坐标是左下角为原点，y轴向上。因为坐标轴上下相反，所以图片上下颠倒。macOS的坐标布局和Quartz 2D一样，以左下角为坐标原点，y轴向上。</p>
<p>注意要先进行CTM变换操作，再<code>CGContextDrawImage</code>画图。</p>
<h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><p>调用函数<code>CGContextTranslateCTM</code>指定沿x轴和y轴的平移位置。沿x轴平移100，沿y轴平移50：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextTranslateCTM(context, 100, 50);</div></pre></td></tr></table></figure>
<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>调用函数<code>CGContextRotateCTM</code>指定旋转角度，是以坐标原点为中心，旋转指定角度。这个坐标原点是指iOS的UIKit的左上角坐标原点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextRotateCTM(context, M_PI_4);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161215-5.png" alt="旋转前与旋转后的图片比较"></p>
<p>函数传入的是弧度值，可以定义以下方法，传入角度值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static inline double radians (double degrees) &#123;return degrees * M_PI/180;&#125;</div></pre></td></tr></table></figure>
<p>等价于上面的旋转函数调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextRotateCTM(context, radians(45.));</div></pre></td></tr></table></figure>
<h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>调用函数<code>CGContextScaleCTM</code>实现缩放操作，也是以坐标原点为中心，x，y，w，h皆缩放为指定比例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextScaleCTM(context, 0.5, 0.5);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161215-6.png" alt="缩放前后的图片比较"></p>
<h3 id="累计变换操作"><a href="#累计变换操作" class="headerlink" title="累计变换操作"></a>累计变换操作</h3><p>上文说道，使用<code>CGContextDrawImage</code>函数画的图片上下颠倒，可以使用累计变换操作将图片扶正。累计变换操作的执行顺序不同，会导致不同结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CGRect imgRect = CGRectMake(100, 40, 100, 130);</div><div class="line">CGContextTranslateCTM(context, imgRect.size.width + imgRect.origin.x * 2, imgRect.size.height + imgRect.origin.y * 2);</div><div class="line">CGContextRotateCTM(context, M_PI);</div><div class="line">CGContextDrawImage(context, imgRect, [UIImage imageNamed:@&quot;img&quot;].CGImage);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161216-0.png" alt="图片扶正结果"></p>
<h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>仿射变换可以实现与CTM函数相同的变换操作，使用仿射变换函数构造矩阵，调用函数<code>CGContextConcatCTM</code>应用于CTM，达到变换效果。</p>
<p>仿射变换函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CGAffineTransformMakeTranslation</td>
<td style="text-align:left">构造平移矩阵，指定移动x,y值</td>
</tr>
<tr>
<td style="text-align:left">CGAffineTransformTranslate</td>
<td style="text-align:left">在现有的变换操作基础上使用平移操作</td>
</tr>
<tr>
<td style="text-align:left">CGAffineTransformMakeRotation</td>
<td style="text-align:left">构造旋转矩阵，指定旋转弧度</td>
</tr>
<tr>
<td style="text-align:left">CGAffineTransformRotate</td>
<td style="text-align:left">在现有的变换操作基础上使用旋转操作</td>
</tr>
<tr>
<td style="text-align:left">CGAffineTransformMakeScale</td>
<td style="text-align:left">构造缩放矩阵，指定x,y拉伸或收缩坐标</td>
</tr>
<tr>
<td style="text-align:left">CGAffineTransformScale</td>
<td style="text-align:left">在现有的变换操作基础上使用旋转操作</td>
</tr>
</tbody>
</table>
<p>构造变换矩阵的函数应用，执行结果和上文中图片一样，等价于上文中CTM函数变换操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//平移</div><div class="line">CGAffineTransform translation = CGAffineTransformMakeTranslation(100, 50);</div><div class="line">CGContextConcatCTM(context, translation);</div><div class="line">//旋转</div><div class="line">CGAffineTransform rotation = CGAffineTransformMakeRotation(M_PI_4);</div><div class="line">CGContextConcatCTM(context, rotation);</div><div class="line">//缩放</div><div class="line">CGAffineTransform scale = CGAffineTransformMakeScale(0.5, 0.5);</div><div class="line">CGContextConcatCTM(context, scale);</div></pre></td></tr></table></figure>
<p>在当前变换的基础上叠加变换操作，和上文中的累计变换操作等价：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CGAffineTransform translate = CGAffineTransformTranslate(CGContextGetCTM(context), 100, 50);</div><div class="line">CGAffineTransform rotate = CGAffineTransformRotate(translate, M_PI_4);</div><div class="line">CGAffineTransform scale = CGAffineTransformScale(rotate, 0.5, 0.5);</div><div class="line">CGContextConcatCTM(context, scale);</div></pre></td></tr></table></figure>
<hr>
<p>参考文章：<a href="http://southpeak.github.io/categories/translate/" target="_blank" rel="external">南峰子翻译的Quartz2D编程指南</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;颜色和颜色空间&quot;&gt;&lt;a href=&quot;#颜色和颜色空间&quot; class=&quot;headerlink&quot; title=&quot;颜色和颜色空间&quot;&gt;&lt;/a&gt;颜色和颜色空间&lt;/h2&gt;&lt;p&gt;不同设备的颜色处理方式各不相同，每种设备都有各自的颜色值范围。就是使用指定函数解析一组数值组成的颜色信息，比如RGB颜色、CMYK颜色。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Quartz2D" scheme="http://markmiao.com/tags/Quartz2D/"/>
    
  </entry>
  
  <entry>
    <title>Quartz 2D（一）概念、图形上下文、路径</title>
    <link href="http://markmiao.com/2016/12/13/Quartz2D1/"/>
    <id>http://markmiao.com/2016/12/13/Quartz2D1/</id>
    <published>2016-12-13T08:59:51.000Z</published>
    <updated>2016-12-13T09:47:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>Quartz 2D是二维图形绘制引擎，可以实现N多图形图像的操作功能，如基本路径的绘制、透明度、描影、绘制阴影、透明层、颜色管理、反锯齿、PDF文档生成和PDF元数据访问。</p>
<a id="more"></a>
<h2 id="画布Page"><a href="#画布Page" class="headerlink" title="画布Page"></a>画布Page</h2><p>在图像操作过程中使用了<code>绘画者模型</code>，绘制过程是将绘制层铺到画布上，这个画布称为<code>Page</code>。类似于Photoshop中，将每个图层叠加放在画布上，形成最后的图像。</p>
<h2 id="图形上下文Graphics-Context"><a href="#图形上下文Graphics-Context" class="headerlink" title="图形上下文Graphics Context"></a>图形上下文Graphics Context</h2><p><code>图形上下文(Graphics Context)</code>是一个数据类型<code>CGContextRef</code>，它存放了Quartz 2D绘制的图形输出信息，可以看做是图形到设备输出的介质工具。Quartz 2D绘制的图形可以放到多种设备上，比如：PDF文件、显示器窗口、bitmap(位图)、view的Layer层等等，这就需要不同的<code>Graphics Context</code>来完成输出到不同设备上的工作。这好比人要上高速需要汽车，去海上需要船，去天空需要飞机，这里人相当于图形，高速路、海、天空相当于设备，而汽车、船、飞机就是<code>Graphics Context</code>。</p>
<p><code>Graphics Context</code>的几种类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. Bitmap Graphics Context</div><div class="line">2. PDF Graphics Context</div><div class="line">3. Window Graphics Context</div><div class="line">4. Layer Context</div><div class="line">5. Post Graphics Context</div></pre></td></tr></table></figure>
<h2 id="Quartz-2D的数据类型"><a href="#Quartz-2D的数据类型" class="headerlink" title="Quartz 2D的数据类型"></a>Quartz 2D的数据类型</h2><p>Quartz 2D API属于Code Graphics框架，所以Quartz 2D的数据类型是以CG开头的。有以下数据类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1. CGPathRef：用于向量图，可创建路径，并进行填充或描画(stroke)</div><div class="line">2. CGImageRef：用于表示bitmap图像和基于采样数据的bitmap图像遮罩。</div><div class="line">3. CGLayerRef：用于表示可用于重复绘制(如背景)和幕后(offscreen)绘制的绘画层</div><div class="line">4. CGPatternRef：用于重绘图</div><div class="line">5. CGShadingRef、CGGradientRef：用于绘制渐变</div><div class="line">6. CGFunctionRef：用于定义回调函数，该函数包含一个随机的浮点值参数。当为阴影创建渐变时使用该类型</div><div class="line">7. CGColorRef, CGColorSpaceRef：用于告诉Quartz如何解释颜色</div><div class="line">8. CGImageSourceRef,CGImageDestinationRef：用于在Quartz中移入移出数据</div><div class="line">9. CGFontRef：用于绘制文本</div><div class="line">10. CGPDFDictionaryRef, CGPDFObjectRef, CGPDFPageRef, CGPDFStream, CGPDFStringRef, and CGPDFArrayRef：用于访问PDF的元数据</div><div class="line">11. CGPDFScannerRef, CGPDFContentStreamRef：用于解析PDF元数据</div><div class="line">12. CGPSConverterRef：用于将PostScript转化成PDF。在iOS中不能使用。</div></pre></td></tr></table></figure>
<h2 id="图形状态"><a href="#图形状态" class="headerlink" title="图形状态"></a>图形状态</h2><p>Quartz通过修改图形状态来修改绘制结果，图形状态直接决定了图形的最终渲染结果。图形状态包含用于绘制程序的参数，绘制参数改变了，图形自然就变了。比如修改了填充色值，图形颜色就变了。</p>
<h2 id="iOS中使用Graphics-Context绘制图形"><a href="#iOS中使用Graphics-Context绘制图形" class="headerlink" title="iOS中使用Graphics Context绘制图形"></a>iOS中使用Graphics Context绘制图形</h2><p>在iOS中要想用Quartz 2D在屏幕上绘图，需要自定义一个UIView，在UIView的<code>- (void)drawRect:(CGRect)rect</code>方法中实现绘图操作，这个方法会在UIView显示在屏幕上和需要被刷新的时候调用。创建上下文的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上下文中绘制图形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    //获取图形上下文</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    //设置红色透明度0.5的填充色</div><div class="line">    CGContextSetRGBFillColor(context, 1, 0, 0, 0.5);</div><div class="line">    //填充一个矩形frame为(10, 20, 100, 40)</div><div class="line">    CGContextFillRect(context, CGRectMake(10, 20, 100, 40));</div><div class="line">    //设置蓝色透明度0.5的填充色</div><div class="line">    CGContextSetRGBFillColor(context, 0, 0, 1, 0.5);</div><div class="line">    //填充一个矩形frame为(10, 20, 40,  100)</div><div class="line">    CGContextFillRect(context, CGRectMake(10, 20, 40, 100));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161209-0.png?raw=true" alt="显示结果"></p>
<p>注意：设置填充色和填充矩形的方法顺序不能颠倒，不然填充色填充不到想填充的矩形中。得不到填充色填充的会是黑色。</p>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>路径可以构建出多种图形，可以是点、直线、弧线、不规则线、规则或不规则形状，可以对闭合路径进行填充行程面。使用路径绘制出想要的图形，有两步：创建路径和绘制路径。创建出点、线等路径，使用函数<code>CGContextDrawPath</code>绘制路径。</p>
<h3 id="点"><a href="#点" class="headerlink" title="点"></a>点</h3><p>点是依靠x、y值固定的位置，可作为路径的起始点位置。比如要画一个线段，必须要有一个起点和一个终点，两点确定一条线段。使用函数<code>CGContextMoveToPoint</code>来确定起始点，传入图形上下文和x,y坐标点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//确定一个坐标为(10,10)的点</div><div class="line">CGContextMoveToPoint(context, 10, 10);</div></pre></td></tr></table></figure>
<h3 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h3><p>有起始点，再指定一个终点位置就能确定一条直线了，使用函数<code>CGContextAddLineToPoint</code>来指定终点位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">	  //获取图形上下文</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    //设置起点</div><div class="line">    CGContextMoveToPoint(context, 20, 20);</div><div class="line">    //起点延长至终点位置</div><div class="line">    CGContextAddLineToPoint(context, 50, 50);</div><div class="line">    //绘制路径</div><div class="line">    CGContextDrawPath(context, kCGPathStroke);    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以使用<code>CGContextAddLineToPoint</code>函数指定多个位置点，线段会一个接一个画下去，形成折线图形。也可以使用<code>CGContextAddLines</code>函数一次性指定多个位置点，完成折线图形，此时无需指定起始点，第一个点默认为起始点(即使用<code>CGContextMoveToPoint</code>指定起始点也无效)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//一个一个点继续加</div><div class="line">CGContextMoveToPoint(context, 20, 20);    </div><div class="line">CGContextAddLineToPoint(context, 50, 50);</div><div class="line">CGContextAddLineToPoint(context, 30, 80);</div><div class="line"></div><div class="line">//一次性指定多个点</div><div class="line">CGPoint pos[3] = &#123;CGPointMake(80, 20), CGPointMake(20, 50), CGPointMake(100, 200)&#125;;</div><div class="line">CGContextAddLines(context, pos, 3);</div></pre></td></tr></table></figure>
<p>由于<code>CGContextAddLineToPoint</code>函数必须得有<code>CGContextMoveToPoint</code>函数固定起始点，<code>CGContextAddLines</code>函数默认第一个点为起始点，所以<code>CGContextAddLines</code>后面可以跟着<code>CGContextAddLineToPoint</code>继续加点画线，能连成一组折线，而<code>CGContextMoveToPoint</code>+<code>CGContextAddLineToPoint</code>画线后面不能跟<code>CGContextAddLines</code>，会画成两组无关联的折线。</p>
<h3 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h3><p>画圆弧提供了两个函数，一个是<code>CGContextAddArc</code>，依次指定<code>图形上下文</code>、<code>圆心坐标</code>、<code>半径</code>、<code>起始弧度</code>、<code>终止弧度</code>、<code>画线顺时针(1)或逆时针(0)</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextAddArc(context, 100, 200, 30, 0, M_PI, 0);</div><div class="line">CGContextDrawPath(context, kCGPathStroke);</div></pre></td></tr></table></figure>
<p>第二个函数是<code>CGContextAddArcToPoint</code>，三点+半径确定一个圆弧。<code>CGContextMoveToPoint</code>函数确定第一个点，<code>CGContextAddArcToPoint</code>添加第二个点、第三个点和还有半径。原理：以第二点为中心，分别向第一点、第三点延长两条射线，射线夹角小于180°的一侧，以指定半径画圆弧，圆弧与射线相切。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextMoveToPoint(context, 100, 100);</div><div class="line">CGContextAddArcToPoint(context, 100, 150, 150, 150, 50);</div><div class="line">CGContextDrawPath(context, kCGPathStroke);</div></pre></td></tr></table></figure>
<h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><p>画Bezier曲线也提供了两个函数，函数<code>CGContextAddCurveToPoint</code>用于画三次Bezier曲线，由一个起点、一个终点和两个控制点构成一条三次Bezier曲线。当两个控制点在起点和终点连线的同侧时，曲线会只有一个拱向，在不同侧时有两个拱向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextMoveToPoint(context, 100, 100);</div><div class="line">CGContextAddCurveToPoint(context, 150, 50, 200, 200, 300, 100);</div><div class="line">CGContextDrawPath(context, kCGPathStroke);</div></pre></td></tr></table></figure>
<p>画二次Bezier曲线，使用函数CGContextAddQuadCurveToPoint。以当前点为起始点，指定一个控制点一个终点，确定一条二次Bezier曲线。控制点决定了曲线拱的方向，该函数只能创建一个拱向的Bezier曲线，而且曲线不可能交叉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextMoveToPoint(context, 100, 100);</div><div class="line">CGContextAddQuadCurveToPoint(context, 200, 200, 300, 100);</div><div class="line">CGContextDrawPath(context, kCGPathStroke);</div></pre></td></tr></table></figure>
<h3 id="闭合路径"><a href="#闭合路径" class="headerlink" title="闭合路径"></a>闭合路径</h3><p>Quartz 2D提供函数<code>CGContextClosePath</code>来闭合路径。就是将终点和起点用直线连接起来，使整个路径闭合。对于直线、弧、曲线等不能自动闭合的路径，如果想完成路径闭合必须调用该函数。</p>
<p>调用了<code>CGContextClosePath</code>完成闭合路径后，再调用<code>Add...</code>添加路径的函数，添加直线、弧线、曲线等路径，会从闭合路径的起始点开始。如果没有完成闭合路径函数的调用，则从终点继续开始新添加的路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextMoveToPoint(context, 100, 100);</div><div class="line">CGContextAddCurveToPoint(context, 150, 50, 150, 200, 300, 100);</div><div class="line">CGContextClosePath(context);</div><div class="line">CGContextAddLineToPoint(context, 200, 500);</div><div class="line">CGContextDrawPath(context, kCGPathStroke);</div></pre></td></tr></table></figure>
<h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><p>使用函数<code>CGContextAddRect</code>来画矩形，函数中的<code>rect</code>中x,y是矩形左上角，宽高是矩形的宽高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextAddRect(context, CGRectMake(20, 20, 100, 40));</div><div class="line">CGContextDrawPath(context, kCGPathStroke);</div></pre></td></tr></table></figure>
<h3 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h3><p>使用函数<code>CGContextAddEllipseInRect</code>来画椭圆，是以矩形来确定椭圆。坐标参数意义和矩形一样，以确定的矩形内切画出的椭圆。矩形的圆心即是椭圆的圆心，矩形的宽高即是椭圆的长轴短轴，当矩形的宽高相等时，椭圆就是一个圆了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextAddEllipseInRect(context, CGRectMake(0, 0, 30, 50));</div><div class="line">CGContextDrawPath(context, kCGPathStroke);</div></pre></td></tr></table></figure>
<h2 id="创建路径"><a href="#创建路径" class="headerlink" title="创建路径"></a>创建路径</h2><ul>
<li>在开始绘制路径前，调用 CGContextBeginPath 或 UI。</li>
<li>直线、弧、曲线开始于当前点。空路径没有当前点；我们必须调用CGContextMoveToPoint来设置第一个子路径的起始点，或者调用一个便利函数来隐式地完成该任务。</li>
<li>如果要闭合当前子路径，调用函数 CGContextClosePath。随后路径将开始一个新的子路径，即使我们不显示设置一个新的起始点。</li>
<li>当绘制弧时，Quartz 将在当前点与弧的起始点间绘制一条直线。</li>
<li>添加椭圆和矩形的 Quartz 程序将在路径中添加新的闭合子路径。</li>
<li>我们必须调用绘制函数来填充或者描边一条路径，因为创建路径时并不会绘制路径。</li>
<li>Quartz 提供了两个数据类型来创建可复用路径 CGPathRef 和 CGMutablePathRef。</li>
<li>Quartz 提供了一个类似于操作图形上下文的 CGPath 的函数集合。这些路径函数操作 CGPath 对象，而不是图形上下文。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1.	CGPathCreateMutable 取代 CGContextBeginPath</div><div class="line">2.	CGPathMoveToPoint 取代 CGContextMoveToPoint</div><div class="line">3.	CGPathAddLineToPoint 取代 CGContexAddLineToPoint</div><div class="line">4.	CGPathAddCurveToPoint 取代 CGContexAddCurveToPoint</div><div class="line">5.	CGPathAddEllipseInRect 取代 CGContexAddEllipseInRect</div><div class="line">6.	CGPathAddArc 取代 CGContexAddArc</div><div class="line">7.	CGPathAddRect 取代 CGContexAddRect</div><div class="line">8.	CGPathCloseSubpath 取代 CGContexClosePath</div></pre></td></tr></table></figure>
<p>如果想要添加一个路径到图形上下文，可以调用CGContextAddPath。路径将保留在图形上下文中，直到Quartz绘制它。我们可以调用CGContextAddPath再次添加路径。</p>
<h2 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h2><p>通过图形上下文加上一系列创建路径的函数得到最终的路径，还需要绘制路径操作，才能使得路径呈现。如上文中一直用到的绘制路径的函数操作<code>CGContextDrawPath(context, kCGPathStroke);</code>。</p>
<p>绘制路径分为描边和填充，描边是绘制路径的边框，填充是绘制路径所包含的区域。</p>
<h3 id="影响描边的属性"><a href="#影响描边的属性" class="headerlink" title="影响描边的属性"></a>影响描边的属性</h3><table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">解释</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CGContextSetLineWidth</td>
<td style="text-align:left">描边路径的宽度</td>
<td style="text-align:left">单位是用户空间单位</td>
</tr>
<tr>
<td style="text-align:left">CGContextSetLineJoin</td>
<td style="text-align:left">指定描边的连接点样式</td>
<td style="text-align:left">枚举类型:Miter(尖角),Round(圆角),Bevel(平角)</td>
</tr>
<tr>
<td style="text-align:left">CGContextSetLineCap</td>
<td style="text-align:left">指定直线端点样式</td>
<td style="text-align:left">枚举类:Butt,Round,Square</td>
</tr>
<tr>
<td style="text-align:left">CGContextSetMiterLimit</td>
<td style="text-align:left">转角的量级</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">CGContextSetLineDash</td>
<td style="text-align:left">虚线模式</td>
<td style="text-align:left">指定虚线数组和虚线相位控制虚线大小和位置</td>
</tr>
<tr>
<td style="text-align:left">CGContextSetStrokeColorSpace</td>
<td style="text-align:left">描边颜色空间</td>
<td style="text-align:left">封装了颜色和颜色空间的CGColorRef</td>
</tr>
<tr>
<td style="text-align:left">CGContextSetStrokeColor</td>
<td style="text-align:left">设置描边颜色</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">CGContextSetStrokePattern</td>
<td style="text-align:left">笔触模式</td>
</tr>
</tbody>
</table>
<h3 id="填充路径"><a href="#填充路径" class="headerlink" title="填充路径"></a>填充路径</h3><p>填充规则有两种：非零缠绕数规则（nonzero winding number rule）、偶数-奇数规则（even-odd rule）。</p>
<p>默认的填充规则为非零缠绕数规则。方法或枚举带有“EO”的为偶数-奇数规则。</p>
<p>非零缠绕数的填充规则与绘制的方向有关、偶数-奇数规则则与方向无关。如图。</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/eosampleone.gif" alt="非零缠绕数规则和偶数奇数规则"></p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CGContextEOFillPath</td>
<td style="text-align:left">使用偶数奇数规则填充当前路径</td>
</tr>
<tr>
<td style="text-align:left">CGContextFillPath</td>
<td style="text-align:left">使用非零缠绕数规则填充当前路径</td>
</tr>
<tr>
<td style="text-align:left">CGContextFillRect</td>
<td style="text-align:left">快速填充一个矩形</td>
</tr>
<tr>
<td style="text-align:left">CGContextFillRects</td>
<td style="text-align:left">快速填充N个矩形</td>
</tr>
<tr>
<td style="text-align:left">CGContextFillEllipseInRect</td>
<td style="text-align:left">快速填充一个椭圆形</td>
</tr>
<tr>
<td style="text-align:left">CGContextDrawPath</td>
<td style="text-align:left">填充或描边路径</td>
</tr>
</tbody>
</table>
<p>CGContextDrawPath函数的使用：</p>
<ul>
<li>CGContextDrawPath(context, kCGPathFill) 填充路径。</li>
<li>CGContextDrawPath(context, kCGPathEOFill) 使用奇偶规则填充路径。</li>
<li>CGContextDrawPath(context, kCGPathStroke) 描边路径。</li>
<li>CGContextDrawPath(context, kCGPathFillStroke) 填充并描边路径。</li>
<li>CGContextDrawPath(context, kCGPathEOFillStroke) 使用奇偶规则填充并描边路径。</li>
</ul>
<h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><p>混合模式是Quartz将绘图绘制到背景上的方式，其实就是前景图和背景图怎么混合叠加。叠加公式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = (alpha * foreground) + (1 - alpha) *background</div></pre></td></tr></table></figure>
<p>Quartz默认使用普通混合模式，也就是<code>kCGBlendModeNormal</code>。下面举例几个混合模式的样式，案例样式的代码见下一节<code>裁剪路径</code>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">kCGBlendModeNormal</th>
<th style="text-align:center">kCGBlendModeMultiply</th>
<th style="text-align:center">kCGBlendModeScreen</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161213-0.png" alt="普通模式"></td>
<td style="text-align:center"><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161213-1.png" alt="正片叠底"></td>
<td style="text-align:center"><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161213-2.png" alt="屏幕混合"></td>
</tr>
</tbody>
</table>
<p>16种混合模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">kCGBlendModeNormal,		//普通</div><div class="line">kCGBlendModeMultiply,		//正片叠底</div><div class="line">kCGBlendModeScreen,		//屏幕</div><div class="line">kCGBlendModeOverlay,		//叠加</div><div class="line">kCGBlendModeDarken,		//暗化</div><div class="line">kCGBlendModeLighten,		//亮化</div><div class="line">kCGBlendModeColorDodge,		//色彩减淡</div><div class="line">kCGBlendModeColorBurn,		//色彩加深</div><div class="line">kCGBlendModeSoftLight,		//柔光</div><div class="line">kCGBlendModeHardLight,		//强光</div><div class="line">kCGBlendModeDifference,		//差值</div><div class="line">kCGBlendModeExclusion,		//排除</div><div class="line">kCGBlendModeHue,			//色相</div><div class="line">kCGBlendModeSaturation,		//饱和度</div><div class="line">kCGBlendModeColor,		//颜色</div><div class="line">kCGBlendModeLuminosity,		//亮度</div></pre></td></tr></table></figure>
<h2 id="裁剪路径"><a href="#裁剪路径" class="headerlink" title="裁剪路径"></a>裁剪路径</h2><p>裁剪是一个遮罩，会遮住不允许绘制的地方。裁剪区域是一个闭合路径，Quartz只会渲染裁剪区域里面的东西，外面的东西不渲染。通过函数<code>CGContextClip</code>裁剪，具体的裁剪代码和执行结果如下，注意代码位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">/** 裁剪 */</div><div class="line">CGContextBeginPath(context);</div><div class="line">CGContextAddArc(context, 200, 200, 150, 0, 2 * M_PI, 0);</div><div class="line">CGContextClosePath(context);</div><div class="line">CGContextClip(context);</div><div class="line"></div><div class="line">CGContextSetRGBFillColor(context, 0.5, 0.2, 1, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(100, 50, 50, 300));</div><div class="line">CGContextSetRGBFillColor(context, 0.8, 0.3, 0.1, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(150, 50, 50, 300));</div><div class="line">CGContextSetRGBFillColor(context, 0.5, 0.1, 0.4, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(200, 50, 50, 300));</div><div class="line">CGContextSetRGBFillColor(context, 0, 0.5, 0.1, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(250, 50, 50, 300));</div><div class="line">    </div><div class="line">//设置混合模式，自行替换上述16中混合模式查看效果</div><div class="line">CGContextSetBlendMode(context, kCGBlendModeMultiply); </div><div class="line"></div><div class="line">CGContextSetRGBFillColor(context, 0.5, 0.2, 1, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(20, 100, 350, 50));</div><div class="line">CGContextSetRGBFillColor(context, 0.8, 0.3, 0.1, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(20, 150, 350, 50));</div><div class="line">CGContextSetRGBFillColor(context, 0.5, 0.1, 0.4, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(20, 200, 350, 50));</div><div class="line">CGContextSetRGBFillColor(context, 0, 0.5, 0.1, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(20, 250, 350, 50));</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161213-3.png" alt="裁剪路径和混合模式的执行结果"></p>
<hr>
<p>参考文章：<a href="http://southpeak.github.io/categories/translate/" target="_blank" rel="external">南峰子翻译的Quartz2D编程指南</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Quartz 2D是二维图形绘制引擎，可以实现N多图形图像的操作功能，如基本路径的绘制、透明度、描影、绘制阴影、透明层、颜色管理、反锯齿、PDF文档生成和PDF元数据访问。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Quartz2D" scheme="http://markmiao.com/tags/Quartz2D/"/>
    
  </entry>
  
  <entry>
    <title>iOS时间问题</title>
    <link href="http://markmiao.com/2016/12/08/iOS%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    <id>http://markmiao.com/2016/12/08/iOS时间问题/</id>
    <published>2016-12-08T02:38:39.000Z</published>
    <updated>2016-12-08T03:37:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发中，经常会遇到各种各样的时间问题，8小时时差，时间戳，求时间间隔，农历等等。解决办法网上比比皆是，但大多零零散散，很多资料并没有说明其中问题。这里集中总结一下，以便于以后查阅和供大家参考。有我自己的理解，错漏之处请大家吐槽。</p>
<a id="more"></a>
<h2 id="NSDate的8小时问题"><a href="#NSDate的8小时问题" class="headerlink" title="NSDate的8小时问题"></a>NSDate的8小时问题</h2><h3 id="NSDate转字符串时间"><a href="#NSDate转字符串时间" class="headerlink" title="NSDate转字符串时间"></a>NSDate转字符串时间</h3><p>初始化一个<code>NSDate</code>时间<code>[NSDate date]</code>，获取的是零时区的时间（格林尼治的时间: 年-月-日 时:分:秒: +时区），而北京时间是东八区时间，因为时区不同，所以打印的时间相差了8小时。此刻表示的时间是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSLog(@&quot;date时间 = %@&quot;, date);</div><div class="line"></div><div class="line">NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</div><div class="line">[formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss Z&quot;];</div><div class="line">NSString *dateStr = [formatter stringFromDate:date];</div><div class="line">NSLog(@&quot;字符串时间 = %@&quot;, dateStr);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-12-07 10:44:24.470 timeTest[32743:2995134] date时间 = 2016-12-07 02:44:24 +0000</div><div class="line">2016-12-07 10:44:24.471 timeTest[32743:2995134] 字符串时间 = 2016-12-07 10:44:24 +0800</div></pre></td></tr></table></figure>
<p>打印结果前面的时间是北京时间：<code>2016-12-07 10:44:24.470</code>。而<code>date</code>打印出来的时间显示少了8小时，因为它表示的是<code>零时区(+0000)</code>时间<code>02:44:24</code>。此刻对应东八区的北京时间就是<code>10:44:24</code>。只是时区不同，表示的时间点是一样的。好比1公斤和2斤，重量是一样的。<code>[NSDate date]</code>获取的时间单位是<code>零时区(+0000)</code>，我们所要的北京时间的单位是<code>东八区(+0800)</code>。</p>
<p>系统会默认<code>[NSDate date]</code>获取的时间为零时区时间，而经过<code>NSDateFormatter</code>转化为字符串时间就是当前所在时区的准确时间，并没有8小时误差。</p>
<h3 id="转字符串时间的时区设定"><a href="#转字符串时间的时区设定" class="headerlink" title="转字符串时间的时区设定"></a>转字符串时间的时区设定</h3><p>上文中NSDate时间转为字符串时间并没有设置<code>NSDateFormatter</code>的<code>timeZone</code>。不设置会默认使用当前所在的时区，与设置系统时区<code>formatter.timeZone = [NSTimeZone systemTimeZone]</code>的效果是一样的。</p>
<p>也可以设置时区，获取指定时区的字符串时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</div><div class="line">[formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</div><div class="line">formatter.timeZone = [NSTimeZone timeZoneWithName:@&quot;Asia/Shanghai&quot;];//东八区时间</div><div class="line">NSString *dateStr = [formatter stringFromDate:date];</div><div class="line">NSLog(@&quot;字符串时间 = %@&quot;, dateStr);</div></pre></td></tr></table></figure>
<p>这时获取的时间就是东八区时间，哪怕手机拿到零时区的格林尼治，获取的也是东八区的时间，因为这里指定时区了。也有如下时区指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">formatter.timeZone = [NSTimeZone timeZoneWithName:@&quot;Asia/Tokyo&quot;];//东九区时间</div><div class="line">formatter.timeZone = [NSTimeZone timeZoneWithName:@&quot;GMT&quot;];//零区时间</div></pre></td></tr></table></figure>
<p>通过下面方法可得到系统支持的时区对应的字符串常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSArray *zones = [NSTimeZone knownTimeZoneNames];</div><div class="line">for (NSString *zone in zones) &#123;</div><div class="line">   NSLog(@&quot;时区名 = %@&quot;, zone);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/timezone.jpg?raw=true" alt="时区对照表"></p>
<h3 id="字符串时间转NSDate"><a href="#字符串时间转NSDate" class="headerlink" title="字符串时间转NSDate"></a>字符串时间转NSDate</h3><p>字符串时间转为NSDate时间也会有时区问题。也会遇到有所谓的8小时误差，其实就是时区不同。比如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</div><div class="line">[formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss Z&quot;];</div><div class="line">NSDate *newDate = [formatter dateFromString:@&quot;2016-12-07 14:06:24 +0800&quot;];</div><div class="line">NSLog(@&quot;newDate = %@&quot;, newDate);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-12-07 14:12:17.468 timeTest[34279:3155380] newDate = 2016-12-07 06:06:24 +0000</div></pre></td></tr></table></figure>
<p><code>NSDateFormatter</code>的指定格式是：<code>@&quot;yyyy-MM-dd HH:mm:ss Z&quot;</code>。这里面的<code>Z</code>指的是时区。要转化的字符串时间格式必须和这个格式匹配，上面给定的字符串时间是：<code>@&quot;2016-12-07 14:06:24 +0800&quot;</code>，是一个东八区时间，转化为NSDate后是零区时间<code>2016-12-07 06:06:24 +0000</code>，字面显示上少了8小时，其实时间一样。</p>
<p>其实如果上面给定的字符串时间为<code>@&quot;2016-12-07 14:06:24 +0000&quot;</code>，转化出来的NSDate时间会完全一样，因为字符串时间为零时区时间，不存在时区误差。大家可以试一下。</p>
<p>当不指定字符串时间的时区时，即没有后面的<code>+0800</code>，同时要把<code>NSDateFormatter</code>时间格式里的<code>Z</code>去掉，保证格式匹配。系统会认为字符串时间是系统所在时区的时间，转化为NSDate时间是零时区时间。</p>
<p>同样，也可以使用<code>formatter.timeZone = [NSTimeZone timeZoneWithName:@&quot;GMT&quot;];</code>这种方式指定字符串时间的时区，和用<code>Z</code>对应<code>+0000</code>是一样的。</p>
<h3 id="NSDate转当前时区的NSDate时间"><a href="#NSDate转当前时区的NSDate时间" class="headerlink" title="NSDate转当前时区的NSDate时间"></a>NSDate转当前时区的NSDate时间</h3><p>因为<code>[NSDate date]</code>得出的时间是零时区时间，当我们要获取当前所在时区的NSDate时间时，通常会用以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSTimeZone *zone = [NSTimeZone systemTimeZone];</div><div class="line">NSInteger interval = [zone secondsFromGMTForDate:date];</div><div class="line">NSDate *localDate = [date  dateByAddingTimeInterval:interval];</div><div class="line">NSLog(@&quot;localDate = %@&quot;,localDate);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-12-07 14:49:03.777 timeTest[34519:3183548] localDate = 2016-12-07 14:49:03 +0000</div></pre></td></tr></table></figure>
<p>上面代码中<code>zone</code>是当前时区，<code>interval</code>是当前时区和零时区时间的差值，最后结果<code>localDate</code>是零时区时间<code>date</code>加上这个差值<code>interval</code>，得到当前时区的NSDate时间。更有甚者，在开发中直接加<code>8*60*60</code>或<code>28800</code>这样的值，因为相差8小时嘛。这样在东八区没问题，在其他时区时间就错了。</p>
<p>其实这种做法是不科学的，因为得到的最终时间还是零时区时间，时间后面明显是<code>+0000</code>，在使用中一般不显示时区，所以认为当做当前时区的时间使用也未尝不可。此为大坑！</p>
<p>坑1：这时如果转为字符串时间，又会增加8小时。因为做时间转换的时候，系统会认为这个NSDate是零时区，得到的字符串时间是东八区的。</p>
<p>解决办法是：将错就错，字符串时间也设置为零时区的字符串时间。从深坑跌入更深的坑！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSTimeZone *zone = [NSTimeZone systemTimeZone];</div><div class="line">NSInteger interval = [zone secondsFromGMTForDate:date];</div><div class="line">NSDate *localDate = [date dateByAddingTimeInterval:interval];</div><div class="line"></div><div class="line">NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</div><div class="line">[formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</div><div class="line">formatter.timeZone = [NSTimeZone timeZoneWithName:@&quot;UTC&quot;];</div><div class="line">NSString *dateStr = [formatter stringFromDate:localDate];</div><div class="line">NSLog(@&quot;字符串时间 = %@&quot;, dateStr);</div></pre></td></tr></table></figure>
<p>这里的<code>@&quot;UTC&quot;</code>是指世界标准时间，也是现在用的时间标准，东八区比这个时间也是快8小时，这里填<code>@&quot;GMT&quot;</code>也是可以的。</p>
<p>坑2：在与后台交互时，有时需要<code>+0000</code>时区，这时只能手动拼接字符串更改这个时区字段，改为正确的时区。</p>
<p><strong>所以，在开发中尽量不要这么做，当时间要求显示、存储或与后台交互的时候，使用字符串时间！不要使用转化的NSDate。</strong></p>
<h2 id="时间换算，时间戳的概念"><a href="#时间换算，时间戳的概念" class="headerlink" title="时间换算，时间戳的概念"></a>时间换算，时间戳的概念</h2><h3 id="当前时间转时间戳"><a href="#当前时间转时间戳" class="headerlink" title="当前时间转时间戳"></a>当前时间转时间戳</h3><p>时间戳是指1970年1月1日0时0分0秒到当前时间的秒数。注意：这里的当前时间是指零时区的NSDate时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSTimeInterval timeIn = [date timeIntervalSince1970];</div><div class="line">NSLog(@&quot;时间戳 = %.0f&quot;, timeIn);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-12-07 15:41:04.000 timeTest[34994:3232390] 时间戳 = 1481096464</div></pre></td></tr></table></figure>
<h3 id="时间戳转当前时间"><a href="#时间戳转当前时间" class="headerlink" title="时间戳转当前时间"></a>时间戳转当前时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSTimeInterval timeIn = [date timeIntervalSince1970];</div><div class="line">NSDate *newDate = [NSDate dateWithTimeIntervalSince1970:timeIn];</div><div class="line">NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];</div><div class="line">[dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss Z&quot;];</div><div class="line">NSString *newTime = [dateFormatter stringFromDate:newDate];</div><div class="line">NSLog(@&quot;初始化时间 = %@，时间戳=%.0f，时间戳转为NSDate时间 = %@，转为字符串时间 = %@&quot;, date, timeIn, newDate, newTime);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-12-07 16:11:56.146 timeTest[35186:3253589] 初始化时间 = 2016-12-07 08:11:56 +0000，时间戳=1481098316，时间戳转为NSDate时间 = 2016-12-07 08:11:56 +0000，转为字符串时间 = 2016-12-07 16:11:56 +0800</div></pre></td></tr></table></figure>
<p>注意时间戳使用的NSDate时间是当前零时区的时间！当前零时区时间！当前零时区时间！重要的事情说三遍！不要进行NSDate转当前时区的NSDate时间，再转时间戳。下面是验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSLog(@&quot;系统零时区NSDate时间 = %@&quot;, date);    </div><div class="line">NSTimeInterval timeIn = [date timeIntervalSince1970];</div><div class="line">NSLog(@&quot;系统零时区NSDate时间转化为时间戳 = %.0f&quot;, timeIn);</div><div class="line">NSTimeZone *zone = [NSTimeZone systemTimeZone];</div><div class="line">NSInteger interval = [zone secondsFromGMTForDate:date];</div><div class="line">NSDate *localDate = [date  dateByAddingTimeInterval:interval];</div><div class="line">NSLog(@&quot;转化为本地NSDate时间 = %@&quot;, localDate);</div><div class="line">NSTimeInterval timeIn2 = [localDate timeIntervalSince1970];</div><div class="line">NSLog(@&quot;本地NSDate时间转化为时间戳 = %.0f&quot;, timeIn2);</div><div class="line">NSDate *detaildate = [NSDate dateWithTimeIntervalSince1970:timeIn];</div><div class="line">NSDate *detaildate2 = [NSDate dateWithTimeIntervalSince1970:timeIn2];</div><div class="line">NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];</div><div class="line">[dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss Z&quot;];</div><div class="line">NSString *newTime = [dateFormatter stringFromDate:detaildate];</div><div class="line">NSString *newTime2 = [dateFormatter stringFromDate:detaildate2];</div><div class="line">NSLog(@&quot;最终转为字符串时间1 = %@， 时间2 = %@&quot;, newTime, newTime2);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2016-12-07 16:13:57.834 timeTest[35211:3255842] 系统零时区NSDate时间 = 2016-12-07 08:13:57 +0000</div><div class="line">2016-12-07 16:13:57.834 timeTest[35211:3255842] 系统零时区NSDate时间转化为时间戳 = 1481098438</div><div class="line">2016-12-07 16:13:57.835 timeTest[35211:3255842] 转化为本地NSDate时间 = 2016-12-07 16:13:57 +0000</div><div class="line">2016-12-07 16:13:57.835 timeTest[35211:3255842] 本地NSDate时间转化为时间戳 = 1481127238</div><div class="line">2016-12-07 16:13:57.836 timeTest[35211:3255842] 最终转为字符串时间1 = 2016-12-07 16:13:57 +0800， 时间2 = 2016-12-08 00:13:57 +0800</div></pre></td></tr></table></figure>
<p>问题解释详见上文的<code>NSDate转当前时区的NSDate时间</code>。</p>
<h2 id="时间操作与比较"><a href="#时间操作与比较" class="headerlink" title="时间操作与比较"></a>时间操作与比较</h2><h3 id="时间初始化和比较方法"><a href="#时间初始化和比较方法" class="headerlink" title="时间初始化和比较方法"></a>时间初始化和比较方法</h3><p>几个时间初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//初始化当前时间，返回零时区时间</div><div class="line">NSDate *date = [NSDate date];</div><div class="line">//以当前时间为准，正数超前指定秒数，负数延后指定秒数</div><div class="line">NSDate *laterDate = [NSDate dateWithTimeIntervalSinceNow:60];</div><div class="line">//以2001-01-01 00:00:00 +0000为基准，正数超前指定秒数，负数延后指定秒数</div><div class="line">NSDate *newDate = [NSDate dateWithTimeIntervalSinceReferenceDate:60];</div><div class="line">//以1970-01-01 00:00:00 +0000为基准，正数超前指定秒数，负数延后指定秒数</div><div class="line">NSDate *newDate1 = [NSDate dateWithTimeIntervalSince1970:60];</div><div class="line">//实例方法，以指定时间为基准，正数超前指定秒数，负数延后指定秒数</div><div class="line">NSDate *newDate2 = [date dateByAddingTimeInterval:60];</div><div class="line">//很久以后的某一天</div><div class="line">NSDate *newDate3 = [NSDate distantFuture];</div><div class="line">//很久以前的某一天</div><div class="line">NSDate *newDate4 = [NSDate distantPast];</div></pre></td></tr></table></figure>
<p>几个时间比较方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//比较两个时间是否相等</div><div class="line">- (BOOL)isEqualToDate:(NSDate *)otherDate;</div><div class="line">//两个时间比较，返回较早时间</div><div class="line">- (NSDate *)earlierDate:(NSDate *)anotherDate;</div><div class="line">//两个时间比较，返回较晚时间</div><div class="line">- (NSDate *)laterDate:(NSDate *)anotherDate;</div><div class="line">//两个时间比较，返回枚举类型</div><div class="line">- (NSComparisonResult)compare:(NSDate *)other;</div></pre></td></tr></table></figure>
<p>几个计算时间间隔的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//返回实例时间与refDate时间间隔秒数</div><div class="line">- (NSTimeInterval)timeIntervalSinceDate:(NSDate *)refDate;</div><div class="line">//返回实例时间与当前时间间隔秒数</div><div class="line">- (NSTimeInterval)timeIntervalSinceNow;</div><div class="line">//返回实例时间的时间戳</div><div class="line">- (NSTimeInterval)timeIntervalSince1970;</div><div class="line">//返回实例时间和2001-01-01 00:00:00 +0000的间隔秒数</div><div class="line">- (NSTimeInterval)timeIntervalSinceReferenceDate;</div><div class="line">//返回当前时间和2001-01-01 00:00:00 +0000的间隔秒数</div><div class="line">+ (NSTimeInterval)timeIntervalSinceReferenceDate;</div></pre></td></tr></table></figure>
<h3 id="获取年月日时分秒周时区"><a href="#获取年月日时分秒周时区" class="headerlink" title="获取年月日时分秒周时区"></a>获取年月日时分秒周时区</h3><p>oc里的时间坑太多，根本没办法像其他语言那样直接time.year就能获取年份。要想获取NSDate的年月日需要使用日历对象<code>NSCalendar</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSCalendar *cal = [NSCalendar currentCalendar];</div><div class="line">NSDateComponents *dateComps = [cal components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay|NSCalendarUnitHour|NSCalendarUnitMinute|NSCalendarUnitSecond|NSCalendarUnitWeekday|NSCalendarUnitWeekOfMonth|NSCalendarUnitWeekOfYear|NSCalendarUnitTimeZone fromDate:date];</div><div class="line">NSLog(@&quot;时间 = %@&quot;, date);</div><div class="line">NSLog(@&quot;年=%ld,月=%ld,日=%ld,时=%ld,分=%ld,秒=%ld,周=%ld,本月第%ld周,本年第%ld周,时区=%@&quot;, dateComps.year, dateComps.month, dateComps.day, dateComps.hour, dateComps.minute, dateComps.second, dateComps.weekday, dateComps.weekOfMonth, dateComps.weekOfYear, dateComps.timeZone.name);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-12-07 17:20:41.639 timeTest[35734:3311752] 时间 = 2016-12-07 09:20:41 +0000</div><div class="line">2016-12-07 17:20:41.640 timeTest[35734:3311752] 年=2016,月=12,日=7,时=17,分=20,秒=41,周=4,本月第2周,本年第50周,时区=Asia/Shanghai</div></pre></td></tr></table></figure>
<p><code>NSDateComponents</code>创建方法中添加的枚举<code>NSCalendarUnit</code>，是后面要获取的年月日时分秒必须对应添加的。比如要获取年<code>dateComps.year</code>，就需要添加枚举<code>NSCalendarUnitYear</code>。</p>
<p>可以看到，<code>[NSDate date]</code>时间可以使用<code>NSCalendar</code>直接获取当前时区的时分秒，打印的<code>时</code>和<code>时区</code>即可看出。这是<code>[NSCalendar currentCalendar]</code>日历对象初始化的原因，也可以用<code>[[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian]</code>指定Identifier的方式初始化阳历日历。可以试试指定Identifier为<code>NSCalendarIdentifierChinese</code>，打印的是中国农历。</p>
<p><code>dateComps.weekOfMonth</code>是今天属于本月的第几周。</p>
<p><code>dateComps.weekOfYear</code>是今天属于本年的第几周。</p>
<p><code>dateComps.weekday</code>是星期，这个和日常使用有些不同。上述程序打印的是<code>周=4</code>，但2016-12-07是<code>周三</code>。这里<code>weekday</code>的对应关系是：周日-1，周一-2，周二-3，周三-4，周四-5，周五-6，周六-7。毕竟国外惯例周日是每周的第一天。</p>
<h2 id="农历"><a href="#农历" class="headerlink" title="农历"></a>农历</h2><p>获取农历的工具方法，可根据需求添加农历节日和二十四节气</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">+ (NSString *)LunarForSolarYear:(int)wCurYear Month:(int)wCurMonth Day:(int)wCurDay</div><div class="line">&#123;</div><div class="line">    //农历日期名</div><div class="line">    NSArray *cDayName =  [NSArray arrayWithObjects:@&quot;*&quot;,@&quot;初一&quot;,@&quot;初二&quot;,@&quot;初三&quot;,@&quot;初四&quot;,@&quot;初五&quot;,@&quot;初六&quot;,@&quot;初七&quot;,@&quot;初八&quot;,@&quot;初九&quot;,@&quot;初十&quot;,@&quot;十一&quot;,@&quot;十二&quot;,@&quot;十三&quot;,@&quot;十四&quot;,@&quot;十五&quot;,@&quot;十六&quot;,@&quot;十七&quot;,@&quot;十八&quot;,@&quot;十九&quot;,@&quot;二十&quot;,@&quot;廿一&quot;,@&quot;廿二&quot;,@&quot;廿三&quot;,@&quot;廿四&quot;,@&quot;廿五&quot;,@&quot;廿六&quot;,@&quot;廿七&quot;,@&quot;廿八&quot;,@&quot;廿九&quot;,@&quot;三十&quot;,nil];</div><div class="line">    //农历月份名</div><div class="line">    NSArray *cMonName =  [NSArray arrayWithObjects:@&quot;*&quot;,@&quot;正月&quot;,@&quot;二月&quot;,@&quot;三月&quot;,@&quot;四月&quot;,@&quot;五月&quot;,@&quot;六月&quot;,@&quot;七月&quot;,@&quot;八月&quot;,@&quot;九月&quot;,@&quot;十月&quot;,@&quot;冬月&quot;,@&quot;腊月&quot;,nil];</div><div class="line">    //公历每月前面的天数</div><div class="line">    const int wMonthAdd[12] = &#123;0,31,59,90,120,151,181,212,243,273,304,334&#125;;</div><div class="line">    //农历数据</div><div class="line">    const int wNongliData[100] = &#123;2635,333387,1701,1748,267701,694,2391,133423,1175,396438</div><div class="line">        ,3402,3749,331177,1453,694,201326,2350,465197,3221,3402</div><div class="line">        ,400202,2901,1386,267611,605,2349,137515,2709,464533,1738</div><div class="line">        ,2901,330421,1242,2651,199255,1323,529706,3733,1706,398762</div><div class="line">        ,2741,1206,267438,2647,1318,204070,3477,461653,1386,2413</div><div class="line">        ,330077,1197,2637,268877,3365,531109,2900,2922,398042,2395</div><div class="line">        ,1179,267415,2635,661067,1701,1748,398772,2742,2391,330031</div><div class="line">        ,1175,1611,200010,3749,527717,1452,2742,332397,2350,3222</div><div class="line">        ,268949,3402,3493,133973,1386,464219,605,2349,334123,2709</div><div class="line">        ,2890,267946,2773,592565,1210,2651,395863,1323,2707,265877&#125;;</div><div class="line">    static int nTheDate,nIsEnd,m,k,n,i,nBit;</div><div class="line">    //计算到初始时间1921年2月8日的天数：1921-2-8(正月初一)</div><div class="line">    nTheDate = (wCurYear - 1921) * 365 + (wCurYear - 1921) / 4 + wCurDay + wMonthAdd[wCurMonth - 1] - 38;</div><div class="line">    if((!(wCurYear % 4)) &amp;&amp; (wCurMonth &gt; 2))</div><div class="line">        nTheDate = nTheDate + 1;</div><div class="line">    //计算农历天干、地支、月、日</div><div class="line">    nIsEnd = 0;</div><div class="line">    m = 0;</div><div class="line">    while(nIsEnd != 1) &#123;</div><div class="line">        if(wNongliData[m] &lt; 4095)</div><div class="line">            k = 11;</div><div class="line">        else</div><div class="line">            k = 12;</div><div class="line">        n = k;</div><div class="line">        while(n&gt;=0) &#123;</div><div class="line">            //获取wNongliData(m)的第n个二进制位的值</div><div class="line">            nBit = wNongliData[m];</div><div class="line">            for(i=1;i&lt;n+1;i++)</div><div class="line">                nBit = nBit/2;</div><div class="line">            nBit = nBit % 2;</div><div class="line">            </div><div class="line">            if (nTheDate &lt;= (29 + nBit)) &#123;</div><div class="line">                nIsEnd = 1;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            nTheDate = nTheDate - 29 - nBit;</div><div class="line">            n = n - 1;</div><div class="line">        &#125;</div><div class="line">        if(nIsEnd)</div><div class="line">            break;</div><div class="line">        m = m + 1;</div><div class="line">    &#125;</div><div class="line">    wCurYear = 1921 + m;</div><div class="line">    wCurMonth = k - n + 1;</div><div class="line">    wCurDay = nTheDate;</div><div class="line">    if (k == 12) &#123;</div><div class="line">        if (wCurMonth == wNongliData[m] / 65536 + 1)</div><div class="line">            wCurMonth = 1 - wCurMonth;</div><div class="line">        else if (wCurMonth &gt; wNongliData[m] / 65536 + 1)</div><div class="line">            wCurMonth = wCurMonth - 1;</div><div class="line">    &#125;</div><div class="line">    //生成农历月</div><div class="line">    NSString *szNongliMonth;</div><div class="line">    if (wCurMonth &lt; 1) &#123;</div><div class="line">        szNongliMonth = [NSString stringWithFormat:@&quot;闰%@&quot;,(NSString *)[cMonName objectAtIndex:-1 * wCurMonth]];</div><div class="line">    &#125;else&#123;</div><div class="line">        szNongliMonth = (NSString *)[cMonName objectAtIndex:wCurMonth];</div><div class="line">    &#125;</div><div class="line">    //生成农历日</div><div class="line">    NSString *szNongliDay = [cDayName objectAtIndex:wCurDay];</div><div class="line">    //合并</div><div class="line">    NSString *lunarDate = [NSString stringWithFormat:@&quot;%@-%@&quot;,szNongliMonth,szNongliDay];</div><div class="line">    return lunarDate;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发中，经常会遇到各种各样的时间问题，8小时时差，时间戳，求时间间隔，农历等等。解决办法网上比比皆是，但大多零零散散，很多资料并没有说明其中问题。这里集中总结一下，以便于以后查阅和供大家参考。有我自己的理解，错漏之处请大家吐槽。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS10" scheme="http://markmiao.com/tags/iOS10/"/>
    
  </entry>
  
  <entry>
    <title>我想做个APP，多长时间，多少钱</title>
    <link href="http://markmiao.com/2016/11/30/%E6%88%91%E6%83%B3%E5%81%9A%E4%B8%AAAPP%EF%BC%8C%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4%EF%BC%8C%E5%A4%9A%E5%B0%91%E9%92%B1/"/>
    <id>http://markmiao.com/2016/11/30/我想做个APP，多长时间，多少钱/</id>
    <published>2016-11-30T08:38:32.000Z</published>
    <updated>2016-11-30T09:13:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在一个阳光明媚的下午，我正瘫坐在椅子上改bug。忽然有人给我发微信：“我想做个app，多长时间，多少钱？”</p>
<p>从我从业iOS开发到现在，这个问题被问过无数次，比那句：“你是程序员，那你会修电脑吗？”还要令人烦。毕竟那只是句玩笑话，而这句在其他人（更多时候是你的boss，经理这些非程序员出身的IT内行人）看来是你的专业，是你必须要知道的，你能回答不知道吗？显得你太不专业了。但这句话最专业、最负责任的回答就是：“我不知道！”</p>
<a id="more"></a>
<p>问我问题的是朋友的朋友，一个在传统行业浸淫多年的人，立志要突破传统行业的束缚，做互联网浪潮中的弄潮儿。当时听他说这句话的时候我有点懵逼：互联网浪潮中的弄潮儿？指示十多年前马云、马化腾那一批吗？现在互联网都蔓延成海了，哪还有潮让你浪，能做一条杂鱼苟延残喘的活下去就不错了。</p>
<p>我真想回答“我不知道”，毕竟还有好多bug等着我改呢，没必要在这浪费时间。但又想到毕竟有过一面之缘，直接回答不知道，是不是显得有点不给面子？在这个问题上，很多时候就是这么栽进坑里的。</p>
<p>“什么类型的app？”这句话发出去，毫无疑问的掉坑里了。他给我发了个app截图，说：“跟这个差不多，不用那么复杂，简单点就行。”</p>
<p>我一看，好嘛，淘宝？！你还真是打算做弄潮儿啊！我说：“淘宝啊？得十多年吧。”加了一个呵呵的表情，一方面想表达我认为你是在开玩笑，我也是开玩笑的回复，另一方面是我想呵呵你一脸。其实我也不算敷衍，淘宝03年成立，做到现在也十多年了。</p>
<p>他明显没有get到我的意思，反而埋怨我没get到他的点。说：“我的意思是淘宝这个类型的app，肯定不用跟淘宝似的那么复杂。简单点，有个列表，可以卖东西就行，几天能弄出来？重要的是要快！”看这意思是：我已想到一个天才创意，就差一个能把创意转化成app的高效程序员了，一定要高效，几天就能做出来，上架使用，推广全国。</p>
<p>这时我能想到的最靠谱的建议是：花钱收购现有的，你觉得最符合你创意理念的那款app。当然这个看似调侃实则靠谱的回答是没办法说出口的。我语重心长的回答道：“电商类app，只保留必要功能：商品展示、登录注册、购物车、下单支付、订单记录，精简到最简单，只是iOS客户端的实现代码也不可能几天内写完。“</p>
<p>本以为我这么说对方会重新估量开发一款app的复杂度，没想到对方急了：”不用考虑那么复杂，先做出一个最简单的，其他的慢慢迭代。就告诉我最快多长时间能搞定，大概花多少钱就行。“</p>
<p>这就是耍流氓了，好话说了一火车，油盐不进。我要还妄想改变他的想法，我就是2B了。索性开门见山的说：三个月。在团队完备，不改需求的前提下。找个人兼职外包，按平均日薪结算。</p>
<p>对方没再回话，不知道是听从我的建议去紧张筹备项目小组了，还是觉得我是个菜狗，这么点小事竟然张口就说三个月，三个月吃屎都赶不上热乎的了。我估计是后者的概率大。喝了口水抖擞抖擞精神，继续改我的bug。遥想当年我也曾豪言壮语，但到最后都跌的遍体鳞伤……</p>
<p>此类情况遇到N多次了，像这种无关自己工作的外部人士咨询行情的还好，毕竟你只需要给出自己认为合理的建议即可。人家也不一定采纳，说不定只是做个对比筛选，事后成功与否都事不关己。但多数情况下是boss或部门经理会问你这个问题，那回答的时候就不是这样轻轻松松侃侃而谈了。毕竟，说出去的话是要兑现的，挖了坑自己填不上，是要栽进去的。</p>
<p>我认为：任何没有完整功能逻辑原型图就问开发时间的都是耍流氓，有原型图问开发时间事后改需求的都是耍无赖。这两者的共同点就是玩死人不偿命。</p>
<p>为什么开发不能像其他行业那样精准预估工期呢？因为开发工作的变数太大。以最常见的app登录功能举例，常见的登录方式有：账号+密码、手机号+验证码和第三方平台登录。手机+验证码需要找短信服务商，要考虑验证码的送达速度和费用问题。第三方登录需要注册账号，创建应用，以及认证开发者资质。腾讯开放平台创建应用需要填写appid，要想有appid需要在iTunes Connect里创建应用，在此之前必须有苹果的开发者账号，申请开发者账号是要公司级还是个人级的？公司级的需要提供邓白氏码。所有这一切都需要时间审核，部分资质认证、账号注册需要花钱。</p>
<p>以上是平台账号问题，下面说开发问题。有登录就得有注册，要保证用户的唯一性，需要有一个唯一标识。以手机号作为唯一标识的话，采用第三方登录的没有手机号，分配独立用户id作为唯一标示的话，先用手机号登录，再用微信登录，就会产生两个用户，如何实现绑定手机号合并用户呢？还有是否保留账号+密码注册呢？如果保留的话还需要有找回密码功能，找回密码是要邮箱验证还是手机验证码验证呢……</p>
<p>一款app并不是简简单单找个码农，噼里啪啦敲一顿键盘就能完成的。至少需要以下几种角色：产品经理，能拍板项目功能逻辑出原型图，把控整个项目进度和团队配合；设计师，根据原型图做高保真交互设计；服务端工程师，做后台数据处理，提供客户端所需接口；客户端工程师，实现app所有的功能逻辑，性能优化，上架应用市场；测试工程师，测试app功能逻辑的正确性和性能。这些只是角色标配，并非每个角色都对应一个人。比如客户端可能需要Android、iOS、WP多个开发工程师，开发往往会兼任测试工作，后台有时会代理产品经理工作。又或者你是精通设计的全栈工程师，对产品又有资深造诣，那便可以身兼所有角色。所以这里又牵扯到团队协作，再默契的团队都会存在沟通成本，只是成本高低的问题。全栈工程师单人开发，没有沟通成本的单兵作战，时间成本会大大增加。所以说：程序开发是一个充满无数不可预知变化的职业，不可能精准预估工期。</p>
<p>道理我们都懂，那开发一个app到底要多长时间呢？预估工期虽然令人讨厌，但确实是一个客户端程序员该具备的能力。当看到原型图预估时间的时候，往往只估算了敲app代码的时间，而且还是个理想化时间。认为自己胸怀万码，光标到处bug灰飞烟灭，功能实现如有神助，代码编译一次通过，简直是码生赢家啊。现实会毫不留情的给你狠狠地一巴掌。比如一个原型图上有10个界面，都是最简单的push跳转，用Storyboard一个小时就能画完，剩下七个小时写数据展示，so easy啊，然后洋洋得意的告诉boss一天就能搞定。然后Storyboard代码版本冲突了，解决冲突用了仨小时，接口响应方式没指明，参数格式写错了，调了仨小时。六个小时过去后，慌了……</p>
<p>之所以不可预估，是因为存在太多的不确定因素。一些不确定因素会因为经验积累而变为确定因素，另一些不确定因素却会一直存在。程序员拿到需求的时候，需要有一个心理预估，每个功能模块多久能完成，哪些逻辑是我以前写过的，哪些框架是需要谷歌才会用的，哪些页面目前还不能确定实现方法。对每个模块分配一个时间块，不求预估准确，但求时间精确，最后把这些时间块加起来，然后乘一个π值，得到的便是一个相对合理的开发工期预估。随着经验积累，慢慢地不需要乘π值了，乘2.5，乘2，乘1.5……能乘以1那就是大神了，乘以0.x就超神了。其实有经验的产品经理也会以这种方式来计算程序员的工期预估，毕竟有经验的产品经理都是被程序员不擅长工期预估而坑过无数次的。唉，相爱相杀，产品狗何苦为难程序猿，程序猿何苦坑害产品狗。</p>
<p>还有开发一个app要多少钱？这个问题其实不应该问程序员，毕竟程序员大多是写死程序、拿死工资的码农。即便是外包公司的程序员也不会接触到公司业务，除非是谈过外包项目，很有经验的产品负责人才能明白这里的行情。我没在外包公司待过，但私下里接过外包项目，大概了解过外包行情。</p>
<p>找个人接外包一般会有两种工资算法，一种是按日薪支付，一种是按预算均分。按日薪支付是指预估出该项目大概需要多长时间，并与甲方谈妥时间点，找产品做原型，找设计出图，找程序员开发，并按日支付项目参与者在职岗位的平均日薪，当然参与者需要在规定时间内完成工作。按预算均分是指该项目甲方一共能给多少预算，开发该项目的所有人员均分这笔预算。这种方式适合熟人团队开发小项目，例如之前接的一个小项目三万块，后台、iOS、Android一人一万，原型图和设计是甲方提供的，开发时间总计两周。其实有时间的话，还是蛮乐意接这种小外包的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个阳光明媚的下午，我正瘫坐在椅子上改bug。忽然有人给我发微信：“我想做个app，多长时间，多少钱？”&lt;/p&gt;
&lt;p&gt;从我从业iOS开发到现在，这个问题被问过无数次，比那句：“你是程序员，那你会修电脑吗？”还要令人烦。毕竟那只是句玩笑话，而这句在其他人（更多时候是你的boss，经理这些非程序员出身的IT内行人）看来是你的专业，是你必须要知道的，你能回答不知道吗？显得你太不专业了。但这句话最专业、最负责任的回答就是：“我不知道！”&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://markmiao.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="APP开发" scheme="http://markmiao.com/tags/APP%E5%BC%80%E5%8F%91/"/>
    
      <category term="外包" scheme="http://markmiao.com/tags/%E5%A4%96%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>微信报名系统H5页面开发</title>
    <link href="http://markmiao.com/2016/11/28/%E5%BE%AE%E4%BF%A1%E6%8A%A5%E5%90%8D%E7%B3%BB%E7%BB%9FH5%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    <id>http://markmiao.com/2016/11/28/微信报名系统H5页面开发/</id>
    <published>2016-11-28T01:58:29.000Z</published>
    <updated>2016-11-28T02:16:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作需要，用HTML5写一个微信的内置网页，是一个参会报名流程。上次写html还是上学时交作业，现在着实有些手忙脚乱了，现学现用、磕磕绊绊，项目总算告一段落，到了要总结一下的时候了。简单记录了做这个项目时所遇到的问题，有些问题在网上能搜到解决办法，有些问题是为了实现效果耍的小聪明。</p>
<a id="more"></a>
<h2 id="工具以及框架"><a href="#工具以及框架" class="headerlink" title="工具以及框架"></a>工具以及框架</h2><p>由于我只负责h5界面(<del>让我负责java后台也做不来。我对好多语言都有兴趣，对java就是提不起兴趣，或许是因为大学学java学烦了。</del>)，所以就用了<a href="http://www.dcloud.io/" target="_blank" rel="external">HBuilder</a>只码web界面，这个开发工具开发h5网页来说很便利，比如它有代码提醒、边改边看模式、手机端网页运行、运行到iPhone上等等功能，但也有不好用的地方，比如快捷键、搜索方式等。</p>
<p>还有开发微信内置web网页必不可少的工具：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1455784140&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信web开发者工具</a>。很不幸的说开发到中期才发现这个工具，明明就在微信JS-SDK下面就是视而不见。目前这个工具已经升级为开发小程序专用编译器，不能调试微信内置web页面。</p>
<p>当然还有谷歌浏览器Google Chrome，浏览器来说，我之前是火狐党，开发这个项目才用了谷歌浏览器。谷歌的开发者工具挺好用的，有错误调试，样式修改，多种手机屏幕调试。还有<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信JS-SDK说明文档</a>火狐浏览器上目录点击无效，谷歌浏览器就可以调转到相应内容。还有一点，项目中用到了一个别人写好的<code>picker</code>控件，在火狐浏览器上打开一团糟，谷歌浏览器完美运行，幸运的是微信内置浏览器也运行无误。重点说明：我不是火狐黑，项目之外依旧继续用火狐。这时可以感觉到web开发做浏览器兼容还是有很多工作的。</p>
<p>开发微信用的东西肯定要用微信提供的开发样式库<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1455784134&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">WeUI</a>，毕竟风格相近直接拿来用就行，即便是不一样，改起来也方便很多。包括微信的JS-SDK的<a href="http://203.195.235.76/jssdk/" target="_blank" rel="external">demo示例代码</a></p>
<p>还有号称最接近原生APP体验的高性能前端框架<a href="http://dev.dcloud.net.cn/mui/" target="_blank" rel="external">MUI</a>，项目中的picker就是用的这里的。</p>
<h2 id="微信分享调用和地图功能"><a href="#微信分享调用和地图功能" class="headerlink" title="微信分享调用和地图功能"></a>微信分享调用和地图功能</h2><h3 id="分享功能重写，调用地图"><a href="#分享功能重写，调用地图" class="headerlink" title="分享功能重写，调用地图"></a>分享功能重写，调用地图</h3><p>微信分享和地图调用都使用了微信提供的JS-SDK，公众平台有详细的说明文档。这里只记录一些调用步骤和遇到的问题。</p>
<p>微信分享不用单独去写，微信内置网页右上角会自动加入分享功能，默认分享出去的网页样式标题为页面标题，图片为网页中第一张图片，简介也是第一段文字。如果想自定义这些样式内容，就需要重写分享方法。</p>
<p>引入js文件，建议调用<code>https</code>的js地址，如果页面启用了<code>https</code>，使用<code>http</code>的js地址在iOS9中将无法调用sdk</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"https://res.wx.qq.com/open/js/jweixin-1.0.0.js"</span> type=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>调用config方法，配置权限验证</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">wx.config(&#123;</div><div class="line">	<span class="attr">debug</span>: <span class="literal">true</span>,<span class="comment">//开启调试模式，一直有alert出现。发布页面时改为false</span></div><div class="line">	appId: <span class="string">'wx1234567890032222'</span>,<span class="comment">//微信公众号唯一标示。</span></div><div class="line">	timestamp: timestamp,<span class="comment">//时间戳</span></div><div class="line">	nonceStr: nonceStr,<span class="comment">//随机串</span></div><div class="line">	signature: signature,<span class="comment">//签名</span></div><div class="line">	jsApiList: [</div><div class="line">		<span class="string">'checkJsApi'</span>,<span class="comment">//验证客户端版本是否支持sdk</span></div><div class="line">		<span class="string">'onMenuShareTimeline'</span>,<span class="comment">//分享朋友圈</span></div><div class="line">		<span class="string">'onMenuShareAppMessage'</span>,<span class="comment">//发送给朋友</span></div><div class="line">		<span class="string">'openLocation'</span>,<span class="comment">//地图</span></div><div class="line">		<span class="string">'showOptionMenu'</span><span class="comment">//开启右上角按钮内页面分享按钮</span></div><div class="line">	]</div><div class="line">&#125;);</div><div class="line"></div><div class="line">wx.ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="comment">// 1 判断当前版本是否支持指定 JS 接口，支持批量判断</span></div><div class="line">	wx.checkJsApi(&#123;</div><div class="line">		<span class="attr">jsApiList</span>: [<span class="string">'getNetworkType'</span>, <span class="string">'previewImage'</span>],</div><div class="line">		<span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	<span class="comment">// 地理位置</span></div><div class="line">	<span class="built_in">document</span>.querySelector(<span class="string">'#openLocation'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		wx.openLocation(&#123;</div><div class="line">			<span class="attr">latitude</span>: <span class="number">22.537180</span>,<span class="comment">//纬度</span></div><div class="line">			longitude: <span class="number">113.976250</span>,<span class="comment">//经度</span></div><div class="line">			name: <span class="string">'xxxx酒店'</span>,<span class="comment">//位置名</span></div><div class="line">			address: <span class="string">'地址说明'</span>,</div><div class="line">			<span class="attr">scale</span>: <span class="number">14</span>,<span class="comment">//地图缩放级别范围从1~28</span></div><div class="line">			infoUrl: <span class="string">''</span><span class="comment">//在查看位置界面底部显示的超链接,可点击跳转</span></div><div class="line">		&#125;);</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="comment">// 2.1 监听“分享给朋友”，按钮点击、自定义分享内容及分享结果接口</span></div><div class="line">	wx.onMenuShareAppMessage(&#123;</div><div class="line">		<span class="attr">title</span>: <span class="string">'分享标题'</span>,</div><div class="line">		<span class="attr">desc</span>: <span class="string">'分享简介'</span>,</div><div class="line">		<span class="attr">link</span>: <span class="string">'https://www.baidu.com'</span>,<span class="comment">//分享地址</span></div><div class="line">		imgUrl: <span class="string">'http://oalg33nuc.bkt.clouddn.com/image/wechatshareimg.jpg'</span>,<span class="comment">//分享图片的地址</span></div><div class="line">	&#125;);</div><div class="line"></div><div class="line">	<span class="comment">// 2.2 监听“分享到朋友圈”按钮点击、自定义分享内容及分享结果接口</span></div><div class="line">	wx.onMenuShareTimeline(&#123;</div><div class="line">		<span class="attr">title</span>: <span class="string">'分享标题'</span>,</div><div class="line">		<span class="attr">desc</span>: <span class="string">'分享简介'</span>,</div><div class="line">		<span class="attr">link</span>: <span class="string">'https://www.baidu.com'</span>,<span class="comment">//分享地址</span></div><div class="line">		imgUrl: <span class="string">'http://oalg33nuc.bkt.clouddn.com/image/wechatshareimg.jpg'</span>,<span class="comment">//分享图片的地址</span></div><div class="line">	&#125;);</div><div class="line">	</div><div class="line">	wx.showOptionMenu();<span class="comment">//显示微信右上角点开的分享按钮</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这一块前端网页还是比较简单的，因为所需要的<code>签名signature</code>等参数都是后台算好给的。生成签名需要<code>jsapi_ticket</code>，要拿到<code>jsapi_ticket</code>需要<code>access_token</code>，获取<code>access_token</code>的步骤和在iOS原生应用中做微信分享是一样的，拿<code>appid</code>和<code>secret</code>等参数调用接口获取<code>access_token</code>。</p>
<h3 id="分享按钮显示-隐藏"><a href="#分享按钮显示-隐藏" class="headerlink" title="分享按钮显示/隐藏"></a>分享按钮显示/隐藏</h3><p>分享按钮的显示问题，有时候要求只要指定页面分享出去，其他页面不能要分享，要隐藏掉分享按钮(发给朋友/分享到朋友圈/复制链接/收藏/邮件等等等)。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG65.jpeg?raw=true" alt="显示按钮"></th>
<th style="text-align:center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG66.jpeg?raw=true" alt="隐藏按钮"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>显示的页面需要在<code>wx.config</code>的<code>jsApiList:[]</code>里面添加<code>showOptionMenu</code>。并调用<code>wx.showOptionMenu();</code>显示方法。</p>
<p>隐藏的页面需要在<code>wx.config</code>的<code>jsApiList:[]</code>里面添加<code>hideOptionMenu</code>。并调用<code>wx.hideOptionMenu();</code>隐藏方法。</p>
<p>有隐藏就要对应有显示，比如第一个页面不作操作默认显示。第二个页面隐藏了，返回第一个页面分享按钮也会被隐藏。所以第一个页面要有显示调用。</p>
<h2 id="MUI的Picker使用问题"><a href="#MUI的Picker使用问题" class="headerlink" title="MUI的Picker使用问题"></a>MUI的Picker使用问题</h2><h3 id="调用MUI的Picker"><a href="#调用MUI的Picker" class="headerlink" title="调用MUI的Picker"></a>调用MUI的Picker</h3><p>用的MUI框架里的picker，调用起来还是很方便的，<code>layer: 2</code>是联级数量，支持多级picker，如果是单级的layer省略不写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cityPicker = <span class="keyword">new</span> $.PopPicker(&#123;</div><div class="line">	<span class="attr">layer</span>: <span class="number">2</span></div><div class="line">&#125;);</div><div class="line">cityPicker.setData(cityData);</div><div class="line"><span class="keyword">var</span> showCityPickerButton = <span class="built_in">document</span>.getElementById(<span class="string">'showCityPicker'</span>);</div><div class="line"><span class="keyword">var</span> cityResult = <span class="built_in">document</span>.getElementById(<span class="string">'selectCityContent'</span>);</div><div class="line">showCityPickerButton.addEventListener(<span class="string">'tap'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">	<span class="built_in">document</span>.activeElement.blur();</div><div class="line">	cityPicker.show(<span class="function"><span class="keyword">function</span>(<span class="params">items</span>) </span>&#123;</div><div class="line">		alert(items[<span class="number">0</span>].text + <span class="string">' '</span> + items[<span class="number">1</span>].text);<span class="comment">//点击确认时的选择结果</span></div><div class="line">		<span class="comment">//返回 false 可以阻止选择框的关闭</span></div><div class="line">		<span class="comment">//return false;</span></div><div class="line">	&#125;);</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h3 id="PopPicker在软键盘弹出时不能完全隐藏"><a href="#PopPicker在软键盘弹出时不能完全隐藏" class="headerlink" title="PopPicker在软键盘弹出时不能完全隐藏"></a>PopPicker在软键盘弹出时不能完全隐藏</h3><p>用的时候还有点问题，在火狐浏览器里，picker的cell都挤在一起了，根本无法滑动。至于是什么原因我也没有研究，因为在微信内置浏览器里可以用。还有另一个bug是不能不改的，iOS中有问题，Android中没问题。就是在输入信息页面，直接点击靠近屏幕下边缘的输入框，页面向上偏移，滑动页面时原本隐藏的picker粗线了。如下左图，右图才是它该有的样子。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG67.jpeg?raw=true" alt="picker出现了"></th>
<th style="text-align:center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG68.jpeg?raw=true" alt="正常的样子，不该出现"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>需要在mui.poppicker.js中增加初始化、show和hide方法中display的改变。解决办法如下，或见<a href="http://ask.dcloud.net.cn/article/603" target="_blank" rel="external">iOS键盘弹出后PopPicker出现的临时解决方法</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//init构造函数最后增加两行：</span></div><div class="line">self.panel.style.display = <span class="string">'none'</span>;</div><div class="line">self.body.style.display = <span class="string">'none'</span>;</div><div class="line"></div><div class="line"><span class="comment">//显示</span></div><div class="line">show: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">	<span class="comment">//增加以下2行</span></div><div class="line">	self.panel.style.display = <span class="string">'block'</span>;</div><div class="line">	self.body.style.display = <span class="string">'block'</span>;</div><div class="line">	self.callback = callback;</div><div class="line">	self.mask.show();</div><div class="line">	<span class="built_in">document</span>.body.classList.add($.className(<span class="string">'poppicker-active-for-page'</span>));</div><div class="line">	self.panel.classList.add($.className(<span class="string">'active'</span>));</div><div class="line">	<span class="comment">//处理物理返回键</span></div><div class="line">	self.__back = $.back;</div><div class="line">	$.back = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		self.hide();</div><div class="line">	&#125;;</div><div class="line">&#125;,</div><div class="line"><span class="comment">//隐藏</span></div><div class="line">hide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">	<span class="keyword">if</span> (self.disposed) <span class="keyword">return</span>;</div><div class="line">	self.panel.classList.remove($.className(<span class="string">'active'</span>));</div><div class="line">	self.mask.close();</div><div class="line">	<span class="built_in">document</span>.body.classList.remove($.className(<span class="string">'poppicker-active-for-page'</span>));</div><div class="line">	</div><div class="line">	<span class="comment">//增加以下2行</span></div><div class="line">	self.panel.style.display = <span class="string">'none'</span>;</div><div class="line">	self.body.style.display = <span class="string">'none'</span>;</div><div class="line">	</div><div class="line">	<span class="comment">//处理物理返回键</span></div><div class="line">	$.back=self.__back;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="MUI的样式mui-min-css与微信的weui-min-css冲突"><a href="#MUI的样式mui-min-css与微信的weui-min-css冲突" class="headerlink" title="MUI的样式mui.min.css与微信的weui.min.css冲突"></a>MUI的样式mui.min.css与微信的weui.min.css冲突</h3><p>因为做的是微信内置网页，所以使用了微信提供的<code>weui.min.css</code>样式，在做picker的时候，需要导入MUI的<code>mui.min.css</code>样式。这样一来<code>weui.min.css</code>里的很多div样式被覆盖了，写好的样式变成一团糟。只能放弃使用<code>mui.min.css</code>。</p>
<p>因为只用了picker，<code>mui.min.css</code>的作用并不多，只有在picker出现时，后面的半透明蒙版。去掉<code>mui.min.css</code>后，这层蒙版便不再出现了。这个问题还是挺大的，影响交互，picker显示时，还可以编辑输入框。</p>
<p>阅遍<code>mui.min.css</code>终于找到这层蒙版的样式控制，把下面这段css代码拿出来，放到自定义的css样式内即可。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.mui-backdrop</span> &#123;</div><div class="line">	<span class="attribute">position</span>: fixed;</div><div class="line">	<span class="attribute">z-index</span>: <span class="number">998</span>;</div><div class="line">	<span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">	<span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">	<span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">	<span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">	<span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0, 0, 0, .3)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="iOS第三方输入法遮盖输入框"><a href="#iOS第三方输入法遮盖输入框" class="headerlink" title="iOS第三方输入法遮盖输入框"></a>iOS第三方输入法遮盖输入框</h2><p>这是一个非常头疼的问题，之前一直没有发现，因为我根本不用第三方输入法。iOS原生输入法已经很强大了，搞不懂为什么还有人用搜狗百度之流的垃圾输入法，难道仅仅为了皮肤吗？Too naive。</p>
<p>即使用其他输入法，按顺序点击输入框，或者点击网页内弹出的软键盘上面自带工具条上的左右箭头键，切换输入框，这样操作也不会出现输入法遮盖输入框问题。而且这个问题在Android上也不存在。</p>
<p>唯独，一上来就点击页面底下的输入框，第三方输入法弹出缓慢，页面偏移距离计算错误，出现了输入法遮盖输入框的问题。好多网页出现这种问题，比如：各大门户网站的登录界面。</p>
<p>解决办法有点low，但还是比较完美的解决了这个bug，定义js方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">	SCROLLY = <span class="number">300</span>;</div><div class="line">	TIMER_NAME = <span class="number">200</span>;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">textfocusClick</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">			<span class="keyword">if</span>(<span class="built_in">window</span>.scrollY &lt; SCROLLY) &#123;</div><div class="line">				<span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">400</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;, TIMER_NAME)</div><div class="line">	&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>会被输入法遮盖的输入框调用方法:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"userNameInput"</span> <span class="attr">onclick</span>=<span class="string">"textfocusClick()"</span> <span class="attr">placeholder</span>=<span class="string">"请输入"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>定义的js方法，第三方输入法弹出时window.scrollY的值小于系统输入法弹出的，我大致试验出一个300的值(网络上给出的100等小值根本不行)。如果小于这个值就说明是第三方输入法首次弹出，要偏移页面<code>window.scrollTo(0, 400);</code>，偏移的数值根据需要设定。输入法本身就弹出了，再切换输入框，window.scrollY值会和系统输入法的一样，不会小于SCROLLY，所以不能偏移页面。因为网页会自动偏移，再进行代码偏移，会出现页面闪动。</p>
<p>输入框添加的是<code>onclick</code>点击事件，只有在点击输入框获取焦点的时候才调用，在用工具条上的切换按钮切换输入框焦点时不会调用。</p>
<h2 id="警示框的悬浮显示"><a href="#警示框的悬浮显示" class="headerlink" title="警示框的悬浮显示"></a>警示框的悬浮显示</h2><p>警示框不固定在页面上，不随页面滑动而滑动，要求悬浮在导航条下面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">	<span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</div><div class="line">		<span class="keyword">var</span> t = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</div><div class="line">		box.style.top = t + <span class="string">"px"</span>;</div><div class="line">	&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>设置警示框div的id为<code>box</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position:absolute;width: 100%;height: 45px; left: 0px;"</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="placeholder样式"><a href="#placeholder样式" class="headerlink" title="placeholder样式"></a>placeholder样式</h2><p>自定义输入框placeholder的文字样式，包括字号大小，字体颜色等，css样式如下。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* all */</span></div><div class="line"><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123;<span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="attribute">padding-top</span>: <span class="number">2px</span>;&#125;</div><div class="line"><span class="selector-pseudo">::-moz-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125;  <span class="selector-tag">firefox</span> 19+ </div><div class="line"><span class="selector-pseudo">:-ms-input-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125; <span class="comment">/* ie */</span></div><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:-moz-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125;</div><div class="line"></div><div class="line"><span class="comment">/* individual: webkit */</span></div><div class="line"><span class="selector-id">#field2</span><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#00f</span>; &#125;</div><div class="line"><span class="selector-id">#field3</span><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#090</span>; <span class="attribute">background</span>:lightgreen; <span class="attribute">text-transform</span>:uppercase; &#125;</div><div class="line"><span class="selector-id">#field4</span><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123; <span class="attribute">font-style</span>:italic; <span class="attribute">text-decoration</span>:overline; <span class="attribute">letter-spacing</span>:<span class="number">3px</span>; <span class="attribute">color</span>:<span class="number">#999</span>; &#125;</div><div class="line"></div><div class="line"><span class="comment">/* individual: mozilla */</span></div><div class="line"><span class="selector-id">#field2</span><span class="selector-pseudo">::-moz-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#00f</span>; &#125;</div><div class="line"><span class="selector-id">#field3</span><span class="selector-pseudo">::-moz-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#090</span>; <span class="attribute">background</span>:lightgreen; <span class="attribute">text-transform</span>:uppercase; &#125;</div><div class="line"><span class="selector-id">#field4</span><span class="selector-pseudo">::-moz-placeholder</span> &#123; <span class="attribute">font-style</span>:italic; <span class="attribute">text-decoration</span>:overline; <span class="attribute">letter-spacing</span>:<span class="number">3px</span>; <span class="attribute">color</span>:<span class="number">#999</span>; &#125;</div></pre></td></tr></table></figure>
<h2 id="正则使用"><a href="#正则使用" class="headerlink" title="正则使用"></a>正则使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myreg = <span class="regexp">/^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(17[0-9]&#123;1&#125;)|(18[0-9]&#123;1&#125;))+\d&#123;8&#125;)$/</span>;</div><div class="line"><span class="keyword">if</span>(myreg.test(phoneNumText)) &#123;</div><div class="line">	alert(<span class="string">"手机号正确"</span>)；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作需要，用HTML5写一个微信的内置网页，是一个参会报名流程。上次写html还是上学时交作业，现在着实有些手忙脚乱了，现学现用、磕磕绊绊，项目总算告一段落，到了要总结一下的时候了。简单记录了做这个项目时所遇到的问题，有些问题在网上能搜到解决办法，有些问题是为了实现效果耍的小聪明。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5" scheme="http://markmiao.com/categories/HTML5/"/>
    
    
      <category term="HTML5" scheme="http://markmiao.com/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>记四天的香港旅程</title>
    <link href="http://markmiao.com/2016/11/22/%E8%AE%B0%E5%9B%9B%E5%A4%A9%E7%9A%84%E9%A6%99%E6%B8%AF%E6%97%85%E7%A8%8B/"/>
    <id>http://markmiao.com/2016/11/22/记四天的香港旅程/</id>
    <published>2016-11-22T08:00:57.000Z</published>
    <updated>2016-11-27T05:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前在豆瓣发过此文，但总感觉时间匆匆过于潦草，想再改改。一拖一个多月过去了，即时游记拖成了回忆录，我怕再过些日子，回忆录就忘的只剩目录了。</p>
<p>读万卷书的意志已消磨光了，行万里路的兴趣慢慢燃起来了。以前讨厌旅游，现在也想有时间多出去玩玩，毕竟还是个爱玩的宝宝。本文记录了我和晓为期四天的香港旅行，这一次不再是文长无图，谨慎入坑。而是图文并茂，欢迎阅读。</p>
<a id="more"></a>
<h2 id="起程，香港"><a href="#起程，香港" class="headerlink" title="起程，香港"></a>起程，香港</h2><p><img src="/img/WechatIMG171.jpeg" alt="香港维多利亚港"></p>
<p>香港，在我印象里只存在于电视电影，好像是个虚构出来的地方，就像“从前有座山”里的那座山。</p>
<p>当听晓说要去香港的时候，我第一反应是拒绝的。我已经过了那个青春热血的古惑仔年纪，为啥要去香港？在我印象中香港最著名的是铜锣湾，铜锣湾最牛逼的是扛把子浩南哥，充满了刀光剑影，弥漫着青春期荷尔蒙。我已步入90后空巢老人的行列了，哪经得起年轻人的折腾。</p>
<p>晓用眼神告诉我香港势在必行，我的一切反对理论都是荒谬且不靠谱的。好！去！反对的理论是荒谬的，赞成的回答是睿智的。现在知道作为一个程序猿是怎么交到女朋友的了吧？！</p>
<p>既然决定去了，做攻略，买机票，订酒店一系列的事接踵而至。乱七八糟的事都是第一次弄，我这磨磨蹭蹭的性格不可避免的产生了诸多麻烦。不过现在也总算是顺利坐上了从北京西站开往深圳的火车，开始了第一篇游记。</p>
<p><img src="/img/WechatIMG188.jpeg" alt="18:42去北京西站的地铁换乘路上"></p>
<p>都说性格决定命运，看来我是充满坎坷的命运。我总是天真的认为车到山前必有路，船到桥头自然直。一切有所布局，便能水到渠成。却不想水到了，渠还没成，一浪拍在了沙滩上。这就是空有决胜千里之外的愿望，没有运筹帷幄之中的能力。</p>
<p>机票一定要提前订，提前订，提前订，重要的事情说三遍。临近起程的日子机票打折的几率太小了，除非人品爆棚，折扣大概能接受就订。我就是吃了磨叽的亏，临近出发前一周，发现机票涨价了。这时买当然不甘心了，但他娘的谁知道往后他是涨是降啊，不会要含着热泪买高价票吧？权衡再三买了到深圳的动车卧铺票。虽然要在火车上睡一晚上，但是时间上来说会比坐飞机好点。</p>
<p>之所以到深圳是因为我不争气的家乡，港澳通只能L签，进香港只能跟团。所以要到深圳找旅游团开过关单子，然后才能过海关进港。过关服务淘宝一搜一大把，5块钱搞定。</p>
<p>买回程机票时也经历价格波动的调戏，我中午看票还3.1折，下午准备买的时候就变成5折了。我当时十分清楚地感觉到了晓眼中的杀气，我也追悔莫及为啥中午不买！可喜的是第二天回到了3.1折，立刻买了！竟然有种得了便宜的窃喜感。</p>
<p>除了被机票折磨，就是被手机卡摧残。淘宝了一张香港四天无限4G卡，提前五天买的，当天下午就发货了，快递信息在第二天更新完停留了四天，手机卡从深圳发出后失联了！出发前一天和卖家交涉，卖家给的答复是最近寄往北京的件都慢。我也是悲催，赶上了。出发当天和卖家打了一早上嘴仗，快递信息总算更新了，手机卡也总算拿到了。</p>
<p>临了临了，晚节不保，临上动车前还被ATM机调戏了一把。候车室里破旧的ATM机，我真怕它吃我卡。我的担心倒是没发生，但也让我心惊肉跳了一把。插了卡，输了密码，输了取款金额，手机收到扣款信息……然后就是漫长的等待，我估计等了大概两分钟，屏幕突然煞白，出现了操作失败请联系发卡行的字样。完犊子了，扣了钱，钱没出来，MLG……脏话还没骂完，银行卡被吐出来了，手机上收到了入款信息。吓得我赶紧换了一个ATM机。</p>
<p>现在回想起来，好像没什么开心的事。唯一开心的事就是晓现在心情不错，所以我也很开心。希望我们这次香港之旅玩的快乐，我的游记写的有趣。</p>
<p><img src="/img/WechatIMG172.jpeg" alt="北京西站进站前的雾霾天"></p>
<h2 id="过关，入港"><a href="#过关，入港" class="headerlink" title="过关，入港"></a>过关，入港</h2><p>迷迷瞪瞪睡了一夜，早上7点25到深圳北站。从窗外望去，满眼翠绿，偶尔闪过的那种热带地区才有的大叶树让我们觉得新鲜。</p>
<p>下动车后，晓拉着我说：你看你看，那都有树。我看了一眼说：你要淡定，要装作经常来的样子，别整的跟山炮进城似的。晓心情好，白瞪了我一眼，嘟囔了一句：你才山炮呢。</p>
<p>在深圳北站逗留了很短的时间，坐地铁赶到福田口岸，拿了5块钱买的入关团签表，排队过关。排队的人不是很多，相比较北京工作日早高峰地铁排队情况来说。过关很容易，出示港澳通和团签表，海关看都没看我一眼，戳了个印就过了。出了中国海关，入香港海关，流程一样，第二次连团签表都不看了。</p>
<p><img src="/img/WechatIMG173.jpeg" alt="中国海关"></p>
<p>从福田口岸的落马洲站到尖沙咀，坐港铁40港币！100块可用额度的八达通一下扣款近一半，有点蒙圈，顿时感觉北京地铁真良心，即使涨价后也还是良心的有些可爱。</p>
<p>还发现香港地铁是没有安检的，我一直不认为北京地铁安检能检出什么危险物品，倒是对限流和秩序维持起到了很大的作用，毕竟中国人多而且大家都忙，限流和秩序很有必要。</p>
<p>第一天没去远的地方逛。吃了顿茶餐厅和麦当劳，去了趟维多利亚港和海港城。</p>
<p>香港茶餐厅挺出名的，之前一直听说，这次有机会试一试了。食物偏西式，甜腻甜腻的，吃一点就有点腻。然后两个人两份煲仔饭外加六个翅中，风卷残云后，就剩骨头了，看来再腻的饭饿疯了也能吃下去。</p>
<p><img src="/img/WechatIMG175.jpeg" alt="在茶餐厅风卷残云的吃了一顿"></p>
<p>下午实在没找到啥好吃的，就去吃麦当劳了。无意中看到麦当劳的招聘广告，服务员月薪10000港币，合人民币8600多。在香港当服务员至少要会三门语言：粤语、 英语、普通话。去好多店里，服务员打招呼都是：雷吼啊、hello、你好。看你说什么话，再以相同的话接待你。我想说：哎呀大妹子，你这有秋裤不？会不会给服务员干懵逼了。</p>
<p>原计划第一站是星光大道，我想去看看李小龙的雕像。星光大道就在维多利亚港旁边，我们住在尖沙咀，走到维多利亚港也就十多分钟的路程。</p>
<p><img src="/img/WechatIMG176.jpeg" alt="去维多利亚港的路上"></p>
<p>我们在维多利亚港周围顶着烈日转了半个多小时，被晒成傻逼了，还是没找到星光大道。我找到一位看起来和蔼可亲的大爷，问他星光大道怎么走？就是有李小龙雕像那个，说着还拉了一个架势。大爷呲着大牙一笑，操着一口粤语普通话说：一年前就关啦！我有些懵逼，啥玩意？大爷又重复了一遍：去年就关啦，在装修，三年后开放，现在进不去啦！我勒个去，大陆消息封锁太严密了吧，网上没人说星光大道关张大吉了啊！</p>
<p>星光大道没见到，转身去了海港城。听说这里是香港最大的购物商城，里面应有尽有，别管男女老少肯定有你中意的东西。事实是没骗我，每一件我都中意，就是买不起。我问晓：这都是啥牌子？晓说：轻奢品牌。我说：这才轻奢呢？重奢不得死去！晓又白瞪了我一眼，嘟囔了一句：山炮。语气我听出来了，这次不是娇嗔，是真在骂我。</p>
<p><img src="/img/WechatIMG177.jpeg" alt="海港城外的海港"></p>
<p>我的消费层次一直很low逼，以前是地摊货，现在是商城，去逛高端点的商城，比如西单大悦城，我还是有点自惭形秽。逛海港城，真感觉像山炮进城。我就是那种别人在炫富我都看不出来的人。努力装作经常来的样子，转角看到了一个熟悉的品牌H&amp;M，立马有种亲切感，像是low逼的品味有地儿接住了。重申不是说H&amp;M品牌low，意思是H&amp;M大众亲民，品牌知名度广。</p>
<p>维多利亚港的景色还是挺美的，特别是夜景。灯火璀璨映照着海面，真有点影视剧里的感觉。坐游轮，欣赏夜景，浑身没有半两品味的我也感觉到了好惬意啊！潮湿的海风，晴朗的夜空，三三两两的外国人席地而坐，好多游人在拍夜景，还时不时有一群海鸥飞过，这才叫生活嘛。</p>
<p><img src="/img/WechatIMG178.jpeg" alt="维多利亚港夜景"></p>
<p>坐天星小轮去中环码头，那里有个湾仔码头可以吃水饺（开玩笑了，提起湾仔码头第一反应就是水饺）。来香港一定要乘坐一次天星小轮，两元港币横渡维多利亚港。夜色下海水有种很深邃的感觉，我问晓：这里有鲨鱼吗？晓说：没有，你跳船游过去吧。我说：我怕被人当成海怪打死。</p>
<p><img src="/img/WechatIMG179.jpeg" alt="乘坐天星小轮"></p>
<p>之前也听说维多利亚港晚上8点有盛大的烟花表演，事实呢？好多年都没有了。虽然有些遗憾，但是夜景还是让我们满足。</p>
<p>香港，毕竟还是离我们很远。说只有影视剧的印象是有些夸张，但真实的香港与在大陆的所见所闻还是有些差距的。</p>
<h2 id="海洋公园，蜡像馆"><a href="#海洋公园，蜡像馆" class="headerlink" title="海洋公园，蜡像馆"></a>海洋公园，蜡像馆</h2><p>来香港的第二天，去海洋公园和杜莎夫人蜡像馆。万圣节主题的海洋公园还是挺有趣的，在山上的蜡像馆还是挺折腾人的。</p>
<p><img src="/img/WechatIMG189.jpeg" alt="俯视海洋公园的游乐场"></p>
<p>海洋公园十点开门，之前查过攻略，不过临行前忘记了。早早坐港铁到金钟站，坐海洋公园巴士赶到海洋馆，提前了半个多小时。其实还是提前点好，人少，玩什么看什么基本都不用排队，下午三点多就差不多玩完了，出园的时候看到有好多人都在排队，那种感觉——爽！</p>
<p>相比较大陆的景区，香港海洋公园的通票通的非常彻底，园内的任何娱乐设施，任何展馆，任何场地，包括万圣节节日主题表演场馆都可以进去，没有额外费用，也没有人查票。晓说：除了吃的。这可以理解，毕竟不是自助餐式海洋公园。其实也可以说这是总价票，所有娱乐费用都缴过了，玩不玩当然没人管你。</p>
<p>游玩的顺序有些失策，初进海洋公园，我俩有些控记不住几己，见了啥都想上去玩一番，上来就玩了个大转盘，脑浆子都快被从耳朵眼里甩出去了。以至于晓一直有些头晕不适，加上10月份的香港还是艳阳高照仲夏时节，我俩脑袋都有些晕晕乎乎，碰上其他的刺激娱乐都有些望而却步。</p>
<p><img src="/img/WechatIMG190.jpeg" alt="差点甩吐了的大转盘"></p>
<p>海洋公园感觉娱乐设施比海洋动物多，过山车、魔天轮、太阳神车……我说：连个海龟都没有，为啥叫海洋公园，叫香港欢乐谷得了。现在回想起来，倒是真没看见海龟哎。玩大转盘把晓的脑水给咣当的活了浆糊，玩过山车时晓本打算不上了，工作人员说：这个很平稳不晃，不会晕的。然后就脑子就彻底成糊糊了，后来的“翻天覆地”我一个人上了，然后我也糊糊了。</p>
<p><img src="/img/WechatIMG191.jpeg" alt="我在上面，差点吐了整个海洋公园"></p>
<p>其实这些刺激娱乐还好，无一例外的把我们晃晕了。后来的海洋列车，虽然没晕，但是失望啊。一辆像是装了甲的火车，我们俩一致认为这个会进入海底隧道，透过如同游轮上的圆形玻璃窗能看到幽蓝深邃的海底世界。列车开动了，我俩激动的像是看见狗粮的榴莲（榴莲是我家养的一只金毛），我们还一直担心一会儿会不会有大乌贼撞到窗户上来。车里灯光闪烁，音乐环绕，头顶上一块一块屏幕放映着海底影像，我说：这气氛渲染的还蛮不错的。时间一分一秒的过去，窗户外面不但没有蓝色的海洋，连萤火虫屁股大的光都没有。我好像意识到：这灯光音乐和头顶的屏幕不是气氛渲染，这就是该项目的正主。不一会儿，窗户亮了，到站了！什么破烂玩意儿，坐地铁看了集动物世界预告片。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="/img/WechatIMG192.jpeg" alt="启动前的海洋列车"></th>
<th style="text-align:center"><img src="/img/WechatIMG193.jpeg" alt="启动起来的海洋列车"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>万圣节快要到了，海洋公园开了好多万圣节主题场馆，有各种鬼屋。我进了一间校园鬼屋，说真的还真有点阴森恐怖感，阴森的环境布置，妖异的背景音乐，灰暗的灯光，时不时的惨叫声……有点要被吓尿了的感觉。我一直在提醒自己这是假的，微笑着向各个扮演鬼怪的工作人员打招呼，他们看着我微笑，也就不一惊一乍的吓我了，还会扭曲身体跳舞给我看。何况入场馆的时候，人也跟我说了：善待工作人员，不要殴打他们。所以我要微笑。</p>
<p><img src="/img/WechatIMG194.jpeg" alt="华为赞助的照妖宫殿"></p>
<p>海洋公园当然也是有海洋动物的，海狮、海豚、鲨鱼、企鹅、北极狐等等，我们一个馆一个馆的转，一会冷，一会热，动物们都自由自在的享受着美食，真不知道是人度假来看动物，还是来受罪给动物看的。</p>
<p>有几个时间段有海豚表演，海豚真的特别聪明，做各种弹跳动作，做完一系列动作才去问饲养员要吃的。不像我家榴莲，拿着零食叫它坐，它会在坐下的同时冷不丁的一口抢走你手中的零食。这就是聪明到能上舞台的动物明星和一个蠢萌到把心眼全都用到吃上的饭桶狗的差别，其实我还是喜欢饭桶狗。</p>
<p><img src="/img/WechatIMG195.jpeg" alt="等着看海豚表演的观众席"></p>
<p>出场馆的时候看到好多cosplay万圣节主题人物的，吸血鬼、女巫、河童……我去和一个女巫合影，晓给拍照，晓说：你亲她。我还没嘟嘴亲呢，女巫说：真的不能亲吆，假装可以。我心想：你这一脸的白粉，假装我也假装不来啊。准备拍的时候，一只吸血鬼闪过来凑热闹，又快速的闪跑了，不知做了什么表情，周围的人一阵嬉笑，只可惜没拍到。</p>
<p><img src="/img/WechatIMG196.jpeg" alt="和我打招呼的河童"></p>
<p>从海洋公园出来，去杜莎夫人蜡像馆。蜡像馆在山顶，那个巴士站就叫山顶。从金钟站坐15路巴士，走过好多盘山道，才到山顶。这是一个像大商场的地方，有好几栋商场大厦。我们来回找了好一阵也没看到蜡像馆，反而看到了好多狗狗，广场上，室外餐厅里都有各种狗。晓倒是挺兴奋的，到处跟狗打招呼。我只能跟人打招呼去问蜡像馆在哪里，一问才知道，在其中一个商场的地下。</p>
<p><img src="/img/WechatIMG197.jpeg" alt="在杜莎夫人蜡像馆处俯视香港"></p>
<p>我是在大众点评上买的票，票据兑换证明以邮件形式发过来的，这个证明必须打印出来，然后去兑换入场门票。在蜡像馆所在大厦的对面大厦有个ePhone店，那里可以打印。价格不菲，建议提前打印好。</p>
<p>几经折腾终于进蜡像馆了，其实我所期待的小龙哥死亡游戏里一身黄衣的经典造型就在场馆外，不用买票就可以拍照合影。</p>
<p><img src="/img/WechatIMG198.jpeg" alt="在场馆门口的小龙哥"></p>
<p>蜡像馆里有各种人物蜡像，古今中外、各国明星、政客领袖、影视人物等等，反正种类是挺多的。去蜡像馆就是合影，是所有游客共同的目的。热门人物身边会一个接一个的有人和他过去合照，冷门人物就得不到游客的垂怜。比如古天乐、吴彦祖身边都排着队照相，曾志伟身边就寥寥无几。每个照相的都摆尽姿势，各种猥琐恶搞，挎胳膊搂肩算正常的，更甚者掏裆袭胸摸大腿。绝大多数蜡像都不限制拍照，也不限制抚摸，只有一少部分拍照是需要花钱的，比如习总书记的。开心的是还有漫威里的钢铁侠、金刚狼、绿巨人，简直惟妙惟肖，终于近距离袭了钢铁侠的胸，摸了金刚狼的爪，捅了绿巨人的嘴。哈哈哈~~</p>
<p><img src="/img/WechatIMG199.jpeg" alt="你们喜欢的哥哥"></p>
<p>有些失望的是蜡像馆竟然没有万圣节主题，按说相比较海洋公园，蜡像馆才更适合弄一些惊悚恐怖元素。比如棺材里的僵尸蜡像、闸刀下的断头饿鬼、真人扮演蜡像吓唬游客……还是很有万圣节恶趣味的。估计是短时间内难以做出品质很高的蜡像，游览快结束的时候，有视频演示蜡像制作过程，甄子丹奉献出自己的老脸取模型，然后再做蜡像，看起来挺高端的。</p>
<p>从蜡像馆回去的时候差不多六点了。路过铜锣湾，去逛了一下崇光百货。晓美其名曰的要帮同事带口红，然后同事没要，她自己买了一管口红一盒粉。谁告诉我香港化妆品便宜的？出来跟我下个月一起啃馒头聊人生。</p>
<h2 id="铜锣湾，迪士尼"><a href="#铜锣湾，迪士尼" class="headerlink" title="铜锣湾，迪士尼"></a>铜锣湾，迪士尼</h2><p>昨天去海洋公园去早了，今天打算晚点去迪士尼。先去趟铜锣湾逛逛街，昨晚的确没逛尽兴。相比较昨天的不尽兴，今天迪士尼之行不是不尽兴，而是败兴。乘兴而来，败兴而归。</p>
<p>早上去铜锣湾吃饭，铜锣湾出名的不仅有陈浩南，还有购物和美食。前两天见识到了香港人早上起的晚，绝大多数店面十点以后开门，更有甚者十二点一点开门。今天出门已经比较晚了，对于几日游的游客来说，晚出门简直就是对时间最罪恶的浪费。刻意晚点出门还是有点早，即便是周一工作日香港还是醒的很晚。</p>
<p>去铜锣湾的一栋大厦吃早餐，去了一家营业了的早茶餐厅。一进门服务员问我俩：两位喝什么茶？我说：不喝茶吃饭。晓说：早茶馆，得喝茶。哦，我又山炮了。一壶大麦茶，几种面食有叉烧包、烧卖、小笼包、饺子，外加一碗白粥，白粥是咸的，但味道还挺好。面食里只有饺子的味道有些符合北方人口味，其他的还都是偏甜偏腻。</p>
<p><img src="/img/WechatIMG200.jpeg" alt="早茶餐厅里的虾仁烧麦，虾真的好多"></p>
<p>在等上菜的时候，晓发现了一个问题：整个早茶餐厅用餐的全部都是老人，甚至服务员也都是老人，刚刚问我们喝什么茶的是个领班，看样子也有五十多岁了，在这里面算年轻人了。给我们端粥的老人有六七十岁了，颤颤巍巍，我怕她一个托不住把粥浇我头上。难道这是老年餐厅？还是在香港只有老年人有闲情逸致去早早的喝早茶，年轻人要么上班要么睡觉？</p>
<p>迪士尼，坐城铁就可以到，很方便。有一条迪士尼专线，列车设计就是迪士尼风格。去了迪士尼才让我真正领略到了什么是身处童话世界，各种动画里的音乐场景人物，不单单是人穿着皮套扮演那么简单。迪士尼真的挺适合带着孩子一起来，孩子丰富的想象力，只有迪士尼能让他的想象变为现实。</p>
<p><img src="/img/WechatIMG202.jpeg" alt="迪士尼大门前"></p>
<p><img src="/img/WechatIMG203.jpeg" alt="迪士尼的标志米老鼠"></p>
<p>先去看的人猿泰山，人猿泰山的树屋在一个岛上，需要坐木筏子过去。大树上是泰山的家，我看见人猿泰山里的大花豹，走过去时突然一声豹吼吓了我们俩一跳，豹子是动画里的样子，周围环境也完全和动画里一样，氛围太逼真，以至于听到那声豹吼时以为豹子会突然扑过来。</p>
<p><img src="/img/WechatIMG204.jpeg" alt="人猿泰山里的大花豹"></p>
<p>迷离山庄是香港迪士尼全球独有的主题园区，传说是亨利爵士与他的助手小猴子阿拔游历世界，收集了各种奇珍异宝，保存在迷离大宅里。我们一起坐游览车游览迷离大宅，在小猴子的带领下，简直就是进入了博物馆奇妙夜。一条金光闪闪的龙忽然活了，仰头吐出一串星光，星光飘过，迷离大宅里的藏品仿佛活了一样，眼前的雕像在唱歌，壁画在说话，钢琴会自己弹奏，大炮会发射炮弹，冰冷的寒风刮起冰雪世界，食人花向我们张开大口，木乃伊在裹尸布里扭动，尸鳖爬了出来……一切都太真实了，视觉，听觉，触觉，嗅觉全方位能感知到周围的奇幻世界。我们根本无暇去拍照，被眼前的景象惊呆了，有原始人拉满弓向我们射箭，箭仿佛擦过我们的脸颊，把小猴子钉在墙上了；壁画上一个美丽的少女在唱歌，突然满头金发变成一条条的蛇，少女变成了一个蛇妖；冷风吹过，把周围的世界都冰封了起来，看到镜子里的自己也被冰封住了。</p>
<p><img src="/img/WechatIMG205.jpeg" alt="迷离大宅里的藏品"></p>
<p><img src="/img/WechatIMG206.jpeg" alt="开启梦幻之旅的小猴子阿拔"></p>
<p>还有坐过山车穿过的灰熊山谷，各种王子与公主故事的梦想花园，小熊维尼历险之旅，玩具总动员，明日世界星球大战，反斗奇兵，蒸汽火车，烟花表演，万圣节主题……还有好多游行表演。</p>
<p>但是我们看的玩的不过五分之一，因为天下雨了。外景场馆全部停止游玩，一场雨扫了所有兴致。</p>
<p><img src="/img/WechatIMG207.jpeg" alt="已经停止运行的旋转木马"></p>
<p>强烈建议计划去玩的朋友们把迪士尼之旅安排在前几天，一定要看好天气！千万别有雨有台风的时候去。一张票在七天工作日内可进去两次，一次玩不尽兴的可以再去一次。我们就是吃了天气与时间的亏，不但天公不作美，也没有时间再去一次了。</p>
<p>从迪士尼败兴而归，又回到铜锣湾。这次去了希慎广场，这里有全香港最大的Apple Store，我爱吃苹果，晓爱玩iPhone，然而并没有什么卵用，Apple Store不卖苹果，也没有iPhone7 Plus。还有占据三层楼的诚品书店，也没有什么卵用，我们已经变的只爱看手机不爱看书了。</p>
<p>然后我们频繁出入化妆品、服装、包包店，这是我们共同的兴趣爱好，至少我的游记里是这么写的。毕竟我只是游记编辑，还有审稿呢。我们快快乐乐的挑选着各种口红、各种霜、各种服装、各种包。我也是从旁给予十分中肯的评价意见：“恩，好看，好，不错……挺配你的……”。</p>
<h2 id="回程，最后的告别"><a href="#回程，最后的告别" class="headerlink" title="回程，最后的告别"></a>回程，最后的告别</h2><p>来香港的第四天，疲惫已经超过了兴奋。所以建议把重头戏安排在前两天，因为最后的时候，人也累了，兴趣也少了。</p>
<p><img src="/img/WechatIMG209.jpeg" alt="离港时的雨天"></p>
<p>原计划是要去一次南丫岛，由于时间距离天气等原因取消了。最后一天还是去逛街了，去了东涌站的东荟城名店仓，感受了一把“商场野餐”。去了机场免税店，狠狠的买了几大包吃的。</p>
<p>在香港的最后一天还在下雨，计划的行程也大部分完成。下午就要回北京了，剩余的时间说多不多，说少不少。也没什么特别想去的地方，索性不再折腾了。收拾好东西打算直接去机场，临走前逛逛机场免税店。</p>
<p>在去机场的港铁上改了主意，打算去一趟东涌站，那边有东荟城和奥特莱斯，都是折扣商场。好吧，还是逛街购物，反正到哪都是逛吃逛吃逛吃……</p>
<p>这次在东荟城逛倒是没逛出什么名堂，吃可是吃的尴尬到了天际。事情是这样的，逛商场时看到有卖快餐的。平时吃快餐吃的都快吐了，但这几天吃的满肚子油腻，都吃出便秘了，看见快餐有种他乡遇故知的感觉。</p>
<p>我们俩一人打包了一份，量还很大。买完之后发现没地方吃，记得商场里有个麦当劳，想去那里找个地方吃。辗转找到麦当劳，队排的跟北京地铁里似的，一个位置都没有，而且人都是在吃汉堡薯条，我俩坐下哼哧哼哧的吃盒饭也不合适啊。我双手托着两盒快餐外加一盒水果，和晓四目相对懵逼的杵在商场里。</p>
<p>杵在那里总不是个事，打算去拿行李去机场再吃。行李寄存在地下二层，那是一个僻静的停车场。盒饭有汤有水也不好带，我看四周没啥人，建议就在这野餐得了，铺了张纸席地而坐吃起来了。</p>
<p>偶尔下来一两个人，我俩感觉尴尬的要死。仗着人生地不熟，谁也不认识谁，索性甩开腮帮子，撩开后槽牙吃吧！这时下来四五个大学生，看到我们在吃饭就乐了，是那种尴尬的乐。啥情况？我还没缓过尴尬的劲，她们就在另一个角上也坐下吃东西！好吧，同是天涯沦落人，就看谁能尬过谁。她们人多明显占优势，有说有笑的，我俩就尴尬了。我脸皮厚还好点，晓已经尴尬的吃不下了，我大概扒拉了几口，拿了行李赶紧走了，“商场野餐”也算是完美落幕。</p>
<p><img src="/img/WechatIMG210.jpeg" alt="香港机场"></p>
<p>到了机场，办理登机手续，退八达通。剩了七八百港币，本打算兑换成人民币，可是机场兑换点汇率太低，100元港币只能兑换82元人民币。就没有兑换，然后就都花了，都花了，花了……</p>
<p>机场免税店的东西挺多，也不算贵，我俩帮朋友带，买了自己吃，啥也想尝尝，最后买了两大包，最终没有辜负作为两个吃货的尊严。进机场安检的时候，安检人员指着一个图片问：有这款手机吗？我一看是三星note7，连忙摇头说没有！看来note7不能上飞机不是传言。</p>
<p>登机前，外面还在下雨。在香港待了四天，两天半好天，一天半下雨。计划的行程也差不多完成了：</p>
<ol>
<li><p>星光大道，封闭装修没去成功，没见到小龙哥的雕像，没见到明星们的手印，失败。</p>
</li>
<li><p>维多利亚海港，欣赏了夜景，但是没看到烟花，多少年前就没有了。</p>
</li>
<li><p>坐天星小轮，两元港币横渡维多利亚港，欣赏海岸线上香港大厦灯光璀璨，最值最赞的香港旅游体验。</p>
</li>
<li><p>海洋公园，玩的刺激，看的精彩。重点是没怎么排队，虽有小遗憾但也很值了。</p>
</li>
<li><p>杜莎夫人蜡像馆，虽然路途很辗转，但最终看到的蜡像也是蛮不错的。</p>
</li>
<li><p>铜锣湾，购物很丰富，美食也很多。既需要时间慢慢去发掘，又需要钱去支持发掘。</p>
</li>
<li><p>迪士尼，真正的童话世界。一场雨留下了太多遗憾，我从未如此讨厌过下雨。会有弥补遗憾的那一天。</p>
</li>
<li><p>海港城，轻奢品牌商场，应有尽有，总有你中意的一款，购物者的天堂，钞票的焚烧炉。</p>
</li>
<li><p>东荟城，折扣商城，各种品牌折扣。有时间逛的话肯定能淘换到实惠的好东西。</p>
</li>
<li><p>免税店，国际机场都会有免税店。会有一些特产和吸引人的品牌，而且价格也不贵，不买一些会感觉不甘心。</p>
</li>
</ol>
<p>坐上回北京的飞机，时间过的好快。四天香港之旅结束了，这是我第一次出大陆，虽然有各种遗憾（好像每次旅行，都会有遗憾），但总归还是一次不错的旅行。流水账式的记录下这次旅行，也算给以后的回忆留一个依据吧。上天貌似感觉我们这趟旅程还不够坎坷，最后还加了个彩蛋，下飞机打车回家，大半夜的赶上北五环查车，几十辆大卡车被查了，堵车堵了一个多小时，到家都快凌晨了。进家门的那一刻，我们俩对视了一下，不由得苦笑，简直是身心俱疲……</p>
<h2 id="附，个人攻略"><a href="#附，个人攻略" class="headerlink" title="附，个人攻略"></a>附，个人攻略</h2><p>看到这里的要么是真爱，要么是无聊。附上一些个人攻略，希望对要去香港的朋友们有一点点帮助。</p>
<ol>
<li><p>L签的旅客不能直接进港，从深圳过海关，可以在淘宝上买相应口岸的过关服务，在过关前拿单子过关即可，好用还不贵。回来的时候可以从香港直飞即可。</p>
</li>
<li><p>最好提前兑换港币，过关时兑换得排队，汇率差别也很大。国内各大银行差不多都可兑换，需要提前预约。预约好也可以兑换小面值港币，并不是只能兑换1千面值。即便是1千面值也可在香港境内破开，虽然好多店铺不收1千面值的，但充八达通是可以的。</p>
</li>
<li><p>八达通可以在港铁进站时买，不用提前淘宝，使用不超过30天退会有9港币手续费，可以用八达通在各种店面刷卡付款。也有其他的套票卡，比如三天不限次乘坐港铁，包含一次或两次机场线。</p>
</li>
<li><p>淘宝可以买到几天的香港无限流量卡，强烈建议几个人就买几张卡。开热点容易断，信号不好，太麻烦。</p>
</li>
<li><p>记得带英标转接插头，有的酒店里会提供，万一不提供会产生很多不必要的麻烦。</p>
</li>
<li><p>海关其实查的不严，只要证件齐全有效，带台iPhone完全没问题，并不像网上说的那样一台iPhone自用都要报税。你把iPhone拼成铠甲披身上被查也不能怨政府。</p>
</li>
<li><p>在大众点评上可以买迪士尼，海洋公园，蜡像馆的门票，会发一封兑换票据的邮件，迪士尼和海洋公园的邮件不用打印，直接扫码入园，迪士尼如果买餐券的话需要兑换。蜡像馆的邮件必须打印，不然不给你兑票。虽然大众点评上都说的是需要打印。</p>
</li>
<li><p>去机场可以不坐机场线，因为机场线特别贵。可以坐到东涌站，坐机场巴士到机场，几块钱即可搞定。</p>
</li>
<li><p>买水要去大型超市买，会便宜一半，4-5港币一瓶，外面小店以及港铁里的7-Eleven都8-9港币，依云这类神水都20多港币。</p>
</li>
<li><p>旅馆里每天会给你补充到两瓶水，即使喝不完也要藏起来或带出去，不然也不会多给你一瓶。毕竟一瓶水好几块钱呢。（这一条酒店不同可能不一样）</p>
</li>
<li><p>最后一个，香港是靠左边走的。时刻记住靠左边，特别是在港铁站里去坐扶梯的时候，靠右走过去会发现是反方向的扶梯，栏杆隔的很严密，只能退回来再去左边。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在豆瓣发过此文，但总感觉时间匆匆过于潦草，想再改改。一拖一个多月过去了，即时游记拖成了回忆录，我怕再过些日子，回忆录就忘的只剩目录了。&lt;/p&gt;
&lt;p&gt;读万卷书的意志已消磨光了，行万里路的兴趣慢慢燃起来了。以前讨厌旅游，现在也想有时间多出去玩玩，毕竟还是个爱玩的宝宝。本文记录了我和晓为期四天的香港旅行，这一次不再是文长无图，谨慎入坑。而是图文并茂，欢迎阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="记事" scheme="http://markmiao.com/categories/%E8%AE%B0%E4%BA%8B/"/>
    
    
      <category term="生活" scheme="http://markmiao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="游记" scheme="http://markmiao.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>制作.a和.framework静态库</title>
    <link href="http://markmiao.com/2016/11/14/%E5%88%B6%E4%BD%9C-a%E5%92%8C-framework%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <id>http://markmiao.com/2016/11/14/制作-a和-framework静态库/</id>
    <published>2016-11-14T09:21:55.000Z</published>
    <updated>2016-11-27T05:14:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS库一般有开源库，静态库和动态库。</p>
<p>开源库是指源代码开放的功能代码，比如AFNetworking。</p>
<p>静态库是指内部代码逻辑看不到，依靠相应的.h头文件调用内部方法的功能模块。有<code>.a静态库</code>和<code>.framework</code>两种形式。比如：百度导航的<code>libbaiduNaviSDK.a</code>，百度地图<code>BaiduMapAPI_Map.framework</code>。使用时要完全拷贝到工程中，调用。<br><a id="more"></a></p>
<p>动态库同样看不到内部代码逻辑，有<code>.dylib</code>(现在为<code>.tbd</code>)和<code>.framework</code>两种形式。比如常见的<code>libz.tbd</code>和<code>Foundation.framework</code>。由系统动态加载到内存中调用。</p>
<p>系统的<code>.framework</code>是动态库，自己创建的<code>.framework</code>是静态库。</p>
<p>本文中所用到的工程代码详见<a href="https://github.com/mxdios/libXDAttributedTool" target="_blank" rel="external">github地址libXDAttributedTool</a></p>
<p><strong>注意：</strong></p>
<p><strong>苹果禁止开发者在项目中使用自己创建的动态库。</strong></p>
<p><strong>swift无法制作.a静态库，只能创建.framework静态库。因为.a静态库需要.h头文件配合使用。</strong></p>
<h2 id="制作-a静态库"><a href="#制作-a静态库" class="headerlink" title="制作.a静态库"></a>制作.a静态库</h2><p>.a静态库是iOS开发中常用的一种库文件，通常为一些第三方提供的功能模块。</p>
<p>以我写的一个工具方法<a href="https://github.com/mxdios/XDAttributedTool" target="_blank" rel="external">给字符串设置富文本模式</a>为例创建.a静态库</p>
<h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>创建项目，选择iOS -&gt; Framework &amp; Library -&gt; Cocoa Touch Static Library</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160908-0.png?raw=true" alt="创建工程"></p>
<p>将要打包.a静态库的功能代码拖到新建的项目中。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160908-1.png?raw=true" alt="创建工程"></p>
<h3 id="配置工程"><a href="#配置工程" class="headerlink" title="配置工程"></a>配置工程</h3><p>添加要打包.a静态库的代码文件，和添加相对应的.h头文件</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-1.png?raw=true" alt="添加文件"></p>
<p>设置release模式</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-2.png?raw=true" alt="设置release模式"></p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-3.png?raw=true" alt="设置release模式"></p>
<h3 id="编译文件"><a href="#编译文件" class="headerlink" title="编译文件"></a>编译文件</h3><p>真机设备编译，生成真机使用的.a静态库：选择<code>iOS Device</code>设备，<code>command + b</code>编译。编译成功后，<code>.liblibAttributedTool.a</code>由红色变为黑色。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-4.png?raw=true" alt="编译文件"></p>
<p>模拟器编译，生成模拟器使用的.a静态库：选择一个模拟器，<code>.liblibAttributedTool.a</code>会又变为红色，<code>command + b</code>编译。编译成功后，<code>.liblibAttributedTool.a</code>由红色变为黑色。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-4.png?raw=true" alt="编译文件"></p>
<p>这时便生成了两个.a文件，分别用于真机和模拟器</p>
<h3 id="合并-a文件"><a href="#合并-a文件" class="headerlink" title="合并.a文件"></a>合并.a文件</h3><p>选中编译后变黑的<code>liblibAttributedTool.a</code>右键 Show in Finder。<code>Release-iphoneos</code>和<code>Release-iphonesimulator</code>分别为真机和模拟器下生成的静态库文件。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-6.png?raw=true" alt="合并"></p>
<p>打开终端，输入<code>lipo -create</code> <code>空格</code> 拖入模拟器下的静态库.a <code>空格</code> 拖入真机下的静态库.a <code>空格</code> 输入<code>-output</code> <code>空格</code> 输入合并后的.a存放路径/静态库名字 <code>回车</code>。这里演示合并后的名字为<code>libXDAttributedTool.a</code>存放在桌面了，<code>ls</code>显示当前路径下的文件。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-7.png?raw=true" alt="合并"></p>
<p>验证合并后的.a静态库支持的有效架构</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-8.png?raw=true" alt="验证"></p>
<h3 id="使用-a静态库"><a href="#使用-a静态库" class="headerlink" title="使用.a静态库"></a>使用.a静态库</h3><p>将合并后的.a静态库和.h头文件(随便在真机或模拟器生成的库文件夹里选一个即可，或者用原项目中的.h头文件)放到一个文件夹内，拖入工程，导入.h文件即可使用。</p>
<p>项目中的<code>libAttributedTool</code>是打包.a静态库的源文件工程</p>
<p>项目中的<code>XDAttributedTool</code>是打包完成，使用.a静态库的测试工程</p>
<p>开源代码使用请见<a href="https://github.com/mxdios/XDAttributedTool" target="_blank" rel="external">XDAttributedTool</a></p>
<h2 id="制作-framework静态库"><a href="#制作-framework静态库" class="headerlink" title="制作.framework静态库"></a>制作.framework静态库</h2><p>.framework静态库也经常使用，比如百度地图的一系列<code>BaiduMapAPI</code>都是.framework静态库。</p>
<h3 id="创建工程-1"><a href="#创建工程-1" class="headerlink" title="创建工程"></a>创建工程</h3><p>创建项目，选择iOS -&gt; Framework &amp; Library -&gt; Cocoa Touch Framework。这一步跟打包.a静态库类似，跟打包.a时的截图不一样，是因为Xcode升级了。打包.a时用的Xcode7.3，打包.framework用的Xcode8.0，这就是拖坑不填的结果。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-0.png" alt="img"></p>
<p>将要打包的功能代码拖到新建的项目中。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-1.png" alt="img"></p>
<h3 id="配置工程-1"><a href="#配置工程-1" class="headerlink" title="配置工程"></a>配置工程</h3><p>在<code>Build Phases</code>里的<code>Headers</code>，把需要暴露在外面的.h文件拖动到<code>Public</code>下面，把不需要暴露的.m文件拖动到<code>Project</code>下面。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-2.png" alt="img"></p>
<p>在新创建的工程里有一个和工程名一样的.h头文件，在该文件中引入全部需要暴露的.h文件。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-3.png" alt="img"></p>
<h3 id="添加脚本"><a href="#添加脚本" class="headerlink" title="添加脚本"></a>添加脚本</h3><p>创建Aggregate，点击<code>TARGETS</code>下面的加号，Xcode8.0在<code>Cross-platform</code>里面的<code>Aggregate</code>，Xcode8之前的在<code>Other</code>里面<code>Aggregate</code>。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/2016-10-144.30.53.png" alt="img"></p>
<p>在新添加的<code>Aggregate</code>的<code>Build Phases</code>里面，点击加号，选择<code>New Run Script Phase</code>，添加Run Script脚本。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/2016-10-144.44.46.png" alt="img"></p>
<p>在Run Script代码框中添加脚本。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-4.png" alt="img"></p>
<p>完整脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># Sets the target folders and the final framework product.</div><div class="line"># 如果工程名称和Framework的Target名称不一样的话，要自定义FMKNAME</div><div class="line"># 例如: FMK_NAME = &quot;MyFramework&quot;</div><div class="line">FMK_NAME=$&#123;PROJECT_NAME&#125;</div><div class="line"># Install dir will be the final output to the framework.</div><div class="line"># The following line create it in the root folder of the current project.</div><div class="line">INSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;FMK_NAME&#125;.framework</div><div class="line"># Working dir will be deleted after the framework creation.</div><div class="line">WRK_DIR=build</div><div class="line">DEVICE_DIR=$&#123;WRK_DIR&#125;/Release-iphoneos/$&#123;FMK_NAME&#125;.framework</div><div class="line">SIMULATOR_DIR=$&#123;WRK_DIR&#125;/Release-iphonesimulator/$&#123;FMK_NAME&#125;.framework</div><div class="line"># -configuration $&#123;CONFIGURATION&#125;</div><div class="line"># Clean and Building both architectures.</div><div class="line">xcodebuild -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphoneos clean build</div><div class="line">xcodebuild -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphonesimulator clean build</div><div class="line"># Cleaning the oldest.</div><div class="line">if [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]</div><div class="line">then</div><div class="line">rm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;</div><div class="line">fi</div><div class="line">mkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;</div><div class="line">cp -R &quot;$&#123;DEVICE_DIR&#125;/&quot; &quot;$&#123;INSTALL_DIR&#125;/&quot;</div><div class="line"># Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.</div><div class="line">lipo -create &quot;$&#123;DEVICE_DIR&#125;/$&#123;FMK_NAME&#125;&quot; &quot;$&#123;SIMULATOR_DIR&#125;/$&#123;FMK_NAME&#125;&quot; -output &quot;$&#123;INSTALL_DIR&#125;/$&#123;FMK_NAME&#125;&quot;</div><div class="line">rm -r &quot;$&#123;WRK_DIR&#125;&quot;</div><div class="line">open &quot;$&#123;INSTALL_DIR&#125;&quot;</div></pre></td></tr></table></figure>
<h3 id="配置armv7s"><a href="#配置armv7s" class="headerlink" title="配置armv7s"></a>配置armv7s</h3><p>在<code>TARGETS</code>第一个包下面，<code>Build Settings</code>下面<code>Architectures</code>这一行，点击选择<code>Other</code>，在弹出框中加上armv7s。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-5.png" alt="img"></p>
<h3 id="编译工程"><a href="#编译工程" class="headerlink" title="编译工程"></a>编译工程</h3><p>选中新创建的<code>TARGETS</code>，command + b 编译工程，编译完成后会自动弹出Finder里打包完成的.framework静态库。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-6.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-8.png" alt="img"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS库一般有开源库，静态库和动态库。&lt;/p&gt;
&lt;p&gt;开源库是指源代码开放的功能代码，比如AFNetworking。&lt;/p&gt;
&lt;p&gt;静态库是指内部代码逻辑看不到，依靠相应的.h头文件调用内部方法的功能模块。有&lt;code&gt;.a静态库&lt;/code&gt;和&lt;code&gt;.framework&lt;/code&gt;两种形式。比如：百度导航的&lt;code&gt;libbaiduNaviSDK.a&lt;/code&gt;，百度地图&lt;code&gt;BaiduMapAPI_Map.framework&lt;/code&gt;。使用时要完全拷贝到工程中，调用。&lt;br&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="静态库" scheme="http://markmiao.com/tags/%E9%9D%99%E6%80%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS10升级后的一些问题</title>
    <link href="http://markmiao.com/2016/11/11/iOS10%E5%8D%87%E7%BA%A7%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://markmiao.com/2016/11/11/iOS10升级后的一些问题/</id>
    <published>2016-11-11T13:07:52.000Z</published>
    <updated>2016-11-27T05:14:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在2016年9月14日凌晨iOS10系统准时推送过来了，作为懒人之前的beta版一直没有升级试用。今天果断手机和Xcode一起升级了，新系统新面貌带来新bug。记录一下升级iOS10和Xcode8.0后遇到的问题。</p>
<a id="more"></a>
<h2 id="开发者证书不能使用"><a href="#开发者证书不能使用" class="headerlink" title="开发者证书不能使用"></a>开发者证书不能使用</h2><p>General里面Signing变成如下样子，Automatically manage signing 自动签名管理。报错了，之前一直使用的企业级开发者证书不可用了。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG79.jpeg?raw=true" alt="img"></p>
<p>Build Settings 里面的 Code Signing Identity 清一色选择为企业级开发者证书。还是报错</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160914-0.png?raw=true" alt="img"></p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160914-1.png?raw=true" alt="img"></p>
<p><strong>解决办法：</strong></p>
<p>取消Automatically manage signing的选择，会出现两个Signing，分别对应Debug和Release，选择该项目对应使用的Provisioning Profiles即可</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160914-2.png?raw=true" alt="img"></p>
<h2 id="注释快捷键command-失效"><a href="#注释快捷键command-失效" class="headerlink" title="注释快捷键command+/失效"></a>注释快捷键command+/失效</h2><p>Xcode8.0的注释// 生成快捷键 command+/失效了</p>
<p><strong>解决办法：</strong></p>
<p>终端运行命令：<code>sudo /usr/libexec/xpccachectl</code><br>Password：<code>输入开机密码</code><br>重启Mac生效</p>
<p>生效后空行快捷键，只在代码行能产生/解除注释，空行不能产生注释。记得之前可以来这….</p>
<h2 id="Xcode控制台输出问题"><a href="#Xcode控制台输出问题" class="headerlink" title="Xcode控制台输出问题"></a>Xcode控制台输出问题</h2><h3 id="无用log打印"><a href="#无用log打印" class="headerlink" title="无用log打印"></a>无用log打印</h3><p>升级Xcode8.0之后运行项目，控制台疯狂打印了N多东西，完全看不懂啊，完犊子了，这么多需要适配的…</p>
<p>眼不见心不烦，下面就提供去掉这些乱七八糟打印内容的方法。</p>
<p><strong>解决办法：</strong></p>
<p>在<code>Edit Scheme...</code>下的Run -&gt; Arguments -&gt; Environment Variables 添加  <code>OS_ACTIVITY_MODE</code> = <code>disable</code></p>
<p>具体见下图</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160914-3.png?raw=true" alt="img"></p>
<h3 id="真机测试log屏蔽"><a href="#真机测试log屏蔽" class="headerlink" title="真机测试log屏蔽"></a>真机测试log屏蔽</h3><p>经过上述修改，在iOS10模拟器中无用的log输出被屏蔽了，但是真机测试的时候，没有log输出，log日志被完全屏蔽了。不知是屏蔽无用log的设置，还是xcode8为了提高真机测试性能屏蔽了log日志？真机测试的log也很重要。</p>
<p>为了app正式发布时不打印log，让打印操作<code>NSLog</code>只在<code>Debug</code>环境下运行，采用了下面的办法自定义<code>NSLog</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#ifdef DEBUG</div><div class="line">#define XDLog(...) NSLog(__VA_ARGS__)</div><div class="line">#else</div><div class="line">#define XDLog(...)</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>iOS10之后，在真机中<code>NSLog</code>无法打印log，可以使用<code>printf()</code>，具体修改见下面自定义log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#ifdef DEBUG</div><div class="line">#define XDString [NSString stringWithFormat:@&quot;%s&quot;, __FILE__].lastPathComponent</div><div class="line">#define XDLog(...) printf(&quot;%s %d行: %s\n\n&quot;,[XDString UTF8String], __LINE__, [[NSString stringWithFormat:__VA_ARGS__] UTF8String]);</div><div class="line">#else</div><div class="line">#define XDLog(...)</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p><code>XDString</code>是获取的该log在哪个文件里，<code>__LINE__</code>该log在第几行。<code>printf()</code>是c语言方法，所以要用<code>UTF8String</code>转义，不然每个log都会有警告。</p>
<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>网络获取数据，做容错处理，判断某个字段是否符合需要的数据类型。之前一度用如下判断方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[NSStringFromClass([userDict[@&quot;plates&quot;] class]) isEqualToString:@&quot;__NSCFArray&quot;]</div></pre></td></tr></table></figure>
<p>如果<code>userDict[@&quot;plates&quot;]</code>的数据类型是数组的话，打印出来的就是<code>__NSCFArray</code>类型。同样如果是字典类型的话，打印出来的就是<code>__NSCFDictionary</code>。但是iOS10之后，打印出来的不同了，同样的数组类型，打印出来的是<code>__NSSingleObjectArrayI</code>。</p>
<p>之前的这种判断方法很欠考虑，还是利用下面的方法比较靠谱：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[userDict[@&quot;plates&quot;] isKindOfClass:[NSArray class]]</div></pre></td></tr></table></figure>
<h2 id="URL-Schemes跳转系统设置"><a href="#URL-Schemes跳转系统设置" class="headerlink" title="URL Schemes跳转系统设置"></a>URL Schemes跳转系统设置</h2><p>跳转系统设置分为<strong>跳转到系统设置列表</strong>和<strong>跳转到自己app的系统设置</strong>。</p>
<p>跳转系统设置列表的方法在iOS10被彻底关闭了，也就是说你已不能从app跳转到系统设置列表里了。但是还可以跳转到自己app的系统设置</p>
<p>例如：我的某个app使用地理定位，运行app时会检测是否开启地理定位，如果未开启，提醒alert，用如下代码点击跳转到地理定位的开启设置里。</p>
<p>iOS10之前使用下面方法可以跳转到系统设置列表，列表里有自己的app，可以点击进去做相应设置.使用时要添加URL Schemes，字段为<code>prefs</code>。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161010-0.png?raw=true" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSURL *url = [NSURL URLWithString:@&quot;prefs:root=LOCATION_SERVICES&quot;];</div><div class="line">if ([[UIApplication sharedApplication] canOpenURL:url]) &#123;</div><div class="line">		[[UIApplication sharedApplication] openURL:url];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>iOS10时该方法被关闭了，只能通过下面方法跳转到自己app的系统设置，使用<code>UIApplicationOpenSettingsURLString</code>，这个字段是在iOS8时出现的。在使用这个方法时，注意iOS8/iOS9时可以使用<code>openURL:</code>，iOS10建议使用<code>openURL:options:completionHandler:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSURL *url = [NSURL URLWithString:UIApplicationOpenSettingsURLString];</div><div class="line">if ([[UIApplication sharedApplication] canOpenURL:url]) &#123;</div><div class="line">    if (iOS10) &#123;</div><div class="line">        [[UIApplication sharedApplication] openURL:url options:@&#123;&#125; completionHandler:^(BOOL success) &#123;</div><div class="line">            XDLog(@&quot;success = %d&quot;, success);</div><div class="line">        &#125;];</div><div class="line">    &#125; else &#123;</div><div class="line">        [[UIApplication sharedApplication] openURL:url];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">跳转到系统设置列表，iOS10之前可用</th>
<th style="text-align:center">跳转到自己app的系统设置，iOS8以后可用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/2016年10月10日上午11.31.12.png?raw=true" alt="img"></td>
<td style="text-align:center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/2016年10月10日上午11.33.55.png?raw=true" alt="img"></td>
</tr>
</tbody>
</table>
<h3 id="附prefs-root"><a href="#附prefs-root" class="headerlink" title="附prefs:root"></a>附prefs:root</h3><p>prefs:root=General&amp;path=About<br>prefs:root=General&amp;path=ACCESSIBILITY<br>prefs:root=AIRPLANE_MODE<br>prefs:root=General&amp;path=AUTOLOCK<br>prefs:root=General&amp;path=USAGE/CELLULAR_USAGE<br>prefs:root=Brightness<br>prefs:root=General&amp;path=Bluetooth<br>prefs:root=General&amp;path=DATE_AND_TIME<br>prefs:root=FACETIME<br>prefs:root=General<br>prefs:root=General&amp;path=Keyboard<br>prefs:root=CASTLE<br>prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP<br>prefs:root=General&amp;path=INTERNATIONAL<br>prefs:root=LOCATION_SERVICES<br>prefs:root=ACCOUNT_SETTINGS<br>prefs:root=MUSIC<br>prefs:root=MUSIC&amp;path=EQ<br>prefs:root=MUSIC&amp;path=VolumeLimit<br>prefs:root=General&amp;path=Network<br>prefs:root=NIKE_PLUS_IPOD<br>prefs:root=NOTES<br>prefs:root=NOTIFICATIONS_ID<br>prefs:root=Phone<br>prefs:root=Photos<br>prefs:root=General&amp;path=ManagedConfigurationList<br>prefs:root=General&amp;path=Reset<br>prefs:root=Sounds&amp;path=Ringtone<br>prefs:root=Safari<br>prefs:root=General&amp;path=Assistant<br>prefs:root=Sounds<br>prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK<br>prefs:root=STORE<br>prefs:root=TWITTER<br>prefs:root=General&amp;path=USAGE<br>prefs:root=VIDEO<br>prefs:root=General&amp;path=Network/VPN<br>prefs:root=Wallpaper<br>prefs:root=WIFI<br>prefs:root=INTERNET_TETHERING  </p>
<h2 id="plist里声明获取隐私数据权限"><a href="#plist里声明获取隐私数据权限" class="headerlink" title="plist里声明获取隐私数据权限"></a>plist里声明获取隐私数据权限</h2><p>访问隐私数据需要在plist里声明，在iOS10之前只需要声明地理定位之类的敏感隐私数据，获取照片、相机等不需要再plist里声明。iOS10之后，这些也必须声明，不声明会crash。需要声明的用户数据有：</p>
<blockquote>
<p>Contacts（联系人）, Calendar（日历）, Reminders（提醒事件）, Photos（照片）, Bluetooth Sharing（蓝牙共享）, Microphone（麦克风）, Camera（相机）, Location（位置）, Health（健康）, HomeKit（家居）, Media Library（媒体库）, Motion（运动）, CallKit（打电话）, Speech Recognition（语言识别）, SiriKit（Siri）, TV Provider（电视提供商）.</p>
</blockquote>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160921-0.png?raw=true" alt="img"></p>
<p>后面string字段填写弹出用户允许时展示的描述信息。<strong>注意，这里必须要写明获取该权限的用途，不然会被AppStore拒绝上架的。</strong></p>
<h2 id="某些app链接网络失败"><a href="#某些app链接网络失败" class="headerlink" title="某些app链接网络失败"></a>某些app链接网络失败</h2><p>iOS10之后出现了实用无线局域网与蜂窝移动网络的允许授权弹窗，有些应用没有出现这个弹窗，莫名其妙的就连不上网络了，去设置的“使用无线局域网与蜂窝移动的应用”里找也找不到，搜索该应用，也没有开启使用网络授权的开关。</p>
<p>其实只需要在“使用无线局域网与蜂窝移动的应用”里面修改任意一个应用的使用网络设置，再打开连不上网的应用，就会出现网络授权弹窗。这是一个系统bug，希望后续的iOS10.x.x系统会修复。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在2016年9月14日凌晨iOS10系统准时推送过来了，作为懒人之前的beta版一直没有升级试用。今天果断手机和Xcode一起升级了，新系统新面貌带来新bug。记录一下升级iOS10和Xcode8.0后遇到的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS10" scheme="http://markmiao.com/tags/iOS10/"/>
    
  </entry>
  
  <entry>
    <title>记个人博客时代的开始</title>
    <link href="http://markmiao.com/2016/11/10/%E8%AE%B0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%97%B6%E4%BB%A3%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>http://markmiao.com/2016/11/10/记个人博客时代的开始/</id>
    <published>2016-11-10T08:37:23.000Z</published>
    <updated>2016-11-27T05:14:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>接触编程有六年了，以敲代码为职业混饭吃也有三年了。既不是名牌大学毕业，也没就职过牛逼闪闪的金牌企业。作为一个默默无闻的码农，耕种着自己的一亩三分地，偶尔在CSDN或者简书上写篇博客，也不是什么高深技术，只是自己工作中遇到的一些问题。即便如此，也没积累下来，博客单薄的像是篇目录。<br><a id="more"></a></p>
<p>用了两天时间使用 Hexo + github 搭建了自己的博客，终于开启了个人博客时代，虽然有点晚，但比起明天还是早。搭建过程中也踩了不少坑，网络上有各种各样的解决办法，搭建博客的流程也烂大街般的多，我也不逞能再写一篇更烂的了。</p>
<p>一直以来想学的太多，关注的太杂，总是不能聚焦一点深入下去，行动的步伐跟不上大脑的冲动。还有之前敲代码时遇到的问题也没有记录完全，想钻研的技术一搁下就抛到脑后了。希望有自己的博客后，能专注一些，不贪多，不烂尾。</p>
<p>现在码代码，之前喜欢写文字。要不是我写的太烂，现在就不是码农而是作家了(说的好像代码写的不烂似的)。不管怎么说，还是很有兴趣写博客的，只是之前没坚持下来。</p>
<p>这个博客不会是纯技术，会掺杂其他的文，但还会以技术为主。目前也别期望出现高质量有深度的技术文，我也写不出来。算是我的个人学习博客，慢慢写，慢慢积累…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触编程有六年了，以敲代码为职业混饭吃也有三年了。既不是名牌大学毕业，也没就职过牛逼闪闪的金牌企业。作为一个默默无闻的码农，耕种着自己的一亩三分地，偶尔在CSDN或者简书上写篇博客，也不是什么高深技术，只是自己工作中遇到的一些问题。即便如此，也没积累下来，博客单薄的像是篇目录。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://markmiao.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="短文" scheme="http://markmiao.com/tags/%E7%9F%AD%E6%96%87/"/>
    
      <category term="碎碎念" scheme="http://markmiao.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>提交应用到AppStore的准备工作</title>
    <link href="http://markmiao.com/2016/11/10/%E6%8F%90%E4%BA%A4%E5%BA%94%E7%94%A8%E5%88%B0AppStore%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <id>http://markmiao.com/2016/11/10/提交应用到AppStore准备工作/</id>
    <published>2016-11-10T03:50:14.000Z</published>
    <updated>2016-12-12T06:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细记录了提交应用到AppStore的准备工作，以及准备的内容对应AppStore上APP的呈现方式，还列出某些内容是不能随意修改的，以及填写时的注意点，还有我提交APP时踩到的坑。对已有过上架经验的开发者来说本文意义不大，但是当产品经理问上架AppStore需要什么资料时，可以把本文分享给他。<br><a id="more"></a></p>
<h2 id="App信息"><a href="#App信息" class="headerlink" title="App信息"></a>App信息</h2><p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160815-7.png?raw=true" alt="iTunes Connect内APP信息截图"></p>
<h3 id="公司名称"><a href="#公司名称" class="headerlink" title="公司名称"></a>公司名称</h3><p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG1081.jpeg?raw=true" alt="12306显示的公司名称"></p>
<p>公司名字是指显示在这里的名字。这个只针对公司级账号说的，个人账号不能设置公司名称，只能以开发商名字显示。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160930-0.png?raw=true" alt="设置公司名"></p>
<p>每个账号在iTunes Connect里创建第一个应用的时候，可以设置公司名字。如果不设置的话，就显示开发商名字。日后不能修改公司名字，也不能重新设置。只能给苹果开发者发邮件，要求去掉公司名显示开发商名字。</p>
<h3 id="app名称"><a href="#app名称" class="headerlink" title="app名称"></a>app名称</h3><p>您的 App 在 App Store 中显示的名称。名称长度不能超过<del>255个字符</del> 50个字符（新审核指南修改）。并不等同于app安装完成在手机上显示的名字，这里的名称可以写为名字+简介。</p>
<p>例如：天猫在AppStore展示的名称如下图，应用名为“天猫”</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/image/%E5%9B%BE%E7%89%87%201.png" alt="天猫"></p>
<h3 id="隐私政策网址-可不填"><a href="#隐私政策网址-可不填" class="headerlink" title="隐私政策网址(可不填)"></a>隐私政策网址(可不填)</h3><p>您所在机构的隐私政策网址(URL)。面向儿童或提供自动续费的 App 内购买项目或免费订阅的 App, 均需要隐私政策。另外, 需用帐户注册、使用现有帐户访问、或由法律另行规定的 App 也需隐私政策。对于收集用户或设备相关数据的 App, 亦推荐使用隐私政策。</p>
<h3 id="套装ID"><a href="#套装ID" class="headerlink" title="套装ID"></a>套装ID</h3><p>套装 ID 必须与您在 Xcode 中使用的 ID 相符。该 ID 在您上传第一个构建版本后便无法更改。</p>
<p>开发人员设置的，在开发信息配置里<code>Certificates, Identifiers &amp; Profiles</code>注册的<code>Identifiers</code>。一般与工程中的<code>Bundle Identifier</code>相同，如果<code>Identifiers</code>使用了通配符<code>*</code>则不需要完全一样(应用有消息推送功能，不能使用通配符！)。</p>
<h3 id="SKU"><a href="#SKU" class="headerlink" title="SKU"></a>SKU</h3><p>您 App 专有的 ID, 此 ID 不会在 App Store 中显示。</p>
<p>开发人员设置，注意保持唯一性。</p>
<h3 id="Apple-ID"><a href="#Apple-ID" class="headerlink" title="Apple ID"></a>Apple ID</h3><p>为您的 App 自动生成的 ID。无需设置，在<code>iTunes Connect</code>创建了应用就会生成此ID。做qq登录分享功能在腾讯开放平台注册应用时需要提交这个ID。</p>
<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>最能准确描述此 App 的类别。分为主要类别和次要类别，次要类别可不填。有如下类别：</p>
<p>报刊杂志、财务、参考、导航、儿童、工具、购物、健康健美、教育、旅游、美食佳饮、商品指南、商务、社交、摄影与录像、生活、体育、天气、图书、效率、新闻、医疗、音乐、游戏、娱乐。</p>
<p>详情请见：<a href="https://itunesconnect.apple.com/itc/static/category_definitions" target="_blank" rel="external">AppStore类别定义</a></p>
<h3 id="分级"><a href="#分级" class="headerlink" title="分级"></a>分级</h3><p>此 App 分级将在所有平台的 App Store 中显示。此分级根据分级限制最高的 App 平台而定。</p>
<h2 id="App版本信息"><a href="#App版本信息" class="headerlink" title="App版本信息"></a>App版本信息</h2><h3 id="app预览和屏幕快照"><a href="#app预览和屏幕快照" class="headerlink" title="app预览和屏幕快照"></a>app预览和屏幕快照</h3><p>屏幕快照必须为 JPG 或 PNG 格式，且必须采用 RGB 颜色空间。 App 预览必须为 M4V、MP4 或 MOV 格式，且不能超过 500 MB。</p>
<p>现在只需要提交5.5英寸的图片，其他尺寸会沿用5.5的图片，尺寸为1242*2208。可以设计几张app介绍图或者用手机截屏。也可以用模拟器保存界面快照，操作：<code>command + s</code>，注意模拟器有显示百分比，在<code>模拟器-&gt;Window-&gt;Scale</code>里面，快捷键是<code>command + 12345</code>，保存界面快照时要<code>command + 1</code>100%模拟器显示。非Retina屏(低分辨率)的Mac模拟器会超过屏幕，但不影响快照保存。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160815-4.png?raw=true" alt="屏幕快照"></p>
<h3 id="描述-关键字-技术支持网址-营销网址"><a href="#描述-关键字-技术支持网址-营销网址" class="headerlink" title="描述/关键字/技术支持网址/营销网址"></a>描述/关键字/技术支持网址/营销网址</h3><p>描述：对您 App 的描述，用以详细说明特性和功能。它还将用于您的 Apple Watch App。显示于AppStore中的内容提要</p>
<p>关键字：一个或多个关键词，用以描述您的 App。关键词将使 App Store 搜索结果更加准确。</p>
<p>技术支持网址：您的 App 技术支持信息网址(URL)。该网址(URL)将会在 App Store 中显示。显示位置为<code>开发人员网站</code>。点击在Safari中打开网址。一般会填写官网地址。</p>
<p>营销网址：您的 App 营销信息网址(URL)。该网址(URL)会在 App Store 中显示。可不填写。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160815-5.png?raw=true" alt="app描述显示的位置"></p>
<h2 id="构建版本"><a href="#构建版本" class="headerlink" title="构建版本"></a>构建版本</h2><p>提交app到AppStore审核最重要的地方！提交打包好的.api文件</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/image/QQ20160815-11.png" alt="构建版本"></p>
<p>但并不是在这里面上传.api文件。而是需要用<code>Application Loader</code>交付应用程序。<code>Application Loader</code>的位置在<code>Xcode</code> -&gt; <code>Open DeveloperTool</code> -&gt; <code>Application loader</code>，或者在应用程序里<code>Xcode.app</code>右键显示包内容 -&gt; <code>Contents</code> -&gt; <code>Applications</code> -&gt; <code>Application loader.app</code>，选择交付应用程序。这里要事先登录上架应用的开发者账号，也就是打包.api文件时配置发布证书的开发者账号。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161212-0.png?raw=true" alt="使用Application loader交付应用程序"></p>
<p>在交付应用程序的时候，点背的话会一直显示<code>正在通过AppStore进行鉴定</code>，然后就一直等然后也没有然后，我曾晚上11点交付应用程序，然后就这样显示了一夜，第二天醒来依旧正在通过AppStore进行鉴定。</p>
<p>至于为什么会这样，相信大家都心知肚明。好多开发者选择翻墙交付应用程序，我也经常这么干，亲测挺快的。其实有时候人品正，在墙内也可以很快交付。我还在网上找到过一个解决办法，需要修改Application Loader里的一个文件内容，亲测过确实有效。</p>
<p>路径为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Applications/Xcode.app显示包内容 -&gt; Contents/Applications/Application Loader.app显示包内容 -&gt; Contents/itms/java/lib/net.properties</div></pre></td></tr></table></figure>
<p>或者路径为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Applications/Xcode.app显示包内容 -&gt; Contents/Applications/Application Loader.app显示包内容 -&gt; Contents/MacOS/itms/java/lib/net.properties</div></pre></td></tr></table></figure>
<p>打开这个文件，把第34行的<code>http.proxyPort=443</code> 改为<code>https.proxyPort=80</code> 再提交应用就ok了。</p>
<h2 id="App综合信息"><a href="#App综合信息" class="headerlink" title="App综合信息"></a>App综合信息</h2><h3 id="app图标"><a href="#app图标" class="headerlink" title="app图标"></a>app图标</h3><p>此图标将用于 App Store，其格式必须为 JPG 或 PNG，最低分辨率至少为 72 DPI，并采用 RGB 色彩空间。它不能包含图层或圆角。尺寸为1024*1024。</p>
<p>在开发中，只需要让设计同事提供一个1024*1024的app图标即可，可以用<a href="https://itunes.apple.com/cn/app/prepo/id476533227?mt=12" target="_blank" rel="external">Prepo</a>生成各种需要的图标尺寸。</p>
<h3 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h3><p>拥有您的 App 专有权的人员或实体的名称，前面是获得权利的年份（例如“2008 Acme Inc”），请勿提供网址(URL)，显示在AppStore。不填写年份，只填写所有权组织或个人也可以。</p>
<h3 id="商务代表联系信息"><a href="#商务代表联系信息" class="headerlink" title="商务代表联系信息"></a>商务代表联系信息</h3><p>您可以为您的 App 在韩国 App Store 中提供额外信息，这一额外信息只会显示在韩国 App Store 中。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160815-9.png?raw=true" alt="分级显示和版权信息显示"></p>
<h3 id="分级-1"><a href="#分级-1" class="headerlink" title="分级"></a>分级</h3><p>为app指定分级，一般都会指定低级，但也要根据实际情况。会影响AppStore审核。如果所有分级全选无，为4+等级，会询问此app是否是针对儿童的，根据实际情况选择。</p>
<p><a href="https://itunesconnect.apple.com/itc/views/shared/app_store_rating_matrix.html" target="_blank" rel="external">了解详情</a></p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160815-10.png?raw=true" alt="分级列表"></p>
<h2 id="APP审核信息"><a href="#APP审核信息" class="headerlink" title="APP审核信息"></a>APP审核信息</h2><p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160815-3.png?raw=true" alt="APP审核信息"></p>
<h3 id="联系信息："><a href="#联系信息：" class="headerlink" title="联系信息："></a>联系信息：</h3><p>一般会填写开发者的联系信息，在App审核中有问题会联系开发者，其实有问题被拒绝上架了也没联系过我，iTunes Connect里会有拒绝原因。app审核结果不会通过这个联系方式反馈，会反馈给开发者账号邮箱。可以下载<code>Connect</code>应用，登录提交app的开发者账号，随时接收审核状态消息推送。<del>我不会说这个应用一点都不好用，但只此一家别无分号，爱用不用</del></p>
<h3 id="演示账户："><a href="#演示账户：" class="headerlink" title="演示账户："></a>演示账户：</h3><p>提供给AppStore审核人员用于登录app的账号密码，必须有效可登录，<strong>非常重要,别问我是怎么知道的(ㄒoㄒ)~~orz</strong>。有的应用是手机号+验证码登录，需要事先让服务器同事留好后门，设定固定手机号+固定验证码能随时登录。(按说这应该开发时就得做到，不然开发者每次登录操作都获取验证码多麻烦，而且这还是要花钱的)</p>
<h3 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h3><p>对审核过程会有所帮助的、有关您 App 的额外信息, 包括在测试中需要的 App 特别设置等。额外说明app里某些影响到审核的部分，可以放入图片链接或者操作视频链接以弥补审核人员不能操作到的部分(比如：p2p项目中绑定银行卡)。</p>
<h3 id="版本发布："><a href="#版本发布：" class="headerlink" title="版本发布："></a>版本发布：</h3><p>这个根据实际情况设置，随便设置，为了一切尽在掌控，我会选择手动发布此版本，你应该体会一下应用审核通过点击发布按钮那一刻的感觉！（千万别点击开发者撤下提交的版本…）</p>
<h2 id="之前不幸踩过的一些坑，被AppStore拒了"><a href="#之前不幸踩过的一些坑，被AppStore拒了" class="headerlink" title="之前不幸踩过的一些坑，被AppStore拒了"></a>之前不幸踩过的一些坑，被AppStore拒了</h2><ol>
<li><p><strong>微信登录/支付/分享：</strong>微信没有提供网页登录。如果手机没有安装微信，不能提醒用户下载微信。正确做法是隐藏掉微信按钮。</p>
</li>
<li><p><strong>qq登录：</strong>qq登录提供了网页登录，但是如果手机没安装qq，腾讯有时会一(chou)意(bu)孤(yao)行(lian)的跳转到qq应用下载页。如果是这样的话一定被拒！正确做法是：一定要测试没有qq客户端的时候登录会不会到网页qq登录，如果跳到了qq下载页，联系腾讯客服人员，提供appid，他们会给改好。</p>
</li>
<li><p><strong>举报功能：</strong>如果应用中存在用户发布的内容，比如用户可以发布状态、帖子等(类似微博)，就必须有举报功能。</p>
</li>
<li><p><strong>新版本检测：</strong>这一条是后来加的审核规则(苹果的审核规则号称大道无形，就是一切我说了算，说你不行你就不行行也不行，见过最搞笑的被拒案例是：一个娱乐型app被拒了，理由是我们感觉您的app不具有娱乐性。全公司懵逼…)。检测是否有新版本之前是可以的，后来苹果不允许了，新版本检测都放到AppStore里进行。但是这种行为并不是不允许的，苹果不允许的是用户在app内手动检测新版本，换句话说app内不允许存在检测新版本的按钮操作，可以隐式的调用后台接口检测后台的版本库，弹窗提醒用户有新版本。</p>
</li>
<li><p><strong>iOS/iPhone/iPad/Mac等名词：</strong>这些苹果专属的名词在app中如果有展示，一定不要写错了，注意大小写，如果错了一定被拒。不展示的话就无所谓了，比如说在代码中定义一个变量名写IpHonE都没人管你(写这样的变量名不排除同事会砍死你)。</p>
</li>
<li><p><strong>未完成模块：</strong>AppStore不接受测试版或未完成版，某个模块如果未完成千万不要为了用户体验贱贱的写上模块开发中…之类的提示，这样会被拒绝上架的。留一个空白页面或者按钮点击没反应可能会上架成功。</p>
</li>
<li><p><strong>64位/https/bitcode：</strong>应用必须支持64位包括应用中使用的静态库，如果不支持64位，交付应用程序就会失败，根本到不了审核。https安全网络请求，目前为止并没有强制这样做，不保证以后会不会强制。比如现在app必须包含<code>IPv6-only</code>网络支持。bitcode Watch应用必须支持，iOS应用可支持可不支持，Mac应用不支持。</p>
</li>
<li><p><strong>后台地理定位：</strong>使用后台地理定位Background Modes为打开状态，需要在<code>info.plist</code>的<code>NSLocationAlwaysUsageDescription</code>字段添加文字描述，说清楚后台地理定位用在什么地方了。</p>
<blockquote>
<p>Please revise the NSLocationAlwaysUsageDescription value in the info.plist to specify the intended purpose of using the user’s location while the app is in the background.</p>
</blockquote>
<p> 还有一个很重要的地方，就是必须在提交app到AppStore时填写的描述里添加电池使用免责声明，提示用户后台定位操作会消耗电量并且影响电池续航能力。这个规则略坑啊</p>
<blockquote>
<p>Please also add the following battery use disclaimer in your Application Description:<br>“Continued use of GPS running in the background can dramatically decrease battery life.”</p>
</blockquote>
</li>
<li><p><strong>其他权限获取：</strong>iOS10以后增加了一些原本不需要的权限介绍，比如获取相机/相册等。这些都需要在<code>info.plist</code>里增加字段，不然在iOS10上会崩溃，肯定会被拒的。iOS10更多问题请见<a href="https://github.com/mxdios/notebook/blob/master/notebooks/iOS10%E5%8D%87%E7%BA%A7%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98.md" target="_blank" rel="external">iOS10升级后的一些问题</a></p>
</li>
<li><p><strong>app内购：</strong>苹果规定，虚拟产品要走app内购(<del>走内购苹果会拿走30%的利润，感觉好赚钱的样子</del>)，不能走第三方支付。问题是：总有一些产品经理会拿一些案例说服开发者可以走第三方支付，比如：微博购买会员可以使用微信支付宝等支付(还有上述第二条qq登录问题，忘记了是不是糗事百科还是哪个段子应用，一直跳转qq下载页，竟然依旧上架无忧，还有若干带有新版本检测功能的app在AppStore大行其道，这样让开发者很难做啊，说实现不了会被指责无能的)。开发者解释无效后，被AppStore狠狠地打脸拒绝。下次直接对产品说：那是微博产品经理和苹果公司合作洽谈的结果，毕竟微博在iPhone手机里有内置的。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文详细记录了提交应用到AppStore的准备工作，以及准备的内容对应AppStore上APP的呈现方式，还列出某些内容是不能随意修改的，以及填写时的注意点，还有我提交APP时踩到的坑。对已有过上架经验的开发者来说本文意义不大，但是当产品经理问上架AppStore需要什么资料时，可以把本文分享给他。&lt;br&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://markmiao.com/tags/iOS/"/>
    
      <category term="AppStore" scheme="http://markmiao.com/tags/AppStore/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发笔记</title>
    <link href="http://markmiao.com/2016/11/09/iOS%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://markmiao.com/2016/11/09/iOS开发笔记/</id>
    <published>2016-11-09T09:24:20.000Z</published>
    <updated>2016-11-27T05:14:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>记录了在iOS开发中踩过的坑和一些问题解决</strong></p>
<p>本文不断更新中…<br><a id="more"></a></p>
<h2 id="微信的openid"><a href="#微信的openid" class="headerlink" title="微信的openid"></a>微信的openid</h2><p>微信的openid对于某个用户来说并不是唯一的，某个用户对某个公众号或者对某个微信开放平台下某个appid生成的是唯一的。appid改变，openid也会改变。公众号下和app下获得的openid不同，现阶段无法实现相同操作。使用unionid打通用户，微信开放平台上绑定了公众号，这时获取的unionid会一致。</p>
<h2 id="Cell进入编辑状态，内容覆盖编辑按钮"><a href="#Cell进入编辑状态，内容覆盖编辑按钮" class="headerlink" title="Cell进入编辑状态，内容覆盖编辑按钮"></a>Cell进入编辑状态，内容覆盖编辑按钮</h2><p>删除一条cell时，最常用的方法就是侧滑删除。</p>
<p>还有就是点击编辑按钮，cell进入编辑状态，点击红色减号button，出现删除按钮，点击删除完成删除操作。这时会出现问题，cell上的内容遮盖了删除按钮，如下图所示。</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/image/Untitleds.gif" alt="如图"></p>
<p>解决这个问题，只需要在自定义cell里加如下代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)layoutSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> layoutSubviews];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isEditing) &#123;</div><div class="line">        [<span class="keyword">self</span> sendSubviewToBack:<span class="keyword">self</span>.contentView];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20160722-0.png" alt="结果"></p>
<h2 id="View中部分内嵌UIWebView"><a href="#View中部分内嵌UIWebView" class="headerlink" title="View中部分内嵌UIWebView"></a>View中部分内嵌UIWebView</h2><p>在开发中，有的界面要求部分原生，部分根据服务器返回的URL地址显示网页。这就需要计算这部分网页的size。不然就会显示不全或者留白太多</p>
<p>创建UIWebView 并加载页面</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIWebView</span> *webview = [[<span class="built_in">UIWebView</span> alloc] init]; <span class="comment">//创建webview</span></div><div class="line">webview.delegate = <span class="keyword">self</span>;  <span class="comment">//设置代理</span></div><div class="line">[webview loadHTMLString:url baseURL:<span class="literal">nil</span>]; <span class="comment">//加载网页</span></div><div class="line">[<span class="keyword">self</span>.view addSubview:webview]; <span class="comment">//添加到view上</span></div></pre></td></tr></table></figure>
<p>在webView的代理方法中获取网页实际size</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView</div><div class="line">&#123;</div><div class="line">    webView.width = <span class="keyword">self</span>.view.width; <span class="comment">//实际宽度</span></div><div class="line">    webView.height = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"document.body.scrollHeight"</span>].floatValue; <span class="comment">//实际高度</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="设置UITextField的placeholder字体的颜色和字号"><a href="#设置UITextField的placeholder字体的颜色和字号" class="headerlink" title="设置UITextField的placeholder字体的颜色和字号"></a>设置UITextField的placeholder字体的颜色和字号</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">textField.placeholder = <span class="string">@"请输入用户名"</span>;  </div><div class="line">[textField setValue:[<span class="built_in">UIColor</span> redColor] forKeyPath:<span class="string">@"_placeholderLabel.textColor"</span>];  </div><div class="line">[textField setValue:[<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">16</span>] forKeyPath:<span class="string">@"_placeholderLabel.font"</span>];</div></pre></td></tr></table></figure>
<h2 id="按钮的拖动效果和点击事件并存"><a href="#按钮的拖动效果和点击事件并存" class="headerlink" title="按钮的拖动效果和点击事件并存"></a>按钮的拖动效果和点击事件并存</h2><p>需求是一个按钮可以在屏幕中随意拖动，不能拖出屏幕外。距离屏幕最边缘有10像素的距离。拖动结束后，根据距离左右两侧哪侧近，靠到近的一侧。</p>
<p>定义<code>Bool</code>类型的全部变量，控制是否执行点击事件</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> _isClick;</div></pre></td></tr></table></figure>
<p>创建按钮添加拖动和点击事件</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//添加点击事件</span></div><div class="line">[btn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(btnClick:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line"><span class="comment">//添加拖动事件</span></div><div class="line">[btn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(dragMoving:withEvent:)forControlEvents: <span class="built_in">UIControlEventTouchDragInside</span>];</div><div class="line"><span class="comment">//添加拖动结束时的事件</span></div><div class="line">[btn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(dragEnded:withEvent:)forControlEvents: <span class="built_in">UIControlEventTouchUpInside</span>];</div></pre></td></tr></table></figure>
<p>实现事件方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//拖动过程中</span></div><div class="line">- (<span class="keyword">void</span>)dragMoving:(<span class="built_in">UIControl</span> *)c withEvent:ev</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CGPoint</span> point = [[[ev allTouches] anyObject] locationInView:<span class="keyword">self</span>.view];   </div><div class="line">    point.x = MIN(MAX(point.x, btn.width * <span class="number">0.5</span> + <span class="number">10</span>) , <span class="keyword">self</span>.view.width - btn.width * <span class="number">0.5</span> - <span class="number">10</span>);<span class="comment">//范围</span></div><div class="line">    point.y = MIN(MAX(point.y, <span class="number">100</span>), <span class="keyword">self</span>.view.height - btn.height * <span class="number">0.5</span> - <span class="number">10</span>);<span class="comment">//范围</span></div><div class="line">    c.center = point;</div><div class="line">    _isClick = <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//拖动结束</span></div><div class="line">- (<span class="keyword">void</span>)dragEnded:(<span class="built_in">UIControl</span> *)c withEvent:ev</div><div class="line">&#123;</div><div class="line">    XDLog(<span class="string">@"dragEnded...."</span>);   </div><div class="line">    <span class="built_in">CGPoint</span> point = [[[ev allTouches] anyObject] locationInView:<span class="keyword">self</span>.view];</div><div class="line">    point.x = MIN(MAX(point.x, btn.width * <span class="number">0.5</span> + <span class="number">10</span>), <span class="keyword">self</span>.view.width - btn.width * <span class="number">0.5</span> - <span class="number">10</span>);<span class="comment">//范围</span></div><div class="line">    point.y = MIN(MAX(point.y, <span class="number">100</span>) , <span class="keyword">self</span>.view.height - btn.height * <span class="number">0.5</span> - <span class="number">10</span>);<span class="comment">//范围</span></div><div class="line">    c.center = point;</div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.2</span> animations:^&#123;</div><div class="line">        c.centerX = c.centerX &lt; <span class="keyword">self</span>.view.width - c.centerX ? <span class="number">30</span> : <span class="keyword">self</span>.view.width - <span class="number">30</span>;</div><div class="line">    &#125;];</div><div class="line">    _isClick = <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//点击事件</span></div><div class="line">- (<span class="keyword">void</span>)btnClick:(<span class="built_in">UIButton</span> *)btn</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (_isClick) &#123;</div><div class="line">    	<span class="comment">//点击方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="UITableViewCell左滑编辑字体颜色设置"><a href="#UITableViewCell左滑编辑字体颜色设置" class="headerlink" title="UITableViewCell左滑编辑字体颜色设置"></a>UITableViewCell左滑编辑字体颜色设置</h2><p>设置按钮，iOS8之后API，用下面代码设置多个按钮</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">UITableViewRowAction</span> *&gt; *)tableView:(<span class="built_in">UITableView</span> *)tableView editActionsForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">	<span class="keyword">void</span>(^rowActionHandler)(<span class="built_in">UITableViewRowAction</span> *, <span class="built_in">NSIndexPath</span> *) = ^(<span class="built_in">UITableViewRowAction</span> * _Nonnull action, <span class="built_in">NSIndexPath</span> * _Nonnull indexPath) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@  index = %ld"</span>, action.title, indexPath.row);</div><div class="line">        [tableView setEditing:<span class="literal">NO</span> animated:<span class="literal">YES</span>];</div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">UITableViewRowAction</span> *action1 = [<span class="built_in">UITableViewRowAction</span> rowActionWithStyle:<span class="built_in">UITableViewRowActionStyleNormal</span> title:<span class="string">@"编辑"</span> handler:rowActionHandler];</div><div class="line">    <span class="built_in">UITableViewRowAction</span> *action2 = [<span class="built_in">UITableViewRowAction</span> rowActionWithStyle:<span class="built_in">UITableViewRowActionStyleNormal</span> title:<span class="string">@"删除"</span> handler:rowActionHandler];</div><div class="line">    <span class="built_in">UITableViewRowAction</span> *action3 = [<span class="built_in">UITableViewRowAction</span> rowActionWithStyle:<span class="built_in">UITableViewRowActionStyleNormal</span> title:<span class="string">@"喜欢"</span> handler:rowActionHandler];</div><div class="line">    action1.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</div><div class="line">    action2.backgroundColor = [<span class="built_in">UIColor</span> blackColor];</div><div class="line">    action3.backgroundColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">    <span class="keyword">return</span> @[action3,action1,action2];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式显示的样式是系统自带的，系统指定字体和文字颜色。</p>
<p>按钮可以修改文字颜色，添加标题图片，背景图片等。<code>UITableViewRowAction</code>的显示为<code>UIButton</code>，修改<code>UIButton</code>的显示样式，cell的多个编辑按钮都会变化</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">UIButton</span> appearance] setTitleColor:[<span class="built_in">UIColor</span> blackColor] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">[[<span class="built_in">UIButton</span> appearance] setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"searchtool"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">[[<span class="built_in">UIButton</span> appearance] setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"searchtool"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</div></pre></td></tr></table></figure>
<p>值得注意的是下面这种方式设置字号无效</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">UIButton</span> appearance].titleLabel.font = XDFont(<span class="number">10</span>);</div></pre></td></tr></table></figure>
<p>只有一个按钮的话可以使用<code>NSAttributedString</code>设置显示文字的字体、字号、颜色等</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *attributes = @&#123;<span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">10</span>], <span class="built_in">NSForegroundColorAttributeName</span>:[<span class="built_in">UIColor</span> redColor]&#125;;</div><div class="line"><span class="built_in">NSAttributedString</span> *attributedTitle = [[<span class="built_in">NSAttributedString</span> alloc] initWithString:<span class="string">@"编辑"</span> attributes: attributes];</div><div class="line">[[<span class="built_in">UIButton</span> appearance] setAttributedTitle:attributedTitle forState:<span class="built_in">UIControlStateNormal</span>];</div></pre></td></tr></table></figure>
<p><em>这种实现方式并不好有诸多问题，当有多个按钮分别设置不同的字体字号颜色时，这种方式无法实现，当找到有效方法再添加….此条权当问题记录</em></p>
<h2 id="用Application-Loader交付应用程序时，一直正在通过AppStore进行鉴定"><a href="#用Application-Loader交付应用程序时，一直正在通过AppStore进行鉴定" class="headerlink" title="用Application Loader交付应用程序时，一直正在通过AppStore进行鉴定"></a>用Application Loader交付应用程序时，一直正在通过AppStore进行鉴定</h2><p>需要修改Application Loader里的一个文件内容。</p>
<p>路径为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Applications/Xcode.app显示包内容 -&gt; Contents/Applications/Application Loader.app显示包内容 -&gt; Contents/itms/java/lib/net.properties</div></pre></td></tr></table></figure>
<p>或者路径为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Applications/Xcode.app显示包内容 -&gt; Contents/Applications/Application Loader.app显示包内容 -&gt; Contents/MacOS/itms/java/lib/net.properties</div></pre></td></tr></table></figure>
<p>打开这个文件，把第34行的http.proxyPort=443 改为https.proxyPort=80  再提交应用就ok了</p>
<h2 id="pdf的展示"><a href="#pdf的展示" class="headerlink" title="pdf的展示"></a>pdf的展示</h2><p>项目里要求读取从服务器下载下来的pdf，pdf文件是一个发票文件，下载到本地Documents目录下，展示出来。问题来了，发票上的印章不见了。</p>
<p>我将这个pdf文件放到了各种应用中打开，结果是：微信、qq、印象笔记、掌阅iReader、Safari、iBooks、WPS Office、mac上的预览，除了WPS Office、mac上的预览能显示出印章，其他的全部显示不出印章，甚至微信、掌阅iReader连发票上的分割线都显示不出来。</p>
<p>而且，用WPS Office打开，可以点击印章删除，可以点击分割线删除。这时我感觉印章和分割线是在pdf上的标注，就像以前使用Adobe的工具给pdf加标注文字，选中文字高亮显示。</p>
<p><strong>最开始使用了最简单的展示pdf文件的方法：UIWebView</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *paths = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>);</div><div class="line"><span class="built_in">NSString</span> *documentsDirectory = [paths objectAtIndex:<span class="number">0</span>];</div><div class="line"><span class="built_in">NSString</span> *filePDF = [documentsDirectory  stringByAppendingPathComponent:<span class="string">@"file.pdf"</span>]</div><div class="line"></div><div class="line"><span class="comment">//第一种webview加载方式</span></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:_filePath];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</div><div class="line">[_webView loadRequest:request];</div><div class="line"></div><div class="line"><span class="comment">//第二种webview加载方式</span></div><div class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:_filePath];</div><div class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:_filePath];</div><div class="line">[_webView loadData:data MIMEType:<span class="string">@"application/pdf"</span> textEncodingName:<span class="string">@"UTF-8"</span> baseURL:url];</div></pre></td></tr></table></figure>
<p>失败！</p>
<p><strong>转而使用<code>Quartz 2D</code>绘制pdf</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</div><div class="line">&#123;</div><div class="line">	<span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">    <span class="comment">//旋转坐标系</span></div><div class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, <span class="keyword">self</span>.frame.size.height<span class="number">-60</span>);</div><div class="line">    <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1</span>, <span class="number">-1</span>);</div><div class="line">    <span class="built_in">CGPDFPageRef</span> pdfPage = <span class="built_in">CGPDFDocumentGetPage</span>(_pdfDoc, <span class="number">1</span>);</div><div class="line">    <span class="built_in">CGContextSaveGState</span>(context);</div><div class="line">    <span class="built_in">CGAffineTransform</span> pdfTransform = <span class="built_in">CGPDFPageGetDrawingTransform</span>(pdfPage, kCGPDFCropBox, <span class="keyword">self</span>.bounds, <span class="number">0</span>, <span class="literal">true</span>);</div><div class="line">    <span class="built_in">CGContextConcatCTM</span>(context, pdfTransform);</div><div class="line">    <span class="built_in">CGContextDrawPDFPage</span>(context, pdfPage);</div><div class="line">    <span class="built_in">CGContextRestoreGState</span>(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>失败！甚至分割线都没了</p>
<p>这是最常用的两种读取pdf文件的方式，然而还是显示不出来发票上面的印章</p>
<p><strong>使用QLPreviewController预览</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//导入QuickLook库</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;QuickLook/QuickLook.h&gt;</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">	QLPreviewController *previ = [[QLPreviewController alloc] init];</div><div class="line">	previ.view.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.view.width, <span class="keyword">self</span>.view.height - <span class="number">200</span>);</div><div class="line">	previ.delegate = <span class="keyword">self</span>;</div><div class="line">	previ.dataSource = <span class="keyword">self</span>;</div><div class="line">	[<span class="keyword">self</span>.view addSubview:previ.view];</div><div class="line">&#125;</div><div class="line"><span class="comment">//实现代理方法</span></div><div class="line"><span class="meta">#pragma mark - 在此代理处加载需要显示的文件</span></div><div class="line">- (<span class="built_in">NSURL</span> *)previewController:(QLPreviewController *)previewController previewItemAtIndex:(<span class="built_in">NSInteger</span>)idx</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:filePath];</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark - 返回文件的个数</span></div><div class="line">-(<span class="built_in">NSInteger</span>)numberOfPreviewItemsInPreviewController:(QLPreviewController *)controller &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark - 即将要退出浏览文件时执行此方法</span></div><div class="line">-(<span class="keyword">void</span>)previewControllerWillDismiss:(QLPreviewController *)controller &#123;</div><div class="line">    XDLog(<span class="string">@"退出"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是失败的没显示出来印章。</p>
<p><strong>在github上找读取pdf的项目</strong></p>
<ul>
<li>UIImage-PDF 将pdf转成image显示，结果失败</li>
<li>Reader 比较著名的pdf阅读项目，支持大文件，加密文件，有着ibooks一样的界面。也有着iBooks一样的结果，同样显示不出来印章</li>
<li>PDFRenderer 结果失败</li>
<li>PDFTest 结果失败</li>
<li>PDFViewTest 结果失败<br>….</li>
</ul>
<p>然后各种谷歌、百度、必应搜索，终于搜到了一个有用的结果</p>
<p>原文如下 </p>
<blockquote><p>公司的项目要读取服务器发来的PDF文件，用网上的方法读取后虽然能读出来，但是发现个问题，PDF文件有的签章不见了。这个可是大问题，试了好多iOS框架库，例如 Reader,FastPdfKit都读不出来。</p>
<p>在知乎上找到一个大神的发言，解释了PDF有的内容读不出来的原因。iOS 对矢量图片的支持如何？ 直接引用其中的一段话:”iOS 的 Core Graphics 框架底层和 OS X 一样，都是基于 PDF 的。所以 iOS 用 PDF 很方便，比如 iOS 的 Quick Look 框架就可以直接看 PDF。如果要是只看文档那样简单的 PDF 的话，一般是没有什么问题的。不过，如果要是想看用 AI 制作的，带有多重描边、填充、网格渐变、阴影、多图层等东西的复杂 PDF 图形的话，有很大机率会出现问题。比如，在 iOS 和 OS X 上常出现的一个问题是，PDF 文稿里隐藏的图层、图形被显示出来。如果查看复杂一些的 PDF，很可能在 Adobe Illustrator、OS X、iOS、Adobe Reader 下查看的效果都不一样。所以说，PDF 虽然一般被认为是跨平台的「安全格式」，不过也并不是 100% 保险。 Adobe Reader 的 iOS 版很可能没有使用 iOS 系统自带的 PDF 和矢量绘图 API，而是自己实现了一个，因此通常 Adobe Reader 显示复杂一些的 PDF 比使用 iOS 原生 API 解析 PDF 的 App 更准确一些。还有， 无论是使用 iOS 原生的 Quick Look 还是用 Adobe Reader 查看，渲染复杂的 PDF 有可能特别慢”。公司PDF的签章好像就是多图层，在文字的底下。</p>
</blockquote>
<p><strong>找了好久，终于找到了一个能读取多图层的PDF文件的框架 - MuPDF</strong></p>
<p>得出一个结论，使用Mupdf</p>
<p><a href="https://github.com/muennich/mupdf" target="_blank" rel="external">Mupdf github地址</a></p>
<p><a href="http://www.jianshu.com/p/5fd00530d4bb" target="_blank" rel="external">使用方法</a></p>
<h2 id="处理git库不允许上传大于100M的文件"><a href="#处理git库不允许上传大于100M的文件" class="headerlink" title="处理git库不允许上传大于100M的文件"></a>处理git库不允许上传大于100M的文件</h2><p>git库在上传大于50M的文件时会有警告，文件大于100M时直接拒绝push。要将这个文件从本地库和远程库中移除掉，再进行push操作。比如百度地图的导航静态库<code>libbaiduNaviSDK.a</code>就有100多M，做push操作时，直接报错了。</p>
<blockquote><p>remote: warning: Large files detected.<br>remote: error: File gasstation/gasstation/Classes/Main/Lib/BaiduNaviSDK/libbaiduNaviSDK.a is 108.63 MB; this exceeds Git@OSC’s file size limit of 100 MB<br>remote: error: hook declined to update refs/heads/master</p>
</blockquote>
<p>如果这个文件是最近一次commit的，并没有进行push操作，换句话说进行push操作的时候报错了。那么需要删除掉本地库中这个文件的commit记录再进行push</p>
<p>在终端中cd进项目目录，就是项目的<code>.git</code>文件的目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /Users/XXX(cd后面路径换成自己项目的路径)</div></pre></td></tr></table></figure>
<p>输入如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git rm --cached /Users/XXX/XXX/libbaiduNaviSDK.a (大文件的路径)</div><div class="line">git commit --amend -CHEAD</div></pre></td></tr></table></figure>
<p>到这一步这个大文件从commit记录中移除了，以后的commit也不会再commit它了。此时进行push即可</p>
<p>还有一种情况是你无数次commit了，也不知道哪次把这个大文件commit上了，在进行push的时候报错了。</p>
<p>这时需要将本地代码库回滚，回滚到某个commit之前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git reset --hard commit-id :回滚到commit-id，讲commit-id之后提交的commit都去除</div><div class="line"></div><div class="line">git reset --hard HEAD~3：将最近3次的提交回滚</div></pre></td></tr></table></figure>
<h2 id="删除苹果开发者平台Developer里的App-ID"><a href="#删除苹果开发者平台Developer里的App-ID" class="headerlink" title="删除苹果开发者平台Developer里的App ID"></a>删除苹果开发者平台Developer里的App ID</h2><p>删除苹果开发者平台Developer里的某个AppID本来是很容易的事情，点击Edit -&gt; Delete -&gt; 警示框中红色Delete即可。但是真实情况却坑的一逼……</p>
<p>Developer中的AppID对应项目中的Bundle id，是一个app的唯一标识，包括在App Store中，在各大第三方开放平台中。一般为了保证唯一性，采用公司域名反写＋app项目名的方式命名。</p>
<p>我经历过替换开发者账号的事。事情是这样的：开发某款app在上线AppStore当天，甲方觉得提供商名字不好(因为是个人开发者账号，显示的是人名拼音)要求下架，重新提供开发者账号提交。甲方是上帝，您高兴就好，反正$99不用我掏腰包。就这样上架第一天我亲手点了下架按钮，</p>
<p>问题就来了，Bundle id被旧的开发者帐号占用了，新的没法用了，我不想为了换个开发者帐号把Bundle id改了，毕竟牵扯好几个第三方平台呢。那就删除原来账号的Bundle id，删除的时候有如下提醒：</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160928-0.png?raw=true" alt="img"></p>
<p>在App Store上使用了，不能删除。我只好去iTunes Connect里删除了app（<strong>注意：此为大坑</strong>），问题依旧，只能求助苹果开发者平台的客服人员。</p>
<p>打苹果开发者客服电话: 4006 701 855 <a href="https://developer.apple.com/contact/phone/cn/" target="_blank" rel="external">全球电话支持</a>。坑爹的是，苹果客服人员告诉我删除不了，开发者平台中的Bundle id在app构建版本之后，不能修改或删除的。即便是你用该Bundle id发布的应用下架删除了，该Bundle id也会随着该应用永沉大海。不能删！不能改！</p>
<p>客服告诉我最佳的解决办法是迁移应用。将原账号的应用迁移到新账号上，应用所用到的Bundle id也会随之迁移过去。但是我把iTunes Connect里的应用删除了，那就没办法迁移了。摆在我面前的有两条路，第一：重新用旧账号打包提交审核通过，迁移应用到新账号，第二：改Bundle id。苹果客服人员对我如是说，客服诚不欺我啊！</p>
<h2 id="NSUserDefaults存储数组或字典报错"><a href="#NSUserDefaults存储数组或字典报错" class="headerlink" title="NSUserDefaults存储数组或字典报错"></a>NSUserDefaults存储数组或字典报错</h2><p>用NSUserDefaults存储数组或字典的时候报错，程序崩溃了，报错内容如下：</p>
<blockquote>
<p>Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘Attempt to insert non-property list object {xxxxxxxxxx} for key defaultsKey’</p>
</blockquote>
<p>是因为要存的数组或字典对象里存在类似<code>&quot;name&quot; = &quot;&lt;null&gt;&quot;</code>这样的字段，这样的字段不能被解析，所以会报错。</p>
<p>解决办法是将<code>&quot;name&quot; = &quot;&lt;null&gt;&quot;</code>换成<code>&quot;name&quot; = &quot;&quot;</code>，这种替换最好是服务端来做，如果服务端没做的话，移动端处理也可以，处理方式如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:oldDict];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *keyStr <span class="keyword">in</span> dict.allKeys) &#123;</div><div class="line">   <span class="keyword">if</span> ([[dict objectForKey:keyStr] isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</div><div class="line">       [dict setObject:<span class="string">@""</span> forKey:keyStr];</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       [dict setObject:[dict objectForKey:keyStr] forKey:keyStr];</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">"newDict = %@"</span>, dict);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;记录了在iOS开发中踩过的坑和一些问题解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文不断更新中…&lt;br&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://markmiao.com/tags/iOS/"/>
    
  </entry>
  
</feed>
