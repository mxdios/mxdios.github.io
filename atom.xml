<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mark Miao</title>
  <subtitle>Mark’s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://markmiao.com/"/>
  <updated>2017-07-27T09:54:08.000Z</updated>
  <id>http://markmiao.com/</id>
  
  <author>
    <name>Mark</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>macOS应用上架被拒</title>
    <link href="http://markmiao.com/2017/07/27/macosapprejected/"/>
    <id>http://markmiao.com/2017/07/27/macosapprejected/</id>
    <published>2017-07-27T08:26:58.000Z</published>
    <updated>2017-07-27T09:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是我开发的第一个macOS客户端，名字为<a href="http://markmiao.com/2017/07/26/stenonote/">速记</a>。是用swift3.0，面向Google开发，磕磕绊绊的写完这一两个界面，相比预想功能大概实现了50%，也算完整，没有完成到预想效果，便按耐不住上传App Store，日后迭代呗。</p>
<a id="more"></a>
<p>结果昨天上传，今天早上就被苹果爸爸拒了。一看被拒理由，哐哐哐列了四五条之多，一下子有点懵。详细看过之后，发现这些问题还是蛮不错的，都是我没注意到的，特此记录下来：</p>
<h2 id="问题1：应用程序的完整性"><a href="#问题1：应用程序的完整性" class="headerlink" title="问题1：应用程序的完整性"></a>问题1：应用程序的完整性</h2><p>问题描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Specifically, the app shows no response when click on the menubar extra icon.</div></pre></td></tr></table></figure>
<p>这个问题拒的我完全没脾气，因为点击一个按钮没有任何反应，苹果据此认为该应用没做完，我竟毫无反驳之力。</p>
<p>情况是这样的：这个<code>extra icon</code>，在有选中内容时，点击会弹出NSPopover，未选中内容时，点击没有任何反应，所以程序不完整。记住即便是空内容也要做提示处理！</p>
<h2 id="问题2：应用程序名称不统一"><a href="#问题2：应用程序名称不统一" class="headerlink" title="问题2：应用程序名称不统一"></a>问题2：应用程序名称不统一</h2><p>问题描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">We noticed that your app name to be displayed on the App Store does not sufficiently match the name of the app displayed when installed on macOS.</div><div class="line"></div><div class="line">iTunes Connect Name: 速记</div><div class="line">App Name when Installed: StenoNote</div><div class="line">App Name when Launched: 速记</div><div class="line">App Name in About/Hide/Quit Menu: 速记</div></pre></td></tr></table></figure>
<p>在iOS开发中，工程名和应用名是完全不同的，应用名可以在<code>Info.plist</code>里的<code>Bundle display name</code>中自定义。但是macOS不同，即便是在<code>Bundle display name</code>自定义了名字，在Dock上鼠标悬浮到应用上时和Launchpad里应用图标下显示的名字仍然是工程名。还有在Mac左上角苹果图标旁边的应用名也是工程名，即便是你在xib或storyboard里改了这里的文字，这里依旧不会变。</p>
<p>我并不知道如何修改这些名字，后来在<code>Info.plist</code>里修改了<code>Bundle name</code>，Mac左上角苹果图标旁边的应用名改变了，但是Dock上和Launchpad里面的没有变化。提交应用之后，这也成了被拒理由之一。</p>
<p>解决办法当然是统一应用名称：</p>
<p>在<code>TARGETS -&gt; Build Settings -&gt; Product Name</code>这里面自定义应用名称。</p>
<h2 id="问题3：权限配置问题"><a href="#问题3：权限配置问题" class="headerlink" title="问题3：权限配置问题"></a>问题3：权限配置问题</h2><p>问题描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Your app uses one or more entitlements which do not have matching functionality within the app. Apps should have only the minimum set of entitlements necessary for the app to function properly. Please remove all entitlements that are not needed by your app and submit an updated binary for review, including the following:</div><div class="line"></div><div class="line">com.apple.security.files.user-selected.read-only</div></pre></td></tr></table></figure>
<p>macOS客户端要想上架App Store，必须开启<code>App Sandbox</code>功能。这里面牵扯到一些权限配置：网络访问、硬件资源、联系人、定位、日历，还有文件和目录的访问。应用中不需要的权限一定不要打开，不然就会以上述理由被拒。</p>
<p>我不知道什么时候开启了<code>User Selected File</code>为<code>Read Only</code>，被拒了，马上改为<code>None</code>。</p>
<h2 id="问题4：黑暗模式"><a href="#问题4：黑暗模式" class="headerlink" title="问题4：黑暗模式"></a>问题4：黑暗模式</h2><p>问题描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The user interface of your app is not consistent with the macOS Human Interface Guidelines. Specifically:</div><div class="line"></div><div class="line">We found that when Dark Mode is enabled, the menu bar extra icons aren&apos;t visible.</div></pre></td></tr></table></figure>
<p>这个问题略惊，之前恍惚听过黑暗模式，从来没用过。启动黑暗模式是在：系统偏好设置 -&gt; 通用 -&gt; 勾选使用暗色菜单和Dock</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/2017-07-27-17-20-20.png" alt="设置黑暗模式"></p>
<p>黑暗模式下Dock和上方工具条都变为黑色半透明，工具条上的图标齐刷刷变为白色，而我的应用图标不见了…不见了…见了…了…</p>
<p>在stackoverflow找到一个问题解答：<a href="https://stackoverflow.com/questions/25379525/how-to-detect-dark-mode-in-yosemite-to-change-the-status-bar-menu-icon" target="_blank" rel="external">How to detect dark mode in Yosemite to change the status bar menu icon</a>。</p>
<p>设置分布式观察者，获取Mac模式变化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">DistributedNotificationCenter</span>.<span class="keyword">default</span>().addObserver(<span class="keyword">self</span>, selector: #selector(changeStatusBarImage(not:)), name: <span class="type">NSNotification</span>.<span class="type">Name</span>(rawValue: <span class="string">"AppleInterfaceThemeChangedNotification"</span>), object: <span class="literal">nil</span>)</div></pre></td></tr></table></figure>
<p>每次更改模式都会调用通知方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeStatusBarImage</span><span class="params">(not: Notification)</span></span> &#123;</div><div class="line">		<span class="built_in">print</span>(<span class="string">"change"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还可以使用下面方法获取当前Mac的模式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> dict = <span class="type">UserDefaults</span>.standard.persistentDomain(forName: <span class="type">UserDefaults</span>.globalDomain)</div><div class="line"><span class="keyword">let</span> style = dict?[<span class="string">"AppleInterfaceStyle"</span>]</div><div class="line"><span class="built_in">print</span>(style)<span class="comment">//是暗黑模式下style打印Optional(Dark)，普通模式下打印nil</span></div></pre></td></tr></table></figure>
<p>stackoverflow问题解答中有一个外链，说明了如果不是根据模式切换去更换复杂图片的话，仅是白变黑，黑变白，仅需要如下几行代码设置<code>NSStatusBar</code>的图片即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> image:<span class="type">NSImage</span> = <span class="type">NSImage</span>(named: <span class="string">"图片名称"</span>)!</div><div class="line">image.isTemplate = <span class="literal">true</span></div><div class="line">item.button?.image = image</div></pre></td></tr></table></figure>
<h2 id="问题5：无菜单重新打开主窗口"><a href="#问题5：无菜单重新打开主窗口" class="headerlink" title="问题5：无菜单重新打开主窗口"></a>问题5：无菜单重新打开主窗口</h2><p>问题描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The user interface of your app is not consistent with the macOS Human Interface Guidelines.</div><div class="line"></div><div class="line">Specifically, we found that when the user closes the main application window there is no menu item to re-open it.</div></pre></td></tr></table></figure>
<p>对于这个问题我是存在异议的，在点击关闭按钮后主窗口退出，点击Dock上的应用图标是可以唤起应用主窗口的。但是文中强调<code>menu item</code>，难道必须右键菜单里需要加上打开客户端主窗口的操作？</p>
<p>暂且在右键菜单里添加了打开客户端主窗口的功能：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDockMenu</span><span class="params">(<span class="number">_</span> sender: NSApplication)</span></span> -&gt; <span class="type">NSMenu</span>? &#123;</div><div class="line">   <span class="keyword">let</span> menu = <span class="type">NSMenu</span>()</div><div class="line">   <span class="keyword">let</span> menuItem = <span class="type">NSMenuItem</span>(title: <span class="string">"打开速记"</span>, action: #selector(openNoteViewController), keyEquivalent: <span class="string">"O"</span>)</div><div class="line">   menu.addItem(menuItem)</div><div class="line">   <span class="keyword">return</span> menu</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写这篇文章的时候，应用经过上述修改再一次提交审核，等待审核中，期待审核结果……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我开发的第一个macOS客户端，名字为&lt;a href=&quot;http://markmiao.com/2017/07/26/stenonote/&quot;&gt;速记&lt;/a&gt;。是用swift3.0，面向Google开发，磕磕绊绊的写完这一两个界面，相比预想功能大概实现了50%，也算完整，没有完成到预想效果，便按耐不住上传App Store，日后迭代呗。&lt;/p&gt;
    
    </summary>
    
      <category term="macOS开发" scheme="http://markmiao.com/categories/macOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="macOS" scheme="http://markmiao.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>速记 - 快速记录每一段文字</title>
    <link href="http://markmiao.com/2017/07/26/stenonote/"/>
    <id>http://markmiao.com/2017/07/26/stenonote/</id>
    <published>2017-07-26T08:54:02.000Z</published>
    <updated>2017-07-26T08:58:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>[速记] 是一款可以在工具栏快速记录一段文字的应用。也支持在应用窗口添加、删除、编辑记录的文本。我们支持的是迅速、便捷、一触即达，比便签更迅速，比日记更简约。</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20170726-161903.png" alt="速记 - 快速记录每一段文字"></p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>在工具栏上点击速记标识，可迅速弹出文本输入框，可快速记录文本内容。</li>
<li>在应用主窗口可快速编辑文本内容，无需保存操作，应用会自动存储更改后的内容。</li>
<li>在应用主窗口可点击加号按钮，快速创建一条记录，输入内容快速便捷。</li>
<li>强大的搜索功能，会实时检索搜索词组，快速将结果反馈到速记列表中。</li>
<li>速记信息，点击应用主窗口右上角按钮，可快速查看本条信息的字数及创建时间。</li>
</ul>
<h2 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h2><p>如果您对[速记]有什么意见或建议，请联系i@markmiao.com 我们会认真对待每一次反馈，将[速记]做的更好。</p>
<p>如果您喜欢该应用，请在App Store留下宝贵的评论。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[速记] 是一款可以在工具栏快速记录一段文字的应用。也支持在应用窗口添加、删除、编辑记录的文本。我们支持的是迅速、便捷、一触即达，比便签更迅速，比日记更简约。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oalg33nuc.bkt.clouddn.com/QQ20170
    
    </summary>
    
      <category term="macOS开发" scheme="http://markmiao.com/categories/macOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="应用" scheme="http://markmiao.com/tags/%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>ipa重签名</title>
    <link href="http://markmiao.com/2017/07/26/ipachongqianming/"/>
    <id>http://markmiao.com/2017/07/26/ipachongqianming/</id>
    <published>2017-07-26T02:58:03.000Z</published>
    <updated>2017-07-26T03:11:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中分发内测应用是经常遇见的，常见的方式有：TestFlight，用企业级开发者账号，搜集UDID打包等方式，每种方式都各有利弊。</p>
<p>由于公司有企业级开发者账号，所以平常应用内测比较简单：直接拿企业级账号打包.ipa，将.ipa发布到内测平台（比如<a href="https://www.pgyer.com" target="_blank" rel="external">蒲公英</a>，<a href="https://fir.im/" target="_blank" rel="external">fir.im</a>），测试人员直接下载安装就可，只是第一次需要信任一下企业级证书。</p>
<a id="more"></a>
<p>在工作中，有时候我们需要分发某个app的.ipa包，并没有改app的源码，无法用自己的账号打包。这时就用到了重签名。</p>
<p>其实ipa重签名的应用场景很多，比如App Store上的付费应用，可以使用自己的开发者账号，其.ipa包重新签名，就可以安装了。各大app助手平台就是这么做的。注意直接从App Store下载的应用是加壳的，无法直接重新签名，必须砸壳。<a href="http://iosre.com/" target="_blank" rel="external">iOSRE逆向</a></p>
<h2 id="iReSign"><a href="#iReSign" class="headerlink" title="iReSign"></a>iReSign</h2><p><a href="https://github.com/maciekish/iReSign" target="_blank" rel="external">iReSign</a>是一个重签名工具</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/2017-07-25-19-21-04.png" alt="iReSign"></p>
<p>操作步骤：</p>
<ol>
<li>选择.ipa包的路径</li>
<li>选择<code>embedded.mobileprovision</code>文件路径。<code>embedded.mobileprovision</code>是用于打包的配置文件<code>Provisioning Profiles</code>。可以直接在<code>Certificates, Identifiers &amp; Profiles</code>中下载，注意下载之后需要将名字设置为<code>embedded.mobileprovision</code>。也可以在之前用该文件打包过的.ipa中找：解压.ipa -&gt; Payload -&gt; xx.app显示包内容 -&gt; <code>embedded.mobileprovision</code></li>
<li>网上有资料说entitlements.plist不需要填写。我试过不填写或填写，我按照本文<a href="http://www.olinone.com/?p=198" target="_blank" rel="external">iOS证书及ipa包重签名探究</a>的方式写的.plist文件。</li>
<li>选中修改ID，填写修改的appid</li>
<li>选择证书，下拉列表会显示mac上有的证书。</li>
<li>点击重新签名！</li>
</ol>
<p>结果是失败了。</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/6111501034232_.pic.jpg" alt="iResign运行结果"></p>
<p>错误信息如下，可以查看该错误的<a href="https://github.com/maciekish/iReSign/issues/99" target="_blank" rel="external">IResign上的issues</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[General] Error Domain=NSCocoaErrorDomain Code=3840 &quot;Unexpected character s at line 1&quot; UserInfo=&#123;NSDebugDescription=Unexpected character s at line 1, kCFPropertyListOldStyleParsingError=Error Domain=NSCocoaErrorDomain Code=3840 &quot;Unexpected &apos;;&apos; or &apos;=&apos; after key at line 1&quot; UserInfo=&#123;NSDebugDescription=Unexpected &apos;;&apos; or &apos;=&apos; after key at line 1&#125;&#125;</div></pre></td></tr></table></figure>
<p>另外还有一个重签名工具：<a href="https://github.com/DanTheMan827/ios-app-signer" target="_blank" rel="external">ios-app-signer</a></p>
<p><a href="http://www.iosugar.com/2017/04/10/Practice-articles-iOS-application-re-signature/" target="_blank" rel="external">实践篇：iOS 应用重签名(上)</a>这篇文章介绍了entitlement文件如何写，ios-app-signer的使用。我没有测试该方法是否可行。</p>
<h2 id="使用sigh脚本"><a href="#使用sigh脚本" class="headerlink" title="使用sigh脚本"></a>使用sigh脚本</h2><p>在iReSign失败后，我在网上找到使用sigh脚本的方式来重签名。</p>
<ol>
<li>安装神器brew，没有安装的看这里：<a href="https://brew.sh/" target="_blank" rel="external">Homebrew</a></li>
<li>安装ruby，命令：<code>brew install ruby</code></li>
<li>安装sigh，命令：<code>sudo gem install sigh</code>，过程比较漫长。</li>
</ol>
<p>安装sigh脚本后，开始进行重签名，步骤如下</p>
<ol>
<li>在终端输入<code>sigh resign</code>，回车</li>
<li>把要签名的ipa文件拖到窗口上，回车</li>
<li>填写用来签名的证书名，回车</li>
<li>把项目的配置文件embedded.mobileprovision文件拖到窗口上，回车</li>
<li>好了，resign脚本会自动更改bundel id，签名并重新打包。</li>
</ol>
<p>注意ipa包名不要有中文。如果应用有多个targetes无法用上述方式重签名。参考文章：<a href="http://www.jianshu.com/p/3f57d51f770a" target="_blank" rel="external">iOS的ipa重签名</a></p>
<p>我按照如上步骤操作，成功使用企业级证书打包，上传到蒲公英内测平台上，也显示的是企业级应用，但是无法安装，提醒无法下载app，我手机上没有从App Store上下载安装该应用，排除了无法覆盖问题。</p>
<p>iOS9以后，企业级应用不会出现信任按钮，如果ipa包和网页的<code>bundle ID</code>不匹配，就无法安装。在iOS9之前是没有检测的。详情见大神iOS程序犭袁的文章<a href="https://github.com/ChenYilong/iOS9AdaptationTips#3%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%88%86%E5%8F%91" target="_blank" rel="external">ios9适配系列教程</a></p>
<h2 id="我操作成功的办法"><a href="#我操作成功的办法" class="headerlink" title="我操作成功的办法"></a>我操作成功的办法</h2><p>经过了无数次测试sigh脚本签名方式，最后即将放弃的时刻成功了。</p>
<ol>
<li>将需要重签的.ipa文件和<code>embedded.mobileprovision</code>配置文件放到同一个文件夹下。注意路径和文件名中不要出现中文，配置文件名一定要是<code>embedded</code>。</li>
<li>在终端中cd到该路径下</li>
<li>使用sigh脚本：<code>sigh resign</code>回车，运行结果跟上面是不一样的，会直接出现<code>Signing Identity:</code>让我填证书名。上述方式应该是第二步拖ipa文件到窗口，<code>Path to ipa file:</code></li>
<li>在<code>Signing Identity:</code>上面会出现一串可用的<code>identity</code>，这里要输入这些<code>identity</code>的十六进制串。回车</li>
<li>成功了：<code>Successfully signed 路径/xxx.ipa!</code>原来文件夹中的.ipa已经被重签名了。上传到蒲公英内测平台，完全可以下载使用。</li>
</ol>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20170726-104243.png" alt="操作步骤"></p>
<p>本文涉及到的知识点都是从网上Google的，感谢网友们分享的资料，还涉及的一些参考资料：</p>
<p><a href="https://objccn.io/issue-17-2/" target="_blank" rel="external">代码签名探析</a></p>
<p><a href="http://www.hudongdong.com/skill/363.html" target="_blank" rel="external">mac用终端对ipa包重新签名</a></p>
<p><a href="http://www.jianshu.com/p/0d460b52ce96" target="_blank" rel="external">iPhone 如何不越狱安装越狱软件</a></p>
<p><a href="http://www.jianshu.com/p/1ef0dbdac653" target="_blank" rel="external">企业证书重新签名ipa</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在工作中分发内测应用是经常遇见的，常见的方式有：TestFlight，用企业级开发者账号，搜集UDID打包等方式，每种方式都各有利弊。&lt;/p&gt;
&lt;p&gt;由于公司有企业级开发者账号，所以平常应用内测比较简单：直接拿企业级账号打包.ipa，将.ipa发布到内测平台（比如&lt;a href=&quot;https://www.pgyer.com&quot;&gt;蒲公英&lt;/a&gt;，&lt;a href=&quot;https://fir.im/&quot;&gt;fir.im&lt;/a&gt;），测试人员直接下载安装就可，只是第一次需要信任一下企业级证书。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://markmiao.com/tags/iOS/"/>
    
      <category term="ipa" scheme="http://markmiao.com/tags/ipa/"/>
    
  </entry>
  
  <entry>
    <title>东戴河之旅</title>
    <link href="http://markmiao.com/2017/07/22/dongdaihezhilv/"/>
    <id>http://markmiao.com/2017/07/22/dongdaihezhilv/</id>
    <published>2017-07-22T06:22:18.000Z</published>
    <updated>2017-07-26T03:19:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017年5月27日，端午节假期开始前夕，我们提前开启了假期模式，跑到东戴河浪了一圈。</p>
<p>虽然刚入夏没多久，但是北京早已没有了春天的影子，夏天像头疯牛一样来的凶猛。天气好点的中午，堪比六月三伏。今天是7月22日了，一篇游记拖了两个月，这拖延症也是没谁了。到今天我才发现，觉得初夏天气热，我还是too young了。</p>
<a id="more"></a>
<p>“这么热的天，咱们出去玩吧？”我分明记得春天的时候，晓说：“这天不冷不热的，咱们出去玩吧？”真是啥天儿都适合出去玩。</p>
<p>“咱们不是刚去蓬莱玩回来吗？”</p>
<p>“别跟我提蓬莱！端午节前，姐姐他们去东戴河，咱们也一起去吧？”</p>
<p>听出来了吗？这虽然是问句，在征求我的意见，但却是道单选题。</p>
<p>“好！”社会主义新生活，就是要这样的民主与和谐。何况我最近也忙的有点想偷闲了。</p>
<p>我们计划27号早上出发，28号晚上回来，错开端午节假期出行高峰。姐姐他们26号自驾出行，我们27号坐动车去。虽然已经错开了假期，火车票还是早就售罄了，至少12306网站上是这么显示的。这些天我比较忙，晓负责酒店住宿和游玩攻略，我挂个软件抢票。</p>
<p>由于最近比较忙，在出发的早上，纠结再三还是把电脑带上了，打算在火车上敲会儿代码，毕竟来回六个小时车程呢。这就是上学时放假带书的怪圈：放假一定带书，带书一定不看，下次一定还带。毕业这么些年了，这个怪圈还没走出来。计划是美好的，现实的残酷的，火车上来回晃，一敲代码就晕。奇怪的是看动漫就不晕，发大志向带上的电脑，用来看了一路的《进击的巨人2》。</p>
<p>10:20到了东戴河，没有几个人下火车，我们下车的地方离出站口最远，不一会儿整个站台就剩我们俩了。四周望去全是野地，跟我们县火车站似的。晓说：“咱们没下错站吧。”我心里也略慌：“没下错吧，是东戴河站啊。”远处电梯口的工作小哥喊道：“快点，一会儿锁门了。”</p>
<p>我问那小哥：“现在还是淡季吧，人怎么这么少？”小哥告诉我们：“恩，现在还有点凉，不能下水，再过几天人就多了。”小哥说锁门不是骗我们的，出站口的人果然已经准备锁门了。小哥忙喊了一句：“等会儿，我这还俩人呢。”</p>
<p>出了火车站，除了一些黑车司机和农家院招揽生意的之外，游客只有我们俩。姐他们昨天已经到东戴河了，过了一会儿姐和哥开车过来接我们。在车上，姐已经按耐不住吐槽他们昨天的囧途囧事：开车压坏了海滩上一块木板赔了人200；车陷进沙滩里找人弄出来花了200；食堂吃饭吃出一只苍蝇恶心了一天；在房车插座上插电蚊香把插座烧了；昨天温度还特别低，在海边住冻得要死。这悲催经历，感觉跟我们去蓬莱那趟有的一拼了。</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/WX20170722-142010@2x.png" alt="房车"></p>
<p>住的地方是海边海滩上的房车，从火车站到海边房车那大概十多分钟的车程。第一次住房车这种高大上的地方，看啥新鲜。房车是类似一个白色大箱子的车厢，两边有窗户。房车虽然也有轮子，但是是固定在海滩上的，不能随便移动。每个房车周围都用篱笆围起来一个小院，有一张桌子和几把椅子。房车内一应俱全，沙发、床、电视、冰箱、煤气灶、卫生间、淋浴等等，不知道是不是因为淡季的原因，部分设备就是个摆设，比如煤气灶。总归来说，住宿环境还是挺好的，至少目前我是这么认为的。</p>
<p>今天来这里玩的人还是特别少，姐说昨晚海滩上这一整排房车只有他们这一辆房车的灯是亮的。我们今天来算是第二家，海滩上远远望去也没有多少人，今天气温宜人，明天又是端午节假期的第一天，这两天估计人会陆陆续续的多起来。</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/231500702179_.pic.jpg" alt="东戴河的海滩"></p>
<p>收拾停当，自然是迫不及待的跑向大海了。脚踩沙滩，享受着海风拂面，东戴河的气温明显比北京的低一些，在北京的那种闷热烦躁早就一扫而光。这里海滩上的沙子特别细，被太阳晒得有点微热，脚踩上去非常干爽。稍微用力转转脚往深了踩踩，就能触及到湿沙子，那种凉爽沁脚心的感觉简直爽透了，特别是对于我们这种在北京燥热了半个初夏的人来说。</p>
<p>东戴河的海水特别清澈，比较来说我在烟台时去过的海边就太混浊了，在这里远远望去真有点碧海蓝天的感觉。姐说东戴河这里的海滩算是比较原始的了，没有被过分开发。有时候还能捡到一些比较漂亮的小贝壳或小海螺，当然不可能有商店里卖的那种大个的。想捡到那种漂亮海螺，只能去电视里的海滩。</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/271500702316_.pic.jpg" alt="海边"></p>
<p>最开心的莫过于姐姐家的小宝宝沫沫了，沫沫在沙滩上一会爬来爬去，一会儿抓沙子，一会儿一屁股做沙滩上，拽着一根不知道从哪里薅过来的干草。晓拿细沙子埋他的小脚丫，一会儿给埋没了，他楞一会儿，一下子抽出来，嘎嘎直乐。姐他们连风筝都带来了，我体验了一把在海边放风筝的感觉，太自由了，根本不用担心挂树上或者和其他风筝缠在一起，海风也格外的赏脸，不大不小，风筝刚好飞起来。一下子线都放光了，极目望去都看不到风筝的本来面目了，其实那是一只卖萌的大虫子。沫沫挺喜欢看我放风筝的，指着风筝乐呢。</p>
<p>所有人来海边必做的事是寻宝。我和晓穿着拖鞋，踩着海水，低着头，仔细搜索，期盼着这一浪一浪地能推上来一只漂亮的贝壳或者海螺，或者是一只运气不好的海蟹，倒霉催的海虾之类的。其实现实很难如我们所愿，倒是找到了一些还看得过去的小贝壳，用我的话说：“没有让我眼前一亮的东西。”晓说：“你适合去看电焊。”姐姐他们昨天也搜寻过好几圈，叔叔阿姨他俩今天早上四五点钟就起来赶海，最终都收获寥寥，都是几块造型奇特的石头，或者长得奇形怪状的贝壳。虽然没什么收获，但是这种悠闲还是令人满足。</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/301500702443_.pic_hd.jpg" alt="海滩"></p>
<p>晚上的重头戏是孔明灯。这是我第一次放孔明灯，真是个耐心细致的技术活，也真难为晓这种急脾气能耐心等着孔明灯慢慢撑起来，缓缓送出去。我亲自拆了一个孔明灯，并写下了我的愿望——挣钱，并尽量耐心的去放我人生中第一个孔明灯。在呼呼的海风下，点了半天才把蜡点着，打火机都烧坏了。两手撑着灯罩，慢慢等它鼓起来，鼓起一点，被海风吹下去一点，鼓一点，吹一点。晓说：“你放低点。”我往低了一放，放的太低了，蜡一下子粘到沙粒了。纠结了半天，好不容易鼓的差不多了，轻轻送出去，往上飞一点，往下落一点，飞一点，落一点，一跳一跳地沿着海岸线就跑了，这个熊灯！这一会儿的功夫，晓他们都放出去仨了。我肯定不甘心，不能就这么放任它跑了呀，非得飞起来不可。我就追着我的熊灯跑，它就跳，我就追。歪歪斜斜，一上一下，沿着海岸线，也不飞起来，也不落下去，也不掉海里自杀，也不烧灯罩自燃，逗我呢？就这样我追出去得有一百多米远，晓喊我：“赶紧回来吧！”难道是我的愿望太重了？我这得挣多少钱呐？我的耐心被这个熊灯彻底磨没了，捧起一把沙子给扑灭了，让你跳！我人生中第一个孔明灯，就这么把我调戏恼了。</p>
<p>夜晚的经历注定要给这场旅行加一点不完美的插曲。</p>
<p>放完孔明灯，天完全黑了，海边的夜，黑的彻底，不像城市里，再黑的夜都有明亮的灯。回到房车，发现有两盏灯不亮了，电视也打不开了，我匆匆洗了个澡发现热水也没了。什么玩意？花那么多钱就给我整个这个？开心了一整天，到了要睡觉了，整了这么一出。</p>
<p>我给客服打电话，客服说：“这么晚电工都下班了，这里就我一个人，我也整不了啊。”“整不了就换个房车。”我没耐心的说。客服说：“房车都预订出去了。”我有点火了，我们从姐姐他们住的房车走过来的时候，一眼望去，几十辆房车只有三四家亮着灯，你告诉我都订出去了？我说：“外面那么多黑着灯的，你告诉我都订出去了？他们今晚来住吗？”客服说：“明天会来。”“明天再说明天的，今晚你先给我们解决。”客服说：“我给你找找有没有空房，一会儿给您回电话。”</p>
<p>十多分钟过去了，没动静，我给打过去之后客服说：“有一套，您确定要换吗？”“换！”反正我们也没多少东西。换了一辆房车，发现没热水，我放了半天都没有。我又给客服打电话：“这个房车没热水，怎么回事？”客服说：“没烧水，您确定今晚要用吗？要不明天再用？”我彻底火了：“你这不废话吗？我得洗漱啊，明天我都退房走了，洗个屁！”客服没办法地说：“好吧，我找人给您弄一下。”这明显没把我们当上帝啊！折腾了一宿，生了一肚子气，最终也终于能安然入睡了。</p>
<p>第二天本打算早起去赶海，没起来，醒了就七八点钟了。早餐是去食堂吃的，就是前天姐姐他们吃出苍蝇的地儿。房车住宿还提供了食堂的三餐餐券，但是食堂离的很远，在一个集装箱住宿的地方，开车去挺近，走着去就有点远了。自从姐姐说他们吃出苍蝇，我们的餐券就没再用过。早餐都是馒头粥，相对干净。</p>
<p>吃完早餐，哥和叔叔阿姨他们开车回去了，我和晓打算逛逛待会儿沿着海岸线走回去。吃饭的时候，我们看到食堂附近有一片礁石，一直延伸到海里面。我们过去一看原来是建筑废料，都是大块的混凝块，上面沾满了贝壳残渣，还有好多小生蚝，大的都被人撬走了，搜索了半天也没什么收获。沿着海边一边走一边找宝贝，最终找到了一串青口贝，几块粘在一起的生蚝，几个漂亮的扇贝，也算收获颇丰了。</p>
<p>到了中午该退房了，姐姐他们退了房就自驾回去了，我和晓是今晚8点多的动车，当时买票的时候只有晚上8点这一趟车还有票。等到晚上8点确实太无聊的，我又看了一下票，发现各个时间段的票都很富余嘛，于是愉快地改签到下午三点四十多。</p>
<p>姐姐他们自驾回京了，我和晓对望一眼，去哪呢？“走，去止锚湾！”姐走之前给我们的建议，可以去止锚湾玩玩。这边荒凉到打车都难，一位发售楼传单的大哥看我们找车，主动搭讪说：跟他去看一眼他们的楼盘，然后免费带我们去止锚湾。我乐了，说：“我们时间紧，您拉趟私活吧，我给钱。”</p>
<p>到了止锚湾，发现这边可比房车那边好玩的多多了，不仅有好玩的还有好吃的。这边的海滩延伸特别长，走进去好远，水都没补过膝盖。都过中午了，先吃顿好吃的。我问一个在海边卖东西的大哥：“路边上这几家海鲜餐馆哪家比较好吃？”大哥说：“都可以，现在没有那种吃完宰客的行为了，放心吃吧。”我一愣，反应过来了，说的是青岛天价大虾那种情况呀。我们随便找了一家，点了点蛏子、花蛤、鱿鱼等海鲜，便宜实惠还好吃。</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/261500702315_.pic.jpg" alt="止锚湾"></p>
<p>吃完海鲜就去下海淘活海鲜了，为此还在刚才那大哥摊铺上买了两双凉鞋，两把塑料铲子（怕买铁的带不上动车）。下海就是一顿乱瞅，还别说这临走之前还真是收获丰富。透过清澈的海水都能看到奔跑的寄居蟹，只要看到就别想逃出我的旋风塑料铲。不仅有寄居蟹，还有小的皮皮虾、小螃蟹等。海边摊铺上还有卖吸筒的，就像小孩玩的呲水筒一样，据说改装之后可以在海底淤泥里吸皮皮虾，我们看到一个人拎了一小桶皮皮虾，说全是拿这玩意吸出来的。我们乐此不疲的玩了两个多小时，捉到一只方形长眼睛红螃蟹，圆形大肚子球螃蟹（我实在不知道这两种蟹的名字），还有若干寄居蟹和小皮皮虾。用矿泉水瓶装着，带它们回北京。</p>
<p>天也热了，人也多了，我们也玩累了。海边上人越来越多，开始有人下海游泳了，我们也准备回去了。在海边买了一包大樱桃，卖樱桃的老板帮我们叫了一辆车去火车站。进站时又遇到那位带我们出站的小哥，看到我们笑了，说：“这么快就走了。”我笑着说：“嗯，走了。”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年5月27日，端午节假期开始前夕，我们提前开启了假期模式，跑到东戴河浪了一圈。&lt;/p&gt;
&lt;p&gt;虽然刚入夏没多久，但是北京早已没有了春天的影子，夏天像头疯牛一样来的凶猛。天气好点的中午，堪比六月三伏。今天是7月22日了，一篇游记拖了两个月，这拖延症也是没谁了。到今天我才发现，觉得初夏天气热，我还是too young了。&lt;/p&gt;
    
    </summary>
    
      <category term="记事" scheme="http://markmiao.com/categories/%E8%AE%B0%E4%BA%8B/"/>
    
    
      <category term="生活" scheme="http://markmiao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="游记" scheme="http://markmiao.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发笔记二</title>
    <link href="http://markmiao.com/2017/07/06/iOStwo/"/>
    <id>http://markmiao.com/2017/07/06/iOStwo/</id>
    <published>2017-07-06T07:27:51.000Z</published>
    <updated>2017-07-06T07:29:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS编译优化策略Optimization-Level"><a href="#iOS编译优化策略Optimization-Level" class="headerlink" title="iOS编译优化策略Optimization Level"></a>iOS编译优化策略Optimization Level</h2><p>开发汉信码扫描功能时，扫描个别汉信码，<code>Release</code>环境下会闪退，<code>Debug</code>环境下正常。没有找到崩溃原因，暂时更改<code>Optimization Level</code>下的<code>Release</code>为<code>None[-O0]</code>，这样<code>Release</code>下也会和<code>Debug</code>一样，对代码没有优化操作。</p>
<a id="more"></a>
<p>更改位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TARGETS -&gt; Build Settings -&gt; Optimization Level -&gt; Release  选择`None[-O0]`</div></pre></td></tr></table></figure>
<p><a href="https://gcc.gnu.org/onlinedocs/gnat_ugn/Optimization-Levels.html" target="_blank" rel="external">Optimization Level官方解释</a></p>
<h2 id="跳转京东客户端某商品详情页"><a href="#跳转京东客户端某商品详情页" class="headerlink" title="跳转京东客户端某商品详情页"></a>跳转京东客户端某商品详情页</h2><p>iOS9以后，app内打开其他app需要在<code>Info.plist</code>里添加<code>LSApplicationQueriesSchemes</code>白名单。</p>
<p>跳转京东客户端需要增加京东的URL Scheme：<code>openapp.jdmobile</code></p>
<p><a href="http://www.jianshu.com/p/195b17052925" target="_blank" rel="external">iOS URL Scheme 大全(快速启动)</a></p>
<p>首先要判断手机里是否安装京东客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;openApp.jdMobile://&quot;]]) &#123;</div><div class="line">		//安装了</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跳转京东客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;openApp.jdMobile://&quot;]];</div></pre></td></tr></table></figure>
<p>跳转京东客户端某商品详情页：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *openUrl = @&quot;openapp.jdmobile://virtual?params=%7B%22sourceValue%22:%220_productDetail_97%22,%22des%22:%22productDetail%22,%22skuId%22:%2299999999%22,%22category%22:%22jump%22,%22sourceType%22:%22PCUBE_CHANNEL%22%7D&quot;;</div><div class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:openUrl]];</div></pre></td></tr></table></figure>
<p>注意：openUrl字符串要原封不动的拷贝到应用中使用，里面的%22、%7等保持原样，不要转义。中间部分的<code>99999999</code>是京东的商品编号：<code>defSkuID</code>，跳转到该商品的详情中。</p>
<h2 id="OC与JavaScript交互"><a href="#OC与JavaScript交互" class="headerlink" title="OC与JavaScript交互"></a>OC与JavaScript交互</h2><p>在APP内使用UIWebView展示网页，有时候需要和网页进行功能交互和数据传递。</p>
<p>最简单的一种交互是使用<code>UIWebView</code>的Delegate方法拦截webView的加载地址，和给定的地址匹配，如果匹配则不允许加载，并跳转到指定控制器，如果不匹配则允许加载。</p>
<p>拦截加载地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)webView:(UIWebView*)webView shouldStartLoadWithRequest:(NSURLRequest*)request navigationType:(UIWebViewNavigationType)navigationType &#123;</div><div class="line">    NSURL *url = [request URL];</div><div class="line">    NSLog(@&quot;加载地址 = %@&quot;, url);</div><div class="line">    return YES;//return YES允许加载，return NO不允许加载</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>iOS7以后，苹果推出了<code>JavaScriptCore</code>，用它可以直接完成oc和js之间的交互通信。下面介绍利用代理实现js调用oc中的方法，并完成数据传递。</p>
<p>第一步：在加载UIWebView的控制器中创建<code>JSExport</code>的协议，并写入和js约定好的方法，方法名要一致。该控制器遵守协议，并实现协议方法，完成webView和该控制器的交互。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">#import &lt;JavaScriptCore/JavaScriptCore.h&gt;//导入JavaScriptCore</div><div class="line"></div><div class="line">@protocol JSObjcDelegate &lt;JSExport&gt; //创建协议，写入协议方法。方法名必须和js内中一致，这些方法在js中属于对象SafetyObj下的</div><div class="line">//方法1：js调用oc中的方法</div><div class="line">- (void)fnJumpScan;</div><div class="line">//方法2：js调用oc中的方法，并要求得到某个返回值</div><div class="line">- (NSString *)fnGetCustomData;</div><div class="line">//方法3：js调用oc中的方法，并传递过来一个参数</div><div class="line">- (void)fnSaveCustomData:(NSString *)callString;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface ViewController : UIViewController&lt;UIWebViewDelegate,JSObjcDelegate&gt;</div><div class="line"></div><div class="line">@property(nonatomic,weak)UIWebView *webView;</div><div class="line">@property (nonatomic, strong) JSContext *context;//js运行环境</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>第二步：在网页加载完毕时，获取js运行环境，并且设置方法对象的代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView &#123;</div><div class="line">    self.context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</div><div class="line">    self.context[@&quot;SafetyObj&quot;] = self;//将自身设置为js对象的代理</div><div class="line">    self.context.exceptionHandler = ^(JSContext *context, JSValue *exception) &#123;</div><div class="line">        context.exception = exception;</div><div class="line">        NSLog(@&quot;异常信息 = %@&quot;, exception);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三步：实现代理方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)fnJumpScan &#123;</div><div class="line">    NSLog(@&quot;点击了jumpScan&quot;);</div><div class="line">&#125;</div><div class="line">- (NSString *)fnGetPostion &#123;</div><div class="line">    return @&quot;1234&quot;;</div><div class="line">&#125;</div><div class="line">- (void)fnSaveCustomData:(NSString *)callString &#123;</div><div class="line">    NSLog(@&quot;callString = %@&quot;, callString);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;iOS编译优化策略Optimization-Level&quot;&gt;&lt;a href=&quot;#iOS编译优化策略Optimization-Level&quot; class=&quot;headerlink&quot; title=&quot;iOS编译优化策略Optimization Level&quot;&gt;&lt;/a&gt;iOS编译优化策略Optimization Level&lt;/h2&gt;&lt;p&gt;开发汉信码扫描功能时，扫描个别汉信码，&lt;code&gt;Release&lt;/code&gt;环境下会闪退，&lt;code&gt;Debug&lt;/code&gt;环境下正常。没有找到崩溃原因，暂时更改&lt;code&gt;Optimization Level&lt;/code&gt;下的&lt;code&gt;Release&lt;/code&gt;为&lt;code&gt;None[-O0]&lt;/code&gt;，这样&lt;code&gt;Release&lt;/code&gt;下也会和&lt;code&gt;Debug&lt;/code&gt;一样，对代码没有优化操作。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://markmiao.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>排班 - 上班时间，一目了然</title>
    <link href="http://markmiao.com/2017/04/05/%E6%8E%92%E7%8F%AD/"/>
    <id>http://markmiao.com/2017/04/05/排班/</id>
    <published>2017-04-05T09:18:42.000Z</published>
    <updated>2017-04-05T09:38:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>排班 - 是一款以日历为基础，记录上班时间的应用。主要针对实行倒班制，上班时间不固定的用户。简单的两步设置，便能准确地在日历上排列出上班时间，查看方便，一目了然。不用在台历上拿笔标记，也不用时时去看主管给你的上班安排。让你告别上班时间不确定的痛苦。</p>
<a id="more"></a>
<p><img src="http://oalg33nuc.bkt.clouddn.com/seticonapp.png" alt=""></p>
<h2 id="获取排班"><a href="#获取排班" class="headerlink" title="获取排班"></a>获取排班</h2><p>iOS: <a href="https://itunes.apple.com/cn/app/id1221228242?mt=8" target="_blank" rel="external">App Store下载</a></p>
<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ul>
<li><p>丰富而简洁的日历信息，包含<code>公历</code>、<code>农历</code>以及各种<code>节日</code>、<code>节气</code>、<code>节假日</code>、<code>纪念日</code>，适合每一位用户查看。</p>
</li>
<li><p><strong>添加排班：</strong>设置<code>坐标时间</code> -&gt; 添加<code>循环班次</code> -&gt; 保存<code>班表</code>，添加的班次会立刻出现在日历上。可选择<code>无限循环</code>、<code>指定时间内循环</code>、<code>按月循环</code>排班。可编辑<code>班表名称</code>。</p>
</li>
<li><p><strong>无线循环排班：</strong><code>坐标时间</code>是开始循环的时间，默认从今天开始。会以这个时间为坐标，向前、向后无限循环设置的<code>循环班次</code>。</p>
</li>
<li><p><strong>指定日期内循环排班：</strong>给<code>循环班次</code>设置一个<code>日期范围</code>，会从<code>开始日期</code>开始执行<code>循环班次</code>，一直循环到<code>结束日期</code>。这个日期范围之外无班次设置。</p>
</li>
<li><p><strong>按月循环排班：</strong>不需要时间设置，从每月的<code>1号</code>开始执行<code>循环班次</code>，循环到每月的最后一日。每个月都是独立循环的。</p>
</li>
<li><p><strong>循环班次：</strong>循环班次可长按拖动排序，指定删除某个班次，一键清空所有添加的班次。</p>
</li>
<li><p><strong>待选班次：</strong>待选班次预设了6个，可添加删除。可以在设置中还原待选班次。</p>
</li>
<li><p><strong>选择班表：</strong>可以添加多个班表，这里显示了添加的所有班表名称，选中确认显示在日历中。可以左滑删除。</p>
</li>
<li><p><strong>班表统计：</strong>统计每个月，各种班次各上了几天班。一键查看方便快捷。</p>
</li>
<li><p><strong>备忘列表：</strong>长按日历中的某天，或点击今日信息中的备忘，可添加备忘信息。所有的备忘信息会显示在这里，可以左滑删除。</p>
</li>
<li><p><strong>其他设置：</strong>可以设置日历的各种显示方式，可以还原待选班次，清空添加的备忘记录和班表。</p>
</li>
<li><p><strong>自定义班次：</strong>当待选班次没有合适的，可以自己添加待选班次，指定喜欢的班次颜色。</p>
</li>
<li><p><strong>修改某一天的班次：</strong>长按日历中的某天，或者点击今日信息中的排班，可修改这一天的班次。</p>
</li>
</ul>
<h2 id="反馈与支持"><a href="#反馈与支持" class="headerlink" title="反馈与支持"></a>反馈与支持</h2><p>如果您有自己的排班需求和对应用的意见或建议，请联系：i@markmiao.com 我们会认真对待每一次反馈，将[排班]做的更好。</p>
<p>如果您喜欢该应用，请在App Store留下宝贵的评价。如果<code>排班</code>对您有一点点用处的话，请支持我们：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="http://oalg33nuc.bkt.clouddn.com/2017-04-05-17-25-23wx.png" alt="微信"></th>
<th style="text-align:center"><img src="http://oalg33nuc.bkt.clouddn.com/2017-04-05-17-24-59zfb.png" alt="支付宝"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><strong>感谢下列开源项目</strong></p>
<p><a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">fmdb</a></p>
<p><a href="https://github.com/yuantiku/YTKKeyValueStore" target="_blank" rel="external">YTKKeyValueStore</a></p>
<p><a href="https://github.com/cyanzhong/LunarCore" target="_blank" rel="external">LunarCore</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排班 - 是一款以日历为基础，记录上班时间的应用。主要针对实行倒班制，上班时间不固定的用户。简单的两步设置，便能准确地在日历上排列出上班时间，查看方便，一目了然。不用在台历上拿笔标记，也不用时时去看主管给你的上班安排。让你告别上班时间不确定的痛苦。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="应用" scheme="http://markmiao.com/tags/%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Widget开发</title>
    <link href="http://markmiao.com/2017/04/02/Widget%E5%BC%80%E5%8F%91/"/>
    <id>http://markmiao.com/2017/04/02/Widget开发/</id>
    <published>2017-04-02T12:09:00.000Z</published>
    <updated>2017-04-05T09:38:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>widget是iOS8时推出的窗口小部件功能，窗口小部件在Android上早已大行其道。记得当年用过的第一部Android是深圳出产的国产机，当时滑过三四个屏幕的应用，还能继续再滑三四个屏幕的窗口小部件。用的最多的窗口小部件就是日历了，屏幕上一目了然。</p>
<a id="more"></a>
<p>Apple直到iOS8才加入窗口小部件，而且可自定义程度远远没有Android开放。</p>
<p>本文记录了开发widget的步骤，以及遇到的一些问题。</p>
<p>开发环境：Xcode8.2.1，swift3.0</p>
<h2 id="创建widget"><a href="#创建widget" class="headerlink" title="创建widget"></a>创建widget</h2><p>widget可以理解为一个独立的项目，虽然形式上看来像是附属于app的一部分功能，其实并不是，widget想获取app的数据，还需要做数据共享。</p>
<p><code>File</code> -&gt; <code>New</code> -&gt; <code>Target</code></p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/2016-10-094.36.08.png?raw=true" alt="创建Today Extension"></p>
<p>选择iOS里的<code>Today Extension</code></p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/2016-10-094.40.27.png?raw=true" alt="创建Today Extension"></p>
<p>习惯使用纯代码布局，喜欢用storyboard的不需要下面的info.plist修改。在新创建的widget项目文件夹中删除<code>MainInterface.storyboard</code>，修改info.plist里的<code>NSExtension</code>字段：</p>
<ol>
<li>删除<code>NSExtensionMainStoryboard</code>字段</li>
<li>添加<code>NSExtensionPrincipalClass</code>字段，Value 为<code>TodayViewController</code>（<code>TodayViewController</code>是自定义控制器，）</li>
</ol>
<p>修改info.plist的结果如下</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161009-0.png?raw=true" alt="img"></p>
<h3 id="问题1-widget崩溃"><a href="#问题1-widget崩溃" class="headerlink" title="问题1.widget崩溃"></a>问题1.widget崩溃</h3><p>经过上述修改，用纯代码布局widget，用OC开发是没有问题的，swift3.0中widget会崩溃，并打印下面的错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;*** setObjectForKey: object cannot be nil (key: 56A34ADC-7A43-43B0-A924-171F803DD305)&apos;</div><div class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</div></pre></td></tr></table></figure>
<p>StackOverflow有人遇到同样的问题：<a href="http://stackoverflow.com/questions/28153273/today-extension-crashes-before-launching-on-ios-8-1-2" target="_blank" rel="external">Today Extension Crashes before launching on iOS 8.1.2</a>，但解答好像并没有效果。</p>
<p>在一篇博客中我找到了解决办法，<a href="http://blog.xebia.com/ios-today-widget-written-in-swift/" target="_blank" rel="external">博客地址</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Since (at the time of this writing) Xcode cannot find Swift classes as extension principal classes, we also would have to add the following line to our TodayViewController:</div><div class="line"></div><div class="line">@objc (TodayViewController)</div><div class="line"></div><div class="line">Update: Make sure to set the &quot;Embedded Content Contains Swift Code&quot; build setting of the main app target to YES. Otherwise your widget written in Swift will crash.</div></pre></td></tr></table></figure>
<p>文中说目前为止Xcode找不到swift类作为拓展主题类（其实到我写这篇文章的时候，还是找不到），这可能是一个bug。解决办法是需要在widget控制器<code>TodayViewController</code>中添加：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@objc</span> (<span class="type">TodayViewController</span>)</div></pre></td></tr></table></figure>
<p>博文更新中说，可以更改<code>Embedded Content Contains Swift Code</code>这个设置为yes，但是在Xcode8.2.1中，这个设置已经没有了，取而代之的是<code>Always Embed Swift Standard Libraries</code>，亲测主项目的<code>targets</code>和widget的<code>targets</code>中修改这个设置的Bool值，都还是会崩溃。</p>
<h2 id="widget折叠"><a href="#widget折叠" class="headerlink" title="widget折叠"></a>widget折叠</h2><p>iOS10之后才有的widget折叠。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> #available(iOSApplicationExtension <span class="number">10.0</span>, *) &#123;</div><div class="line">    <span class="keyword">self</span>.extensionContext?.widgetLargestAvailableDisplayMode = .expanded</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Fallback on earlier versions</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现下面方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@available</span>(iOSApplicationExtension <span class="number">10.0</span>, *)</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">widgetActiveDisplayModeDidChange</span><span class="params">(<span class="number">_</span> activeDisplayMode: NCWidgetDisplayMode, withMaximumSize maxSize: CGSize)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> activeDisplayMode == .expanded &#123;</div><div class="line">        <span class="keyword">self</span>.preferredContentSize = <span class="type">CGSize</span>(width: <span class="number">0</span>, height: <span class="number">200</span>)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">self</span>.preferredContentSize = maxSize</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="代码共享"><a href="#代码共享" class="headerlink" title="代码共享"></a>代码共享</h2><p>虽然widget附属于主应用，但其实是独立的。在widget中无法调用主应用中的代码，这样一来就蛋疼了。有些公共方法或者控件，在主应用中写完了，在widget却无法使用。当然把主应用中的代码拷贝一份到widget中也是可以的，这种做法太low。</p>
<p>可以使用framework做代码共享。创建一个framework</p>
<p><code>File</code> -&gt; <code>New</code> -&gt; <code>Target</code></p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20170330-150955.png" alt="创建framework"></p>
<p>在<code>framework</code>的<code>Build Phases</code> -&gt; <code>Compile Sources</code>里面添加要共享的代码文件。</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20170330-152310.png" alt="添加共享的代码文件"></p>
<p>在<code>TARGETS</code>里面，分别在主项目和widget下面的<code>Linked Frameworks and Libraries</code>里面添加新建的<code>framework</code></p>
<p>并在widget中用到共享代码的地方引入<code>framework</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ShareToday</div></pre></td></tr></table></figure>
<h3 id="问题1-引入framework报错和报警告"><a href="#问题1-引入framework报错和报警告" class="headerlink" title="问题1.引入framework报错和报警告"></a>问题1.引入framework报错和报警告</h3><p>引入的时候会如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TodayViewController.swift:11:8: Module file&apos;s minimum deployment target is ios10.0 v10.0:</div></pre></td></tr></table></figure></p>
<p>是因为framework的<code>Deployment Target</code>的版本号和widget的版本号不相符，改为一样的即可。</p>
<p>报如下警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ld: warning: linking against a dylib which is not safe for use in application extensions:</div></pre></td></tr></table></figure>
<p>是因为application extensions限制了一些API的使用，而在新建的framework里面，可能包含了这些API，所以才会出现这个警告。</p>
<p>解决办法：勾选framework里面的<code>Allow app extension API only</code></p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20170330-152418.png" alt="注意"></p>
<h3 id="问题2-方法调用不到"><a href="#问题2-方法调用不到" class="headerlink" title="问题2.方法调用不到"></a>问题2.方法调用不到</h3><p>swift中，加入到framework的一些方法，在引入头文件后的widget调用不到。</p>
<p>解决办法：需要把方法设置为公用的，用<code>public</code>修饰方法，例如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">getString</span><span class="params">(a: Int)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">	  <span class="keyword">return</span> <span class="string">"<span class="subst">\(a)</span>"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有共用的oc代码，需要将.m文件引入到<code>Compile Sources</code>，将.h文件拖入<code>Headers</code>的<code>Public</code>里面，然后在framework的.h头文件中<code>#import</code>共用oc代码的.h头文件</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/2017-04-02-14-17-36.png" alt="引入oc共享代码"></p>
<h2 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h2><h3 id="配置证书："><a href="#配置证书：" class="headerlink" title="配置证书："></a>配置证书：</h3><ol>
<li>在<code>Certificates, Identifiers &amp; Profiles</code>里的<code>Identifiers</code>下面添加<code>App IDs</code>时，要勾选<code>App Groups</code>。</li>
<li>在<code>App Group</code>添加一个<code>App Group</code>，在写<code>Identifier</code>，会在前面自动添加<code>group.</code></li>
<li>添加<code>App Group</code>之后，在<code>App IDs</code>点开第1步创建的id，点击edit，把<code>App Group</code>添加上，<code>App Group</code>的黄点会变成绿点。</li>
</ol>
<p><img src="http://oalg33nuc.bkt.clouddn.com/WX20170402-113444@2x.png" alt="创建的App Group"></p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/WX20170402-113344@2x.png" alt="配置完成的Identifier"></p>
<h3 id="添加证书"><a href="#添加证书" class="headerlink" title="添加证书"></a>添加证书</h3><p>在Xcode的<code>TARGEST</code>下面，主程序和widget的<code>Capabilities</code>里面，都要打开<code>App Groups</code>。下面的Steps不能有红色叹号的错误。</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/WX20170402-113739@2x.png" alt="正确显示"></p>
<p>在证书配置正确的前提下，还出现了红色叹号的错误警告，有可能是因为主项目或者widget的<code>General</code>里面没有选择好正确的签名Team。</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/WX20170402-112029@2x.png" alt="配置正确的签名"></p>
<h3 id="用NSUserDefaults共享数据，"><a href="#用NSUserDefaults共享数据，" class="headerlink" title="用NSUserDefaults共享数据，"></a>用NSUserDefaults共享数据，</h3><p>存储数据</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> shareDefaults = <span class="type">UserDefaults</span>(suiteName: <span class="string">"group.xxx.xxx.xx"</span>)<span class="comment">//App Groups ID</span></div><div class="line">shareDefaults?.<span class="keyword">set</span>(worksArray, forKey: <span class="string">"worksArray"</span>)</div><div class="line">shareDefaults?.synchronize()</div></pre></td></tr></table></figure>
<p>读取数据</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> shareDefaults = <span class="type">UserDefaults</span>(suiteName: <span class="string">"group.xxx.xxx.xx"</span>)<span class="comment">//App Groups ID</span></div><div class="line"><span class="keyword">let</span> worksArray = shareDefaults?.array(forKey: <span class="string">"worksArray"</span>)</div></pre></td></tr></table></figure>
<h3 id="点击widget开启app"><a href="#点击widget开启app" class="headerlink" title="点击widget开启app"></a>点击widget开启app</h3><p>在widget中，点击图标可以开启主应用，不用添加任何方法。如果想点击其他地方开启app，需要在app的<code>TARGEST</code>里的<code>info</code>下<code>URL Types</code>添加<code>URL Schemes</code></p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161009-1.png?raw=true" alt="img"></p>
<p>添加点击事件，调用方法，开启app</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">openApp</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">self</span>.extensionContext?.open(<span class="type">URL</span>(string: <span class="string">"paibanapp://"</span>)!, completionHandler: &#123; (<span class="type">Bool</span>) <span class="keyword">in</span></div><div class="line">		<span class="built_in">print</span>(<span class="string">"success"</span>)</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;widget是iOS8时推出的窗口小部件功能，窗口小部件在Android上早已大行其道。记得当年用过的第一部Android是深圳出产的国产机，当时滑过三四个屏幕的应用，还能继续再滑三四个屏幕的窗口小部件。用的最多的窗口小部件就是日历了，屏幕上一目了然。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="swift" scheme="http://markmiao.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift中contains的使用</title>
    <link href="http://markmiao.com/2017/03/16/swift%E4%B8%ADcontains%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://markmiao.com/2017/03/16/swift中contains的使用/</id>
    <published>2017-03-16T05:25:47.000Z</published>
    <updated>2017-03-16T05:27:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>contains</code>是swift中的一个实例方法，返回一个Bool值，用于做“是否包含”的判断。简单的说就是：告诉你一堆玩意儿中是否有你要的玩意儿。</p>
<a id="more"></a>
<h2 id="方法contains"><a href="#方法contains" class="headerlink" title="方法contains()"></a>方法contains()</h2><p>用法1：判断字符串中是否包含某个字符或某段字符串</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> str = <span class="string">"abcdef"</span></div><div class="line"><span class="built_in">print</span>(str.<span class="built_in">contains</span>(<span class="string">"a"</span>))<span class="comment">//true</span></div><div class="line"><span class="built_in">print</span>(str.<span class="built_in">contains</span>(<span class="string">"bcd"</span>))<span class="comment">//true</span></div><div class="line"><span class="built_in">print</span>(str.<span class="built_in">contains</span>(<span class="string">"g"</span>))<span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>用法2：判断数组中是否包含某个元素</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = [<span class="string">"Mark"</span>, <span class="string">"Kim"</span>, <span class="string">"Goudan"</span>]</div><div class="line"><span class="built_in">print</span>(str.<span class="built_in">contains</span>(<span class="string">"Mark"</span>))<span class="comment">//true</span></div><div class="line"><span class="built_in">print</span>(str.<span class="built_in">contains</span>(<span class="string">"MJ"</span>))<span class="comment">//false</span></div></pre></td></tr></table></figure>
<h2 id="方法contains-where"><a href="#方法contains-where" class="headerlink" title="方法contains(where: )"></a>方法contains(where: )</h2><p>该方法接收一个闭包，以序列元素作为闭包的参数，返回一个Bool值，判断该序列中是否有元素符合闭包条件。</p>
<p>用法1：判断Int数组中元素有没有大于100的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> list = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">44</span>,<span class="number">66</span>,<span class="number">88</span>,<span class="number">100</span>]</div><div class="line"><span class="keyword">let</span> zz = list.<span class="built_in">contains</span>(<span class="keyword">where</span>: &#123; (value) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> value &gt; <span class="number">100</span></div><div class="line">&#125;)</div><div class="line"><span class="built_in">print</span>(zz)<span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>闭包的写法可以简化，闭包中只有一行表达式时，可以省略return，直接写表达式，隐式返回：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> zz = list.<span class="built_in">contains</span>(<span class="keyword">where</span>: &#123; (value) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></div><div class="line">	 value &gt; <span class="number">100</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>闭包的参数名可以简化为$0，表示第i个参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> zz = list.<span class="built_in">contains</span>(<span class="keyword">where</span>: &#123;$<span class="number">0</span> &gt; <span class="number">100</span>&#125;)</div></pre></td></tr></table></figure>
<p>用法2：判断对象数组中对象元素的某个key所对应的value是存在某值</p>
<p>例如：判断下面<code>dictList</code>数组中的字典元素里面是否有<code>&quot;name&quot;</code> == <code>&quot;Mark&quot;</code>的元素存在</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> dictList = [[<span class="string">"name"</span>: <span class="string">"Goudan"</span>, <span class="string">"age"</span>: <span class="string">"22"</span>], [<span class="string">"name"</span>: <span class="string">"Mark"</span>, <span class="string">"age"</span>: <span class="string">"18"</span>], [<span class="string">"name"</span>: <span class="string">"Maoya"</span>, <span class="string">"age"</span>: <span class="string">"19"</span>], [<span class="string">"name"</span>: <span class="string">"Tuzi"</span>, <span class="string">"age"</span>: <span class="string">"25"</span>], ]</div></pre></td></tr></table></figure>
<p>当然可以通过<code>for</code>循环遍历<code>dictList</code>数组，挨个字典元素检测。这样做太麻烦，可以使用<code>contains(where: )</code>方法，传入一个闭包，完成检测</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> isMark = dictList.<span class="built_in">contains</span>(<span class="keyword">where</span>: &#123; (dict:[<span class="type">String</span> : <span class="type">String</span>]) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></div><div class="line">    dict[<span class="string">"name"</span>] == <span class="string">"Mark"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>可简写为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> isMark = a.<span class="built_in">contains</span>(<span class="keyword">where</span>: &#123;$<span class="number">0</span>[<span class="string">"name"</span>] == <span class="string">"Mark"</span>&#125;)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;contains&lt;/code&gt;是swift中的一个实例方法，返回一个Bool值，用于做“是否包含”的判断。简单的说就是：告诉你一堆玩意儿中是否有你要的玩意儿。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="swift" scheme="http://markmiao.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>蓬莱两日游</title>
    <link href="http://markmiao.com/2017/03/14/%E8%93%AC%E8%8E%B1%E4%B8%A4%E6%97%A5%E6%B8%B8/"/>
    <id>http://markmiao.com/2017/03/14/蓬莱两日游/</id>
    <published>2017-03-14T10:06:32.000Z</published>
    <updated>2017-03-14T10:08:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近俗事缠身，鸭梨山大。工作和生活的状态有些脱轨，人压抑太久了，就需要放松一下，不然会出问题的，可能是身体、心理、或者是家庭。为了有一个好的生活状态，需要暂停一下，歇一歇，散散心。</p>
<a id="more"></a>
<p>晓说想看海，在大海边坐坐，找找面朝大海，春暖花开的感觉，放松一下这段时间疲惫的身心。我俩思前想后，感觉蓬莱不错。东海仙山，自古以来那都是出神仙的地方。八仙就在这地过的海，显的神通，当年秦始皇求仙问道都去蓬莱。我俩一致认为：此地可去！其实想去的原因并没这么复杂，主要是去蓬莱的特价机票最便宜。</p>
<p>3月4号早上去的蓬莱，5号下午回的北京。不知道是不是因为去心不诚，此次旅行可谓一言难尽。面朝大海，却没有春暖花开。人间仙境，果然是名不虚传。</p>
<p>4号早上7:40的飞机，我一直认为是7:50的，10分钟误差虽不至于误机，但也让我紧张了一下，再加上早上起得有点晚，不免有些慌张。洗漱的时候，我刮胡子把嘴唇刮破了，好久才止住血。晓把擦脸油扣了一地，看她那心疼的眼神，我嘴破了咕嘟咕嘟流血时，她看我都没这眼神。</p>
<p>出发时，晓没穿羽绒服。我凭借在烟台待过好几年的社会经验告诉她：会冻的你打嘚嘚。上车前我跑回楼里拿了羽绒服，在蓬莱的这两天，此举会让她觉得我比那瓶擦脸油管用。</p>
<p>急急忙忙上了车，周六虽然不堵车，但是逢路口必遇红灯。我说：“也是醉了，这一早上诸事不顺！”晓给了我一巴掌：“胡说八道什么呢，赶紧呸呸呸。”我呸了两下，估计是没呸干净，不顺的事后面还有好多。早上没睡醒有些困了，我说：“好困。”晓说：“昨晚我一宿夜班呢，一眼没合，我还没说困呢。”我贱兮兮的说：“这么长时间不合眼，眼睛干不干？”晓都没搭理我。</p>
<p>到了首都机场，飞机意料之中的晚点，到蓬莱机场时已经是中午了。酒店订在蓬莱阁附近，从机场到蓬莱阁有机场快线大巴，大概一小时左右的车程，坐大巴挺方便就没有打车。这时蓬莱的天气还是阳光明媚，虽然海风吹着有点凉，但还算怡人。</p>
<p>到蓬莱东站下车，这时离海边已经很近了，海风也感觉大了。令我有些意外的是人很少，按说这也算是中国“微”著名旅游景点，虽然是淡季，但是周末不该人这么少吧？事实是淡季的存在不是没有原因的，真的是会淡出鸟来。我们到了酒店门口，酒店大门紧闭，“不会倒闭了吧？”我手捂着玻璃往门内看，酒店前台都落灰了，上面有个牌子写着入住酒店请打电话。我掏手机准备打电话，听见晓在旁边叫我，我说：“等会，我打个电话问问。”晓说：“你打个屁电话，这门能开。”我抬头看见晓开着旁边的门，看傻逼似的看着我……</p>
<p>订酒店的时候特意挑了一个带大阳台的，可以支着太阳伞，坐着藤椅，面朝大海，享受海风拂面，醉日熏人。当然这是我们理想状态下，现实总是很残酷。硬件设备是都不缺，阳台、太阳伞、藤椅都有，探探脑也能看到大海。缺的是怡人的海风和醉人的暖阳，海风不是拂面是扇耳光，说寒风刺骨有些夸张，冻一身鸡皮疙瘩还是没问题的。现在才刚过中午，阳光已经不是那么明媚了，看太阳都不刺眼，原因是——起雾了……</p>
<p>我看了一眼天气预报：大雾预警！我擦嘞，我都看见雾了才来预警，还有个鸡毛用。蓬莱的雾起的真猛，不一会儿海边已经看不见了，海风越刮越大，雾却越刮越浓。晓一副愁眉苦脸的样子：“为什么我每次来山东海边都是这个样子？”上次她去青岛，看到的也是浓雾笼罩下的大海。我耸耸肩表示无能为力，我能怎么样，我也很绝望啊！</p>
<p>稍微收拾一下就下去找地吃饭了，每去一个地方，美食的吸引力总是大于美景。好不容易来一次海边城市，海鲜肯定不容错过的美食享受。在我们准备大吃一顿的时候，发现周围的餐馆大多数都大门紧闭。也难怪，路上行人都不多，餐馆哪还有什么生意，不如关门歇业，这淡季不是一般的淡。终于发现了一家还在营业而且感觉不错的餐厅，我们是唯一的顾客，包场吃了一顿很爽的海鲜餐。</p>
<p>吃完饭出来时能见度都不到500米了，到处雾气昭昭，海上一片灰白，根本看不到哪是海面哪是雾气。呼隆隆的海浪声越来越大，海上的浓雾都被刮到陆地上了。这种天气都不想去蓬莱阁了，但是已经订了票了，距离也不远，就大口吸着浓雾，往蓬莱阁方向溜达。在路上碰到一个卖冰糖葫芦的老太太，攀谈起来，听出我是山东口音就和我多聊了几句。原来过年初一到十五，蓬莱当地人去蓬莱阁门票只要10块钱，对外票价可是140呢！其实这也无可厚非，福泽桑梓嘛，一方水土造福一方百姓。想当年我和同学也是冒充智圣诸葛亮故里附近村里的孩子，才得以进入诸葛亮宗祠，一瞻风采。</p>
<p>蓬莱阁在一座临海的山上，山上有各种庙宇，佛道皆有，道教居多。有三清殿、吕祖殿、天后宫、龙王宫、弥陀寺、蓬莱阁，以蓬莱阁最为壮观，从蓬莱阁往下看就是波澜壮阔的大海，遗憾的是放眼望去白茫茫一片全是雾气，海面都看不到。所有庙宇都供奉着神像，无一例外都有卖香烛、祈福卡之类的摊位。见到游客就以祈福送子保平安来推销产品，一排香128，保你平安又大发，来年生个胖娃娃。灵不灵自己体会，反正对于此类推销我是一概谢绝。</p>
<p>蓬莱阁上还有好几座炮台，大炮筒锈迹斑斑，点引线的眼都锈死了，想当年是不是还轰沉过海盗船？千百年来一直镇守着蓬莱海岸线，让我想起了历史上那副绝对：烟锁池塘柳，炮镇海城楼。此刻我为我的博学而骄傲，看到这里的景象我脑海中不是：卧槽，雾真他妈大，炮真他妈粗。而是一副十分应景的对联。得意之际来到城墙边，想看看下面的大海，海风裹挟着浓雾扑了一脸，“卧槽，真他妈冷！”</p>
<p>两个人在蓬莱阁溜达了一圈，冻的鼻涕都出来了。说好的面朝大海，春暖花开呢？到处都是雾气笼罩，海风凛冽。果然是人间仙境，在人间只有神仙才能住的地方！回到酒店吹了半天空调也没缓过劲来，酒店还没有暖气，刚来知道没暖气的时候，我就开始方了，这哪是度假，简直是找罪受。下午为了避免冻感冒，去逛商场了。果然商场才是适合人待的地方，外面只适合神仙待。商城逛腻了，买了张电影票，看《金刚狼3》。旅游看电影也算是一段“传奇笑话”。</p>
<p>第二天的计划是极地海洋世界。每次旅行都会有各种不如意，相应也会有称心如意的。第二天的极地海洋世界之旅相比于第一天的蓬莱阁，那是相当凑合，那家伙，那场面，锣鼓……都过去了，我就不感慨了。也是第一天吃糠拉嗓子了，第二天给点稀粥跟喝蜜似的。其实极地海洋世界挺不错的，一句话点评：值回票价。</p>
<p>蓬莱阁和极地海洋世界的票是在大众点评上一起订的，本以为会在景点入口取票，没想到是家旅行社。旅行社的人开车把我们送到极地海洋世界，并送我们进去。我们是被送进去的，所以没有票据。其中有没有黑幕我也懒的琢磨了，如果中途遇到查票的，再打电话联系旅行社吧。重要的是先玩开心了再说。</p>
<p>极地海洋世界是室内场馆，有固定的游览路线，顺着路标走即可，不会错过景点，即便是错过了也可以再游览N遍。场馆里有两处表演：妹子们的表演和海洋动物的表演，只在指定时间内演出，在游览过程中不要错过表演时间即可。场馆内有各种海洋动物，大多数和游客隔着一层玻璃，可以近距离观看。</p>
<p>有一处是食人鱼，可以买肉喂它，不知道是不是真的食人鱼，小小的，每条鱼的嘴角上都有一抹血红，和电影上的差别很大。我用小木棍上的细线绑着肉去喂它，真的是扑上去就撕咬，扽细线的力气也挺大的。我猛的一拽木棍，差点把一条食人鱼拽出来，不知道拽出来会不会咬我。片刻间线上的肉就被撕扒光了，肉吃完了全都散开了。</p>
<p>还有一处是海狮，那是一头没见过世面的海狮，竟然会和游客互动。它会拱你放在玻璃上的手，移动手还会跟着你的手跑，会和你打招呼，会露出水面吐泡泡。多亏玻璃是全封闭的，不然我猜它会漫过玻璃往外吐水，吐游客一身。对于喜欢动物的晓来说，今天可真是玩爽了，每个展览处都停留一会儿和里面的动物打招呼，当然这些动物都是见过世面的，都没有理她的。那头海狮是个例外，和她玩的格外的好，不理周围几个小孩，唯独跟着她的手跑，弄的那几个小孩好郁闷。隔壁的海象就比较高冷，一看就是久经“游场”的动物，不论晓怎么和它打招呼，它都不理，自顾自的游着。</p>
<p>最令晓开心的是一只小猴子，晓最喜欢猴子。那只猴子比手掌大不了多少，可以在手掌中站立。那是一个让游客抱着小猴子照相的消费点，景点最不缺的就是这些消费点。那只小猴子真挺可爱的，一伸手就顺着手掌跑过来了，可以放在头上、肩上。晓乐的跟只大马猴似的，玩的是不亦乐乎。工作人员再三招呼小猴，才把小猴弄回去招待下一个游客。我们去拿照片，出来的时候看到一个小孩刚把小猴抱过去，晓向小猴一招手小猴噌一下顺着她的胳膊爬了过来，小孩一脸懵逼，晓急忙把小猴还给那小孩，不然一会儿小孩该哭了。不知道这个小孩是不是刚才海狮馆那的小孩，如果是的话他今天也是够郁闷的。</p>
<p>海底世界是个几百米的长廊，弧形玻璃罩在头顶上，鱼群都在上面游来游去。之前在电视上见过，感觉特别美，仿佛置身鱼群。今天一看，头晕目眩。因为是弧形的玻璃，透过玻璃看水里就像带了个大度数的近视镜，整的晕头转向的。出了海底世界就是表演看台，是妹子们的表演。</p>
<p>我们如愿以偿的看到了美人鱼表演和海底芭蕾表演，晓说是我如愿以偿，因为表演的都是精瘦的漂亮妹子们。妹子们在鱼群里翩翩起舞，时而上浮，时而下潜，优美的舞姿令我想起了捕鱼达人，为啥没有一个吐网的大炮？我说我想捕旁边的大海龟你信不？美人鱼表演讲述了一个动人的爱情故事，反正我是没看明白，王子潜下来的那一刻我想退票，转念一想无票可退。那哪是王子，就是个大肚囊子嘛，潜水服都裹不住了。海底芭蕾是妹子们穿着比基尼，在水中……我不写了，后面的自己想。</p>
<p>看完美人鱼和海底芭蕾的表演，下面比较精彩的就剩海洋动物的表演了，海狮和海豚们的表演。和香港海洋公园里的动物表演差不多，让海狮和人类打招呼、拍手、倒立、做数学题等等，让海豚跳高，顶球，转呼啦圈等等，还找了一个游客互动。对于每天都要进行几次表演的他们也都是轻车熟路，不知道它们是不是喜欢做这些表演，但喜欢吃是肯定的，表演过程中会有吃的，为了口吃谁都不容易，动物们又何尝不是。</p>
<p>从海洋公园里出来，吃了一顿海鲜火锅。有令人难忘的海肠子，吃的过程中在网上搜了一下海肠，然后就不想吃了。蓬莱的天气还是比较冷，但是今天没雾了。吃完饭去海边走了走，海风呼啸，海浪一浪叠一浪，待了一会就冻得不行了。往回走的时候发现鞋上沾了些黑色的东西，我说：“这啥？海屎吗？”也没在意，想回家刷一下就好了。后来发现是黑油，无论如何都刷不掉，废了两双鞋。</p>
<p>下午整理了一下去机场，晓说：“从来没有在旅行的时候这么想回去。”说完缩了缩脖子，裹紧羽绒服。上了飞机，离开了蓬莱，没有留恋。晚上在飞机上看下面的夜景，车灯穿梭，璀璨的灯光织就了城市轮廓，万家灯火的夜景太美了。这次旅行本来是出来放松的，直到这一刻整个人才有些轻松。</p>
<p>到北京首都机场时已经晚上九点多了，在机场巴士上，我俩都有些累了，回想这次旅行，失望大于喜悦。我忽然问道：“机场巴士报站吗？”晓说：“不报站你还不知道路吗？”因为我们下车的站点就在我们住的地方。我说：“你听不懂我这句话的重点吗？我是在说知不知道路的问题吗？我问巴士报不报站，你问我知不知道路……”“闭嘴！我眼睛不干！”这个梗终于接上了，这趟旅行也算圆满结束，耶！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近俗事缠身，鸭梨山大。工作和生活的状态有些脱轨，人压抑太久了，就需要放松一下，不然会出问题的，可能是身体、心理、或者是家庭。为了有一个好的生活状态，需要暂停一下，歇一歇，散散心。&lt;/p&gt;
    
    </summary>
    
      <category term="记事" scheme="http://markmiao.com/categories/%E8%AE%B0%E4%BA%8B/"/>
    
    
      <category term="生活" scheme="http://markmiao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="游记" scheme="http://markmiao.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>swift中delegate的使用注意</title>
    <link href="http://markmiao.com/2017/03/10/swift%E4%B8%ADdelegate%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/"/>
    <id>http://markmiao.com/2017/03/10/swift中delegate的使用注意/</id>
    <published>2017-03-10T08:21:42.000Z</published>
    <updated>2017-03-16T05:28:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>delegate是iOS开发中一种非常常用的设计模式，经常用作界面的反向传值。block可以做到同样的事情，曾有人言delegate是个臃肿的胖子，远不如block轻便，早该淘汰了。在ARC中，block中使用swift要用weak修饰，注意循环引用。delegate也需要使用weak指针，避免内存泄露。</p>
<a id="more"></a>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, <span class="keyword">weak</span>)id&lt;<span class="type">XDViewControllerDelegate</span>&gt; delegate;</div></pre></td></tr></table></figure>
<p>ARC环境下在oc中定义delegate使用weak修饰，在delegate对象释放掉后，delegate没有强指针引用也会被释放掉，避免了访问不存在delegate对象的delegate方法而崩溃。可以在<code>dealloc</code>方法中做防御性操作：置空delegate。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)dealloc &#123;</div><div class="line">    <span class="keyword">self</span>.delegate = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在最近的swift项目中用到delegate，由于没有使用weak修饰，控件循环引用无法释放，导致内存泄露。</p>
<p>场景是这样的: 在控制器中添加了A控件，A控件中有个子控件B，B有个代理方法，A作为他的代理，并实现了代理方法。在完成功能后，使用<code>removeFromSuperview()</code>移除A控件时，发现A和B的反初始化方法<code>deinit</code>都没调用，说明这两个控件没被释放掉，内存泄露了。</p>
<p>(这里有个小坑，<code>deinit { }</code>方法里面如果没有执行代码是不会调用的，使用<code>deinit</code>检测该控件是否被移除，记得在<code>deinit { }</code>里面写一行执行代码，比如<code>print(&quot;deinit&quot;)</code>)</p>
<p>因为我在定义delegate的时候，是这样定义的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">workSelectViewDelegate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addWorkBtnViewClick</span><span class="params">(workTitle: String, workColor: String)</span></span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkSelectView</span>: <span class="title">UIView</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> delegate:workSelectViewDelegate?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于delegate没有weak修饰，在移除A控件的时候，A中有B，B的代理又是A，A和B相互引用，导致谁也没能释放掉。</p>
<p>将delegate使用weak修饰即可，直接在<code>var delegate</code>前面加<code>weak</code>，编译会报错。这是因为在swift中遵守protocol的类型有很多，其中有些类型不支持weak修饰，比如struct。这里需要限制protocol的类型遵守。比如下面指定这个protocol只能由class遵守：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">workSelectViewDelegate</span>: <span class="title">class</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addWorkBtnViewClick</span><span class="params">(workTitle: String, workColor: String)</span></span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkSelectView</span>: <span class="title">UIView</span></span>&#123;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate:workSelectViewDelegate?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一种方式是定义oc类型的protocol，因为oc类型的protocol只有class实现。使用关键词<code>@objc</code>修饰protocol：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">workSelectViewDelegate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addWorkBtnViewClick</span><span class="params">(workTitle: String, workColor: String)</span></span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkSelectView</span>: <span class="title">UIView</span></span>&#123;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate:workSelectViewDelegate?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相比第二种方法，第一种方法明显才是swift该有的样子，第二种太依赖oc了。</p>
<p>说起依赖oc，想起来在delegate定义中的<code>optional</code>，在swift中定义delegate方法，如果没有可选修饰，遵守了代理而不实现代理方法，不是警告，而是直接报错。</p>
<p>要想使用可选实现的修饰<code>optional</code>，必须使用<code>@objc</code>修饰</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">workSelectViewDelegate</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addWorkBtnViewClick</span><span class="params">(workTitle: String, workColor: String)</span></span></div><div class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">addTimeTextString</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样还有一个问题，如果代理有结构体作为返回值的话，会不支持而报错。</p>
<p>需要另一种方法定义可选代理方法，协议拓展：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">workSelectViewDelegate</span>: <span class="title">class</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addWorkBtnViewClick</span><span class="params">(workTitle: String, workColor: String)</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addTimeTextString</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">workSelectViewDelegate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addTimeTextString</span><span class="params">()</span></span> &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;delegate是iOS开发中一种非常常用的设计模式，经常用作界面的反向传值。block可以做到同样的事情，曾有人言delegate是个臃肿的胖子，远不如block轻便，早该淘汰了。在ARC中，block中使用swift要用weak修饰，注意循环引用。delegate也需要使用weak指针，避免内存泄露。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="swift" scheme="http://markmiao.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>我对小程序的一些看法</title>
    <link href="http://markmiao.com/2017/01/10/%E6%88%91%E5%AF%B9%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/"/>
    <id>http://markmiao.com/2017/01/10/我对小程序的一些看法/</id>
    <published>2017-01-10T07:05:25.000Z</published>
    <updated>2017-01-10T07:07:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>2016年9月22日，微信捣鼓了一年的应用号对部分开发者账号推送内测邀请，并暂时定名为“小程序”。2017年1月9日，“小程序”由暂定名落地为正式名，正式上线。这篇文章本来是在去年9月22日小程序推内测时写的，写了一半。今天补全，补成一篇对于小程序我的一些看法吧。也是我2017年第一篇博文，以非技术类文章开篇，可见我的懒惰。</p>
<a id="more"></a>
<p>9月22日，小程序推送内测，作为一种新兴的开发方向，在互联网圈子激起了不小的波澜。对程序猿来说，又有一个新的开发方向要涉猎了，好(F)开(U)心(C)吆(K)！好比这些火起来的语言技术：swift、React Native、Weex、php、Python、h5、js、Go……程序猿真是学无止境，怪不得都想要有几年开发经验的程序员，这些技术没有几年哪涉猎的过来啊！</p>
<p>吐槽归吐槽，作为一个好奇心极重的程序猿，对于新出的技术，还是想大致了解一下“小程序”到底是个什么玩意，万一以后做这方面的开发，这篇文字也算是探路石了。</p>
<p>2017年1月9日，小程序正式上线。“微信之父”张小龙挑的这个日子也颇有深意，十年前的1月9日乔布斯发布了第一款iPhone，彻底颠覆了移动互联网和手机市场。不知道微信是不是打算革命移动应用市场，将中国现在第一大应用推向AppStore的行列。“我是一个应用，但我不甘心只做一个应用。”估计这就是微信的心里话。</p>
<p>小程序定位是O2O，主攻线上与线下的连接。扫描二维码是小程序的主要入口。以二维码为O2O的连接媒介，以不用安装下载用完即走的轻便迅速，来弥补普通APP庞杂冗余的短板。在Apple和Google垄断移动应用市场的环境下，微信以小程序走线下启动这条路，想在移动应用市场分一杯羹。</p>
<p>小程序的线上入口比较深，需要搜索小程序全名（腾讯系的小程序支持模糊搜索），访问过小程序，才会在“发现”模块出现“小程序”一栏，里面是访问过的小程序记录，并非小程序市场。有人吐槽这是为了防止AppStore审核人员发现，对微信来说，以这种方式规避审核太弱智了吧。我想这并非为了规避审核，而是防止“微信推出小程序应用市场”的概念出现。微信在推出小程序之前估计已经和Apple和Google达成协议：我们不会抢占两位大哥应用市场的利润，我们只做个线下推广的小程序，就如同电线杆贴小广告，不会做应用市场，市场老大依旧是您二位，两位大哥高抬贵手给口吃的。</p>
<p>微信内不支持模糊搜索小程序，这也是对“小程序应用市场”概念的抑制。应用市场最重要的是能展示应用和快速搜索到应用。“小程序”模块既不能展示未使用过的应用，也不支持模糊搜索快速搜到应用，这便完全遏制了“小程序”模块是应用市场的概念。而且有模糊搜索就容易出现竞价排名，就有了应用市场的概念，微信明显意不在应用市场（或者说目前不敢有意此处），而是只想踏足线下入口这片领域。这估计也是微信对Apple和Google两位大哥的宣誓明志。</p>
<p>微信明言不推出小程序市场，如果推出小程序市场无疑是跟AppStore、谷歌应用市场宣战了，因为那完全是赤裸裸的利益争夺，两位大哥斩杀小弟估计也决不会手软。其实微信也知道，即使我不推出小程序市场，也会有一大群的跟屁虫替我推出。果不其然，1月9日当天就出现了一大批小程序市场，对此微信做了第二次宣誓明志，无法识别图片二维码打开小程序，只能扫码进入。如此一来，小程序应用市场的存在意义就如同小程序名称列表一样了。</p>
<p>除了不能模糊搜索，微信小程序还不能分享到朋友圈，只能转发给好友，这便遏制了爆炸式传播的路径。一键朋友圈分享所产生的推广力度，岂是一个好友一个好友的转发所能比拟的？微信重申主打扫码启动小程序，无需安装，用完即走，我们不提供市场和推广，我们只是小程序的审核者和搬运工。既想抢大哥的蛋糕吃，又要防止被大哥揍，微信不得不煞费苦心，剑走偏锋式的开辟一条新径。</p>
<p>对于小程序的未来，有人看好，有人不看好，有人看热闹，有人在观望。毫无疑问的是，小程序是2017年互联网界的第一个大新闻。</p>
<p>小程序开发成本低，又基于庞大的微信用户量。能火起来是肯定的，但能火到什么程度是大家最关心的。有人说能火到把原生应用都挤死，iOS和Android工程师都回家养猪吧。也有人说Apple和Google不会允许小程序太火，火到这种程度之前就会把微信干掉，依托微信的公司都等死吧。</p>
<p>这两种都太极端了，悬在自己头上的达摩克利斯之剑什么时候斩下，Apple、Google、微信他们自己比谁都清楚。他们不清楚的是看不见的那股异军突起，《腾讯传》里KK对马化腾说：“即将灭掉你的那个人，从来不会出现在一份既定的名单中。”就好比当年强盛的诺基亚和symbian，不是被竞争对手摩托罗拉打败，而是死在iPhone的Android的崛起。统一三国的不是魏蜀吴，而是司马氏。</p>
<p>到底要不要开发小程序？众说纷纭。有人说互联网世界波谲云诡、变幻莫测，好不容易出现了一列必火的快车，再不赶紧上车，等老司机开车了，就赶不上第一批红利了。就是那句话：等你想吃的时候，屎都凉了。也有人说小程序能承载的东西太少了，又依托于微信，自己对产品的掌控力弱化，何必降低自己原生应用的活跃量给微信加流量呢？这是另一句话：为什么要拿自己的热脸去捂暖别人的冷屁股呢？</p>
<p>各有各的说法，各有各的道理。那我他妈的到底要不要推出小程序呢？</p>
<p>其实根据小程序的O2O定位，可以大致研究研究自己公司到底适不适合推出小程序。我认为，小程序适用于固定地点、用户非日常刚需、偶尔使用的低频应用。比如：进店线上点餐、某个景点介绍和路线、某个商店的线上商城、某个学校的官宣。通俗解释就是：我不经常用，但用起来又比较着急，别让我下载APP注册账号，让我一扫立刻用到。就好比擦腚纸，要用的时候从旁边厕纸盒一抽即可，要是先让我解厕纸盒的密码锁，我不得疯了啊！用完之后随水冲走。用时一抽，用完一冲，也用带着占用口袋空间，太方便了。（这个比喻没有贬低小程序的意思，我实在是想不到比这个更恰当的比喻了）</p>
<p>如果是高频率使用的应用，还是原生应用适合。比如：日历。我要看个日历，直接右划看widget即可，连解锁都不用。让我解锁，打开微信，点到小程序，看日历，那也得疯了。还有如果只是偶尔定一次餐，点小程序订餐即可，不用专门下个APP。但如果我是天天加班订餐，我还是习惯用原生APP。</p>
<p>作为用户角度，哪个方便我用哪个，用户体验是能留住我的唯一手段，谁能让我爽，我就喜欢谁。有人在微博上说：我已经卸载了美团外卖和猫眼APP了。小程序里的美团外面和猫眼APP完全可以满足用户订餐和买电影票的需求，用户毫不留恋原生APP，删除卸载。对于美团和猫眼来说这种消息不知是好是坏，自己原生应用的用户活跃量硬生生被微信小程序剥夺了一部分，用自己的用户贡献了微信的流量。比较来说滴滴就比较聪明，滴滴出行只能打快车，用户要是想打顺风车、小巴还是得去APP。</p>
<p>作为程序员，公司要我做哪个就得做哪个，管你小程序是一波红利还是一撮泡沫。“小猿呀，明天小程序要上线，今天加加班，搞定它，相信你吆。” “哦……” 同事们都下班了，我翻开微信公众平台的小程序，开始看第一篇“简易教程”，开始踩坑之旅。作为程序员，小程序还是需要看看的，毕竟是今年的第一波技术浪潮，虽然后面一浪接着一浪，别第一浪就拍死了，死在第二浪会好看点。</p>
<p>本文纯属是我对微信小程序的一些看法，如有偏差，欢迎拍砖吐槽。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016年9月22日，微信捣鼓了一年的应用号对部分开发者账号推送内测邀请，并暂时定名为“小程序”。2017年1月9日，“小程序”由暂定名落地为正式名，正式上线。这篇文章本来是在去年9月22日小程序推内测时写的，写了一半。今天补全，补成一篇对于小程序我的一些看法吧。也是我2017年第一篇博文，以非技术类文章开篇，可见我的懒惰。&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://markmiao.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="小程序" scheme="http://markmiao.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>2016我的年终总结</title>
    <link href="http://markmiao.com/2016/12/31/2016%E6%88%91%E7%9A%84%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://markmiao.com/2016/12/31/2016我的年终总结/</id>
    <published>2016-12-31T04:19:49.000Z</published>
    <updated>2016-12-31T04:23:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉2016年结束了，离梦想又远了一步。在微博上看到一句话：“十年前并不是九几年而是零六年！”那一瞬间感觉自己真的老了。90后已不再是年轻的标签，奔三也奔的那么马不停蹄。三十而立，到现在依旧晃晃悠悠，到三十那天我真能立住吗？怎么立？金鸡独立？又或者是静静地坐着敲代码，平凡的度过本以为不平凡的那一天。</p>
<a id="more"></a>
<p>来北京四年了，每年都有不一样的事，每年都遇到不一样的人。谈不到精彩，相对于平淡总有一些波澜，可以厚颜无耻的说一句：我还年轻没到平淡的年纪。回头看看这一年，总觉得这是我最忙碌、变化最大的一年。具体想想有哪些变化，貌似也没什么。是虚度了时光，还是矫情了岁月？</p>
<h2 id="工作和技术"><a href="#工作和技术" class="headerlink" title="工作和技术"></a>工作和技术</h2><p>工作方面没有多大改变，依旧敲代码。2015年国庆假期结束入职现在这家公司，app开发了一堆，拿的出手的却没有。工作相对于在以前公司的时候清闲多了，几乎没加过班。一方面是工作经验多了的原因，对于工作中遇到的问题，也不像初入行时那么手忙脚乱了。另一方面是项目周期长，时间充裕。记得我刚入行时的第一家公司，项目周期短，需求变化大，迭代迅速，差不多一两周出一版。就是赶着AppStore的审核时间，等待审核期间新需求就出来了，审核通过上架了，新版本也开发的差不多了，继续提交。快速增长期的创业公司就是这个节奏，那段时间经常通宵加班，睡在公司。我的上一辆自行车停在地铁口，通宵加班两天，第三天回来的时候不见了。那段时间真是加班加的快吐了，简直是张口就要骂娘的状态，那时最大的愿望就是下班时能看到夕阳。但那段时间也是我技术提升最快的时候，现在闲下来了，反而有些怀念当时受虐的日子，人真是有些贱骨头。</p>
<p>技术方面没有大的提升，作为本职工作的iOS开发，钻研的还不够，好多深层次的东西都不懂。有时候看到和我差不多时间入行，甚至比我入行还晚的人写的技术博客，令我惭愧不已。我不但写不出来，甚至都看不懂，我都不好意思说比别人早入行。前段时间在微博上看到一段话，是面试官对面试者说的话：你不是有N年经验，你是一年经验用了N年。当时感觉被狠狠抽了一个大嘴巴子，这他妈不就是说的我吗？安逸的工作环境使人颓废，多少次励志，多少次放弃，间歇性踌躇满志，持续性混吃等死。感觉膝盖狠狠地中了一箭，长跪不起。客观来说，技术还是有些提升，虽然提升幅度不值一哂。swift、Mac、git、Python、h5、JavaScript……这些多少有些涉猎，嗯……好吧，目前还停留在涉猎层面。一直十分佩服那些能按部就班沉下心了学习一门技术的人，能让自己不断学习的人，就是所谓成功的一类人吧，即使目前不成功，成功的那天总不会很远。</p>
<h2 id="生活和爱情"><a href="#生活和爱情" class="headerlink" title="生活和爱情"></a>生活和爱情</h2><p>生活方面算是变化最大的了，2016年春节过后，和女朋友搬到现在居住的地方，脱离了以前合租的窘境。6月份头脑一热养了一只金毛，现在他已经有九个月了。硕大的体型、对人忘我般的热情，每当遛他的时候，总担心他扑向陌生人。虽然他性情温顺，但毕竟体型太大，对人又热情，喜欢闹腾。除了了解金毛、喜欢狗狗的人能和他玩玩，其他人即便喜欢也不敢靠近。养过狗狗才知道，养狗真的挺麻烦的，特别是养一只大狗。烦透了的时候忍不住揍一顿，揍完又感觉他好可怜。我对晓说：他就像是个意外怀孕的孩子，讨人厌又惹人怜。晓说：也是一个家庭成员，好好养着吧。有时上班不在家，透过摄像头看到他静静地坐在窗前，看窗外车来车往，感觉他好想出去玩，像个孩子……</p>
<p>晓是和我在2016年元旦之前去我家的，那也是她第一次去我家，第一次见我父母。我见她父母是在3月份，和她一家人去了一趟西安。晓美其名曰旅行见父母，其实就想出去浪一下。最终圆满，我父母对晓非常喜欢，晓的父母对我也十分满意。7月份，我父母来北京，双方父母进行了亲切友好的会谈，对我们的终身大事交换意见，并达成一致协议。10月份，在晓的父母的陪同下，晓和我在我家举行了订婚仪式，亲朋好友献上真诚祝福。在北京，我从一个通宵加班两天、自行车丢了都没人问的单身狗，变成了一个有小窝、有爱人、有孩子(目前是宠物)的程序猿。这一波虐狗得负刑事责任了……</p>
<h2 id="读书和旅行"><a href="#读书和旅行" class="headerlink" title="读书和旅行"></a>读书和旅行</h2><p>都说读万卷书，行万里路。这两者缺一不可。一直以来，我都是喜欢看旧书，不愿去翻开一本新书。有的书我都读过十几二十几遍了，想读书的时候还会去读那些，当然都不是什么技术型书籍。读书确实是提升自己最有效的方式，读书破万卷，下笔如有神，古人诚不欺我。当然我离这个境界还差十万八千里，但我希望我能向着这个目标不断前进。年底看了一本新书，吴晓波写的《腾讯传》，讲述了腾讯的发展史，记录了一个互联网巨型企业一路走来的跌宕坎坷，我看到了任何成功都容不得半点侥幸，腾讯的崛起也绝非偶然。</p>
<p>旅行是费钱的，但长久看来收益大于付出。2015年有过一次旅行，和晓去四川成都，去了宽窄巷子、大熊猫培育基地、九寨沟，最终由于我发高烧仓促返京。2016年有过两次远途旅行，第一次是和晓的家人去西安，第二次是和晓去香港。每次旅行或多或少都会有遗憾，或许根本不可能存在完美的旅行，有不完美才会有下一次的追求完美。明年还会去旅行，目的地还没想好，我会为了完美的旅行做更多的准备，虽然肯定还会有不完美。</p>
<p>前几天看到一段话：如果不读书，行万里路也不过是个邮差。仔细想想蛮有道理的，庐山瀑布有亿万人望过，也只有李白写出了“飞流直下三千尺，疑是银河落九天”的绝句。有多少文化底蕴才能读出美景的多少韵味，看到草原，牛想到的是饱餐一顿，诗人想的是天苍苍，野茫茫，风吹草低见牛羊。打住！这段话纯属吹牛逼，我也不相信一个程序猿到一个地方首先想到的是美景而不是美食。我是一个爱吃的俗人，不是爱景诗人，但我知道多读书能多挣钱，多挣钱能多旅行，多旅行才能吃到更好的美食。</p>
<h2 id="大环境和小愿望"><a href="#大环境和小愿望" class="headerlink" title="大环境和小愿望"></a>大环境和小愿望</h2><p>2016年，互联网行业历经寒冬，从波澜翻滚变成了暗潮涌动。记得前几年，互联网创业随处可见，创业门槛低到有台电脑就行，到处都能听到风投融资的故事。雷军说：站在风口上，猪都会飞。今年风小了，好多猪摔死了。光我认识的同学朋友圈子里，就有五六家公司关门大吉，我这个小圈子都如此，可见这个大行业的动荡。互联网行业从疯狂渐渐趋向沉稳，从互联网行业招聘就可以看出来，程序员找工作难，iOS更是难于上青天。有AppStore上架作品已不再是加分项，而是基本技能。网上有人说：招Android和iOS两个职位，Android一天收到十几份简历，iOS能收到几百份简历！多少iOS开发者抱着简历海投，只求一份工作。有人抱怨iOS不行了，转投H5。相信过不了多久你又会抱怨H5不行了，那时候你转投什么呢？在一篇博文里看到这么一段话：不是这个行业不行，而是你不行。事实如此，无数iOS开发者找不到工作的同时，也有无数企业招不到合适的iOS开发。需求和供应有时就是这么尴尬的不对等，作为程序员，职责就是实现各种需求，不是等着适合自己的需求再去实现。好了，牛逼吹完了，我该去给老板的iPhone7 Plus贴膜了。</p>
<p>2016年，技术爆发的一年。层出不穷的新技术令人眼花缭乱，swift出到3.0，每一版都像是一门新的语言；JavaScript和h5也日益繁荣，就像几年前的iOS；Python、PHP老牌语言和新秀Go语言也火的不要不要的了；iOS开发的热更新也花样繁多，JSPatch，今年年底滴滴的DynamicCocoa；跨平台的方式也越来越多，Facebook的React Native，阿里的Weex；还有年底微信横空出世的小程序……</p>
<p>我是一头赶上风口飓风的猪，压迫着骨子里的惰性努力瘦身，希望在风停的时候不至于摔死。2016年年底做的最正确的事就是购买域名搭建了自己的博客，这件本应早几年就做的事，一直拖到了现在。有了自己的博客和订阅号，还有github的小绿格子，在这些面子工程的倒逼下或许不会那么容易就轻言放弃。</p>
<p>2016再见，2017你好。新年愿望是：希望2017年的年终总结里没有懊悔。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉2016年结束了，离梦想又远了一步。在微博上看到一句话：“十年前并不是九几年而是零六年！”那一瞬间感觉自己真的老了。90后已不再是年轻的标签，奔三也奔的那么马不停蹄。三十而立，到现在依旧晃晃悠悠，到三十那天我真能立住吗？怎么立？金鸡独立？又或者是静静地坐着敲代码，平凡的度过本以为不平凡的那一天。&lt;/p&gt;
    
    </summary>
    
      <category term="记事" scheme="http://markmiao.com/categories/%E8%AE%B0%E4%BA%8B/"/>
    
    
      <category term="总结" scheme="http://markmiao.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="生活" scheme="http://markmiao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>私有API的使用</title>
    <link href="http://markmiao.com/2016/12/28/%E7%A7%81%E6%9C%89API%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://markmiao.com/2016/12/28/私有API的使用/</id>
    <published>2016-12-28T09:42:20.000Z</published>
    <updated>2016-12-28T09:45:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>私有API是指苹果未公开的一些方法，通常情况下这些方法不允许开发者使用，通常情况是指上架AppStore。私有API可以实现一些开放API不能实现的效果，功能强大，效果非凡。苹果不允许使用，是因为有些私有API会侵犯用户隐私，但使用私有API也并非一定会侵犯用户隐私，这要看开发者怎么用了。</p>
<a id="more"></a>
<p>企业级账号发布供内部人使用的APP，可以使用私有API。发布到其他APP平台供越狱手机下载的APP，也有可能使用了私有API。这两者没有苹果审核把关，私有API可以随便使用。<strong>苹果明令禁止使用私有API的APP上架AppStore！</strong>但凡事无绝对，AppStore上也不乏使用私有API的应用，使用办法有很多，比如热更新。不被苹果发现就行，发现了轻者下架，重者封号。</p>
<p>我想看看私有API到底能干些啥，写了一个测试私有API的小项目，涉及到的知识点大多数来源于网络，在此感谢大神们的知识共享。项目很小，知识很浅，欢迎拍砖吐槽。</p>
<p>项目代码: <a href="https://github.com/mxdios/privateApiApps" target="_blank" rel="external">privateApiApps</a></p>
<p>开发环境: Xcode 8.2.1，iPhone 6，iOS 10.2</p>
<p>项目截图:</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="http://oalg33nuc.bkt.clouddn.com/WechatIMG241.jpeg" alt="获取iPhone上的所有APP"></th>
<th style="text-align:center"><img src="http://oalg33nuc.bkt.clouddn.com/WechatIMG242.jpeg" alt="APP相关信息"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>参考资料:</p>
<ol>
<li><a href="https://github.com/nst/iOS-Runtime-Headers" target="_blank" rel="external">iOS-Runtime-Headers</a></li>
<li><a href="http://octree.me/2016/08/01/get-installed-apps/" target="_blank" rel="external">获取iOS设备上安装的应用列表</a></li>
</ol>
<h2 id="获取iPhone中安装的APP列表"><a href="#获取iPhone中安装的APP列表" class="headerlink" title="获取iPhone中安装的APP列表"></a>获取iPhone中安装的APP列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class LSAppClass = objc_getClass(&quot;LSApplicationWorkspace&quot;);</div><div class="line">NSObject *workspace = [LSAppClass performSelector:@selector(defaultWorkspace)];</div><div class="line">NSArray *appsArray = [workspace performSelector:@selector(allApplications)];</div></pre></td></tr></table></figure>
<p>这里面使用了runtime的方法<code>- (id)performSelector:(SEL)aSelector;</code>，需要引入<code>&lt;objc/runtime.h&gt;</code>。该方法的作用是给接收者传递进去一个方法，返回值就是这个方法执行后的返回值。</p>
<p>由于调用的是私有API，传入的方法相当于一个字符串，编译器不会检测该方法是否正确，相反会一直报警告。例如上面传递的方法<code>defaultWorkspace</code>，这是个私有API的方法。通常还有另一种调用<code>performSelector</code>方法的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSObject *workspace = [LSAppClass performSelector:NSSelectorFromString(@&quot;defaultWorkspace&quot;)];</div></pre></td></tr></table></figure>
<p>如果传递进去的私有API方法名写错了，程序就会找不到该方法而崩溃。所以通常会通过下面方法检测接收者或接收者的父类是否实现了传递进去的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)respondsToSelector:(SEL)aSelector;</div></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ([LSAppClass respondsToSelector:@selector(defaultWorkspace)]) &#123;</div><div class="line">   	NSObject *workspace = [LSAppClass performSelector:@selector(defaultWorkspace)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>真实情况中，该方法并非必要。传入的私有API方法名都是固定的，程序崩溃了说明方法名写错了，改成正确的即可。使用该方法不会崩溃，反而不易发现错误。</p>
<h2 id="获取每个APP的相关信息"><a href="#获取每个APP的相关信息" class="headerlink" title="获取每个APP的相关信息"></a>获取每个APP的相关信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[appsArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;   </div><div class="line">	AppsObject *appsObj = [[AppsObject alloc] init];</div><div class="line">	appsObj.appName = [obj performSelector:@selector(localizedName)];</div><div class="line">	appsObj.version = [obj performSelector:@selector(shortVersionString)];</div><div class="line">	appsObj.bundleId = [obj performSelector:@selector(applicationIdentifier)];</div><div class="line">	appsObj.appFullName = [obj performSelector:@selector(itemName)];</div><div class="line">	appsObj.appType = [obj performSelector:@selector(applicationType)];</div><div class="line">	appsObj.appVendorName = [obj performSelector:@selector(vendorName)];</div><div class="line">	appsObj.appRating = [obj performSelector:@selector(ratingLabel)];</div><div class="line">	[_appsObjArray addObject:appsObj];</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<p>遍历获取的APP列表，通过私有API获取每个app的各种信息：</p>
<table>
<thead>
<tr>
<th style="text-align:left">私有API方法名</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">localizedName</td>
<td style="text-align:left">app名字</td>
</tr>
<tr>
<td style="text-align:left">shortVersionString</td>
<td style="text-align:left">版本号</td>
</tr>
<tr>
<td style="text-align:left">applicationIdentifier</td>
<td style="text-align:left">Bundle Identifier</td>
</tr>
<tr>
<td style="text-align:left">itemName</td>
<td style="text-align:left">app在AppStore显示的名字</td>
</tr>
<tr>
<td style="text-align:left">applicationType</td>
<td style="text-align:left">app类型,分为:System和User</td>
</tr>
<tr>
<td style="text-align:left">vendorName</td>
<td style="text-align:left">app供应商</td>
</tr>
<tr>
<td style="text-align:left">ratingLabel</td>
<td style="text-align:left">app评级</td>
</tr>
</tbody>
</table>
<h2 id="获取APP图标"><a href="#获取APP图标" class="headerlink" title="获取APP图标"></a>获取APP图标</h2><p>上述中并没有获取APP图标的方法，获取app图标比较麻烦。</p>
<h3 id="获取APP图标路径"><a href="#获取APP图标路径" class="headerlink" title="获取APP图标路径"></a>获取APP图标路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSDictionary *dict = [object performSelector:@selector(boundIconsDictionary)];</div><div class="line">NSString *appIconPath = [NSString stringWithFormat:@&quot;%@/%@.png&quot;,[[object performSelector:@selector(resourcesDirectoryURL)] path],[[[dict objectForKey:@&quot;CFBundlePrimaryIcon&quot;] objectForKey:@&quot;CFBundleIconFiles&quot;] lastObject]];</div></pre></td></tr></table></figure>
<p>iOS10.2亲测，该方法只能获取模拟器上的APP图标，真机无效。</p>
<h3 id="获取图标data数据"><a href="#获取图标data数据" class="headerlink" title="获取图标data数据"></a>获取图标data数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appsObj.iconData = [obj performSelector:@selector(iconDataForVariant:) withObject:@(2)];</div></pre></td></tr></table></figure>
<p>该data数据并不能直接转为UIImage，需要对data数据进行截取转换，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+ (UIImage *)getAppIcon:(NSData *)iconData &#123;</div><div class="line">    NSInteger lenth = iconData.length;</div><div class="line">    NSInteger width = 87;</div><div class="line">    NSInteger height = 87;</div><div class="line">    uint32_t *pixels = (uint32_t *)malloc(width * height * sizeof(uint32_t));</div><div class="line">    [iconData getBytes:pixels range:NSMakeRange(32, lenth - 32)];</div><div class="line">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    CGContextRef ctx = CGBitmapContextCreate(pixels, width, height, 8, (width + 1) * sizeof(uint32_t), colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);</div><div class="line">    CGImageRef cgImage = CGBitmapContextCreateImage(ctx);</div><div class="line">    CGContextRelease(ctx);</div><div class="line">    CGColorSpaceRelease(colorSpace);</div><div class="line">    UIImage *icon = [UIImage imageWithCGImage: cgImage];</div><div class="line">    CGImageRelease(cgImage);</div><div class="line">    return icon;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="打开APP"><a href="#打开APP" class="headerlink" title="打开APP"></a>打开APP</h2><p>在iOS 9以后要想打开其他app需要添加URL Scheme，设置白名单，否则将无法打开，白名单的上限为50个。上文中我们可以获取APP的<code>Bundle Id</code>，依靠<code>Bundle Id</code>使用私有API可以打开其他APP，并没有数量限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class LSAppClass = NSClassFromString(@&quot;LSApplicationWorkspace&quot;);</div><div class="line">id workSpace = [(id)LSAppClass performSelector:@selector(defaultWorkspace)];</div><div class="line">[workSpace performSelector:@selector(openApplicationWithBundleID:) withObject:self.appsObj.bundleId];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;私有API是指苹果未公开的一些方法，通常情况下这些方法不允许开发者使用，通常情况是指上架AppStore。私有API可以实现一些开放API不能实现的效果，功能强大，效果非凡。苹果不允许使用，是因为有些私有API会侵犯用户隐私，但使用私有API也并非一定会侵犯用户隐私，这要看开发者怎么用了。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://markmiao.com/tags/iOS/"/>
    
      <category term="私有API" scheme="http://markmiao.com/tags/%E7%A7%81%E6%9C%89API/"/>
    
  </entry>
  
  <entry>
    <title>Quartz 2D（三）样式、阴影、渐变</title>
    <link href="http://markmiao.com/2016/12/21/Quartz2D3/"/>
    <id>http://markmiao.com/2016/12/21/Quartz2D3/</id>
    <published>2016-12-21T07:03:09.000Z</published>
    <updated>2016-12-21T07:04:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><p>Pattern可翻译为样式、模型。类似于iOS中自定义的view，可以重复多次把自定义的view添加到控制器的view上。样式(Pattern)是绘制操作的一个序列，可以重复的绘制到一个图形上下文上。</p>
<a id="more"></a>
<h3 id="样式单元格"><a href="#样式单元格" class="headerlink" title="样式单元格"></a>样式单元格</h3><p>样式单元格是样式的基本组件，在创建的时候就要定义单元格的边界，并在这个范围内进行绘制。在图形上下文上绘制单元格时，可以随意指定两个单元格之间上下左右间距，也可以指定负数，单元格重合而已。像极了添加view控件。</p>
<h3 id="着色样式和模板样式"><a href="#着色样式和模板样式" class="headerlink" title="着色样式和模板样式"></a>着色样式和模板样式</h3><p>着色样式是有固定颜色的，在创建样式单元格的时候就指定其颜色了，跟绘制流程没有关系。</p>
<p>模板样式即为非着色样式，在创建样式单元格的时候只指定了形状，并没有指定颜色，在绘制过程中指定颜色。</p>
<p>在Quartz 2D中可以使用这两种样式实现样式绘图，将创建好的样式绘制到page上的过程称为平铺，有三种平铺选项：1、没有失真，2、最小的失真的恒定间距，3、恒定间距。</p>
<h3 id="绘制着色样式"><a href="#绘制着色样式" class="headerlink" title="绘制着色样式"></a>绘制着色样式</h3><p>绘制着色样式一般需要下面几步：1、设置样式单元格的回调函数，2、设置着色模式单元格，3、绘制操作。下面是绘制着色样式的示例代码和运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    [super drawRect:rect];</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    clorePatternPaingting(context, CGRectMake(0, 0, 300, 500));</div><div class="line">&#125;</div><div class="line">void clorePatternPaingting(CGContextRef context, CGRect rect) &#123;</div><div class="line">    CGColorSpaceRef patternSpace = CGColorSpaceCreatePattern(NULL);</div><div class="line">    CGContextSetFillColorSpace(context, patternSpace);</div><div class="line">    CGColorSpaceRelease(patternSpace);</div><div class="line">    static const CGPatternCallbacks call = &#123;0, &amp;drawPattern, NULL&#125;;</div><div class="line">    CGPatternRef pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 30, 30), CGAffineTransformIdentity, 30, 30, kCGPatternTilingConstantSpacing, true, &amp;call);</div><div class="line">    CGFloat alpha = 1.0;</div><div class="line">    CGContextSetFillPattern(context, pattern, &amp;alpha);</div><div class="line">    CGPatternRelease(pattern);</div><div class="line">    CGContextFillRect(context, rect);</div><div class="line">&#125;</div><div class="line">void drawPattern(void *info, CGContextRef context) &#123;</div><div class="line">    CGContextSetRGBFillColor(context, 1, 0, 0, 1);</div><div class="line">    CGContextFillRect(context, CGRectMake(0, 0, 10, 10));</div><div class="line">    CGContextSetRGBFillColor(context, 0, 1, 0, 1);</div><div class="line">    CGContextFillRect(context, CGRectMake(10, 0, 10, 10));</div><div class="line">    CGContextSetRGBFillColor(context, 0, 0, 1, 1);</div><div class="line">    CGContextFillRect(context, CGRectMake(0, 10, 10, 10));</div><div class="line">    CGContextSetRGBFillColor(context, 0.5, 0, 0.5, 1);</div><div class="line">    CGContextFillRect(context, CGRectMake(10, 10, 10, 10));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161220-0.png" alt="绘制着色模式的运行结果"></p>
<p><strong>代码解释：</strong></p>
<p>上述代码块中第三个函数<code>drawPattern</code>的作用就是第1步：设置样式单元格的回调函数。参数<code>info</code>:是指向模式相关数据的指针，可以传<code>NULL</code>。<code>context</code>:是图形上下文。在该函数中指定了每个颜色块的大小和填充色。因为是着色样式，所以指定填充色。</p>
<p>第二个函数，也是在<code>drawRect</code>方法中调用的函数<code>clorePatternPaingting</code>，执行了第2步:设置着色模式单元格和第3步:绘制操作。下面对每块代码进行解释：</p>
<p><strong>清空基本颜色空间：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGColorSpaceRef patternSpace = CGColorSpaceCreatePattern(NULL);</div><div class="line">CGContextSetFillColorSpace(context, patternSpace);</div><div class="line">CGColorSpaceRelease(patternSpace);</div></pre></td></tr></table></figure>
<p>因为我们要使用着色样式里面的颜色，所以清空基本颜色空间，以确保着色样式上的颜色能显示。可以试一下把这段代码注释的结果，绘制着色样式的空间为黑色，因为基本颜色空间没清空也没着色，所以呈黑色。</p>
<p><strong>设置着色模式单元格：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static const CGPatternCallbacks call = &#123;0, &amp;drawPattern, NULL&#125;;</div><div class="line">CGPatternRef pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 30, 30), CGAffineTransformIdentity, 30, 30, kCGPatternTilingConstantSpacing, true, &amp;call);</div></pre></td></tr></table></figure>
<p>模式单元格的信息保存在<code>CGPatternRef</code>类型的<code>CGPattern</code>对象中，使用<code>CGPatternCreate</code>创建该对象。需要传入的参数依次解释为：</p>
<ol>
<li>info：是一个指针，指向我们要传递给绘制回调函数的数据。这里传的是<code>NULL</code></li>
<li>bound：指定模式单元格的大小</li>
<li>matrix：指定模式矩阵，它将模式坐标系统映射到图形上下文的默认坐标系统。如果希望两个坐标系统是一样的，则可以使用单位矩阵。</li>
<li>xStep, yStep：指定单元格之间的水平和竖直间距。</li>
<li>tiling：平铺模式，可以是kCGPatternTilingNoDistortion、kCGPatternTilingConstantSpacingMinimalDistortion、kCGPatternTilingConstantSpacing</li>
<li>isColored：指定模式单元格是着色模式(true)还是模板模式(false)</li>
<li>callbacks：是一个指向CGPatternCallbacks结构体的指针。格式如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct CGPatternCallbacks &#123;</div><div class="line">    unsigned int version;</div><div class="line">    CGPatternDrawPatternCallback __nullable drawPattern;</div><div class="line">    CGPatternReleaseInfoCallback __nullable releaseInfo;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>version</code>一般设置为<code>0</code>，<code>drawPattern</code>是指向设置样式单元格的回调函数，<code>releaseInfo</code>是指向回调函数，释放CGPattern对象时调用，以释放存储在我们传递给绘制回调的info参数中的数据。如果在这个参数中没有传递任何数据传<code>NULL</code>。</p>
<p>所以<code>CGPatternCallbacks</code>结构体定义为<code>static const CGPatternCallbacks call = {0, &amp;drawPattern, NULL};</code></p>
<p><strong>绘制着色样式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CGFloat alpha = 1.0;</div><div class="line">CGContextSetFillPattern(context, pattern, &amp;alpha);</div><div class="line">CGPatternRelease(pattern);</div><div class="line">CGContextFillRect(context, rect);</div></pre></td></tr></table></figure>
<p>调用函数<code>CGContextSetFillPattern</code>使用着色样式进行填充操作，或者调用函数<code>CGContextSetStrokePattern</code>进行描边操作。需要指定着色样式在填充或描边过程的透明度。</p>
<p>样式使用完毕后需要释放，调用函数：<code>CGPatternRelease</code></p>
<p>将定义的着色样式使用函数<code>CGContextFillRect</code>填充到指定<code>rect</code>的矩形中。</p>
<p>这一系列操作都放到函数<code>clorePatternPaingting</code>内，在<code>drawRect</code>方法中直接调用该函数即可完成着色样式的定义和绘制。</p>
<h3 id="绘制模板样式"><a href="#绘制模板样式" class="headerlink" title="绘制模板样式"></a>绘制模板样式</h3><p>绘制模板样式的步骤和绘制着色样式的一样：1、设置样式单元格的回调函数，2、设置模板模式单元格，3、绘制操作。下面是绘制模板样式的示例代码和运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    [super drawRect:rect];</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    stencilPatternPaingting(context, CGRectMake(0, 0, 300, 500));</div><div class="line">&#125;</div><div class="line">void stencilPatternPaingting(CGContextRef context, CGRect rect) &#123;</div><div class="line">    CGColorSpaceRef baseSpace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    CGColorSpaceRef patternSpace = CGColorSpaceCreatePattern(baseSpace);</div><div class="line">    CGContextSetFillColorSpace(context, patternSpace);</div><div class="line">    CGColorSpaceRelease(patternSpace);</div><div class="line">    CGColorSpaceRelease(baseSpace);</div><div class="line">    static const CGPatternCallbacks cell = &#123;0, &amp;drawStencilPattern, NULL&#125;;</div><div class="line">    CGPatternRef pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 30, 30), CGAffineTransformIdentity, 40, 40, kCGPatternTilingConstantSpacing, false, &amp;cell);</div><div class="line">    static const CGFloat color[] = &#123;1, 0, 0, 1&#125;;</div><div class="line">    CGContextSetFillPattern(context, pattern, color);</div><div class="line">    CGPatternRelease(pattern);</div><div class="line">    CGContextFillRect(context, rect);</div><div class="line">&#125;</div><div class="line">void drawStencilPattern(void *info, CGContextRef context) &#123;</div><div class="line">    CGContextAddEllipseInRect(context, CGRectMake(0, 0, 30, 30));</div><div class="line">    CGContextFillPath(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161220-1.png" alt="绘制模板样式的运行结果"></p>
<p>代码解释参考上文中着色样式的代码解释。区别1是用下述代码设置样式单元格的颜色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static const CGFloat color[] = &#123;1, 0, 0, 1&#125;;</div><div class="line">CGContextSetFillPattern(context, pattern, color);</div></pre></td></tr></table></figure>
<p>区别2是<code>CGPatternCreate</code>函数中传的参数是<code>false</code>。</p>
<h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>阴影有三个属性：x偏移量，y偏移量，模糊度</p>
<p>阴影通过函数<code>CGContextSetShadow</code>设置，指定图形上下文、x偏移量、y偏移量、模糊度。设置阴影后，绘制的对象都会有阴影，阴影的色值为0.3透明度的黑色，颜色RGBA值为{0, 0, 0, 0.3}。</p>
<p>也可以是使用函数<code>CGContextSetShadowWithColor</code>设置彩色阴影。</p>
<p>在调用<code>CGContextSetShadow</code>或<code>CGContextSetShadowWithColor</code>之前保存图形状态，可以通过恢复图形状态来关闭阴影。或者设置阴影颜色为<code>NULL</code>关闭阴影。</p>
<p>分别设置彩色阴影和普通阴影：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextSaveGState(context);</div><div class="line">CGContextSetShadowWithColor(context, CGSizeMake(10, 10), 2, [UIColor redColor].CGColor);</div><div class="line">CGContextSetRGBFillColor (context, 0, 1, 0, 1);</div><div class="line">CGContextAddEllipseInRect(context, CGRectMake(40, 40, 100, 100));</div><div class="line">CGContextFillPath(context);</div><div class="line">CGContextSetShadow(context, CGSizeMake(10, 10), 2);</div><div class="line">CGContextFillRect(context, CGRectMake(200, 40, 100, 100));</div><div class="line">CGContextRestoreGState(context);</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161220-2.png" alt="圆形的红色阴影和矩形的灰色阴影"></p>
<p>x偏移量正值在图形右边，负值在图形左边。y偏移量和坐标有关，在iOS中，UIKit坐标系y轴和Quartz 2D坐标系y轴相反，所以如果是由UIKit创建的图形上下文则正值在图形下面，负值在图形上面。macOS的坐标系和Quartz 2D坐标系一样，所以正值在图形上面，负值在图形下面。阴影绘制不受CTM影响。</p>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>可以使用函数<code>CGShadingRef</code>和<code>CGGradientRef</code>创建渐变。渐变分为轴向渐变和径向渐变。渐变的颜色变化有很多，可以是一种颜色到另一种颜色过度，也可以是多种颜色依次过度变化，还有是一种颜色的透明度<code>alpha</code>变化，但是这种无法绘制到PDF上，无法打印。</p>
<p><code>CGShading</code>和<code>CGGradient</code>的区别：</p>
<table>
<thead>
<tr>
<th style="text-align:left">CGGradient</th>
<th style="text-align:left">CGShading</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">可以使用同一对象绘制轴向和径向梯度</td>
<td style="text-align:left">需要创建单独的对象的轴向和径向梯度</td>
</tr>
<tr>
<td style="text-align:left">在绘图时设置渐变的几何体</td>
<td style="text-align:left">在对象创建时间设置渐变的几何体</td>
</tr>
<tr>
<td style="text-align:left">Quartz计算梯度中每个点的颜色</td>
<td style="text-align:left">需要提供一个回调函数，用来计算渐变中每个点的颜色</td>
</tr>
<tr>
<td style="text-align:left">可以定义两个以上的位置和颜色</td>
<td style="text-align:left">需要设计回调，使用两个以上的位置和颜色</td>
</tr>
</tbody>
</table>
<h3 id="CGGradient"><a href="#CGGradient" class="headerlink" title="CGGradient"></a>CGGradient</h3><p>使用CGGradient创建渐变。</p>
<ol>
<li>首先调用函数<code>CGGradientCreateWithColorComponents</code>创建<code>CGGradient</code>对象，参数含义分别是：颜色空间、颜色数组（采用RGBA颜色）、位置数组（0.0-1.0之间的数值，0.0为轴线起点，1.0为轴线终点。传递NULL默认0为起始位置，1为终点位置，相当于{0.0, 1.0}）、数组中元素个数。</li>
<li>调用<code>CGContextDrawLinearGradient</code>函数绘制轴向渐变或<code>CGContextDrawRadialGradient</code>函数绘制径向渐变，参数含义分别是：图形上下文、<code>CGGradient</code>对象、起始位置、终止位置、绘图选项。</li>
<li>绘制完毕后，释放颜色空间和<code>CGGradient</code>对象。</li>
</ol>
<p>绘制轴向渐变:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGFloat compoents[] = &#123;1,0,1,1, 0.3,0.5,1,1.0&#125;;</div><div class="line">CGFloat locations[] = &#123;0.0, 1.0&#125;;</div><div class="line">CGColorSpaceRef colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);</div><div class="line">CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, compoents, locations, 2);</div><div class="line">CGContextDrawLinearGradient(context, gradient, CGPointMake(0, 0), CGPointMake(0, 100), kCGGradientDrawsBeforeStartLocation);</div><div class="line">CGColorSpaceRelease(colorSpace);</div><div class="line">CGGradientRelease(gradient);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161221-0.png" alt="使用CGGradient绘制轴向渐变"></p>
<p>绘制径向渐变:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGFloat compoents[] = &#123;1,0,1,1, 0.3,0.5,1,1.0&#125;;</div><div class="line">CGFloat locations[] = &#123;0.0, 1.0&#125;;</div><div class="line">CGColorSpaceRef colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);</div><div class="line">CGGradientRef gradient = CGGradientCreateWithColorComponents(colorSpace, compoents, locations, 2);</div><div class="line">CGContextDrawRadialGradient(context, gradient, CGPointMake(200, 50), 20, CGPointMake(200, 400), 70, kCGGradientDrawsAfterEndLocation);</div><div class="line">CGColorSpaceRelease(colorSpace);</div><div class="line">CGGradientRelease(gradient);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161221-1.png" alt="使用CGGradient绘制径向渐变"></p>
<h3 id="CGShading"><a href="#CGShading" class="headerlink" title="CGShading"></a>CGShading</h3><p>绘制轴向渐变需要以下步骤：</p>
<ol>
<li>设置 CGFunction 对象来计算颜色值</li>
<li>创建轴向渐变的 CGShading 对象</li>
<li>裁减上下文</li>
<li>使用 CGShading 对象来绘制轴向渐变</li>
<li>释放对象</li>
</ol>
<p>绘制轴向渐变完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    [super drawRect:rect];</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    CGFunctionRef functionObj = getFunction(colorspace);</div><div class="line">    CGShadingRef shading = CGShadingCreateAxial(colorspace, CGPointMake(0, 0.5), CGPointMake(1, 0.5), functionObj, false, false);</div><div class="line">    CGAffineTransform myTransform = CGAffineTransformMakeScale(100, 100);</div><div class="line">    CGContextConcatCTM (context, myTransform);</div><div class="line">    CGContextSaveGState (context);</div><div class="line">    CGContextBeginPath(context);</div><div class="line">    CGContextAddArc(context,  .5, .5, .3, 0, M_PI, 0);</div><div class="line">    CGContextClosePath(context);</div><div class="line">    CGContextClip(context);</div><div class="line">    CGContextDrawShading(context, shading);</div><div class="line">    CGShadingRelease(shading);</div><div class="line">    CGColorSpaceRelease(colorspace);</div><div class="line">    CGFunctionRelease(functionObj);</div><div class="line">    CGContextRestoreGState (context);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static CGFunctionRef getFunction(CGColorSpaceRef colorspace) &#123;</div><div class="line">    size_t numComponents = 1 + CGColorSpaceGetNumberOfComponents(colorspace);</div><div class="line">    CGFloat input_value_range[] = &#123;0, 1&#125;;</div><div class="line">    CGFloat output_value_range[] = &#123;0, 1, 0, 0, 0,0,1,1&#125;;</div><div class="line">    CGFunctionCallbacks callbacks = &#123;0, &amp;calculateShadingValues, NULL&#125;;</div><div class="line">    return CGFunctionCreate((void *) numComponents, 1, input_value_range, numComponents, output_value_range, &amp;callbacks);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void calculateShadingValues(void *info, const CGFloat *in, CGFloat *out) &#123;</div><div class="line">    CGFloat v;</div><div class="line">    size_t k, compoents;</div><div class="line">    static const CGFloat c[] = &#123;1,0,0.5,1&#125;;</div><div class="line">    compoents = (size_t)info;</div><div class="line">    v = *in;</div><div class="line">    for (k = 0; k &lt; compoents - 1; k ++)</div><div class="line">        *out ++ = c[k] * v;</div><div class="line">    *out++ = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161221-2.png" alt="使用CGShading绘制轴向渐变"></p>
<p>绘制径向渐变，需要以下步骤：</p>
<ol>
<li>设置 CGFunction 对象来计算颜色值</li>
<li>创建径向渐变的 CGShading 对象</li>
<li>使用 CGShading 对象来绘制径向渐变</li>
<li>释放对象</li>
</ol>
<p>绘制径向渐变完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    [super drawRect:rect];</div><div class="line"></div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    </div><div class="line">    CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();</div><div class="line">    CGFunctionRef functionObj = getFunction(colorspace);</div><div class="line">    CGShadingRef shading = CGShadingCreateRadial(colorspace, CGPointMake(0.25, 0.3), 0.1, CGPointMake(0.7, 0.7), 0.25, functionObj, false, false);</div><div class="line"></div><div class="line">    CGAffineTransform myTransform = CGAffineTransformMakeScale(100, 100);</div><div class="line">    CGContextConcatCTM (context, myTransform);</div><div class="line">    CGContextSaveGState (context);</div><div class="line">    </div><div class="line">    CGContextClipToRect (context, CGRectMake(0, 0, 1, 1));</div><div class="line">    CGContextSetRGBFillColor (context, 1, 1, 1, 1);</div><div class="line">    CGContextFillRect (context, CGRectMake(0, 0, 1, 1));</div><div class="line">    </div><div class="line">    CGContextDrawShading(context, shading);</div><div class="line">    </div><div class="line">    CGShadingRelease(shading);</div><div class="line">    CGColorSpaceRelease(colorspace);</div><div class="line">    CGFunctionRelease(functionObj);</div><div class="line">    CGContextRestoreGState (context);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static CGFunctionRef getFunction(CGColorSpaceRef colorspace) &#123;</div><div class="line">    size_t numComponents = 1 + CGColorSpaceGetNumberOfComponents(colorspace);</div><div class="line">    </div><div class="line">    CGFloat input_value_range[] = &#123;0, 1&#125;;</div><div class="line">    CGFloat output_value_range[] = &#123;0, 1, 0, 0, 0,0,1,1&#125;;</div><div class="line">    </div><div class="line">    CGFunctionCallbacks callbacks = &#123;0, &amp;calculateShadingValues, NULL&#125;;</div><div class="line">    return CGFunctionCreate((void *) numComponents, 1, input_value_range, numComponents, output_value_range, &amp;callbacks);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">static void calculateShadingValues(void *info, const CGFloat *in, CGFloat *out) &#123;</div><div class="line">    </div><div class="line">    size_t k, compoents;</div><div class="line">    double frequency[] = &#123;55, 220, 110, 0&#125;;</div><div class="line">    compoents = (size_t)info;</div><div class="line">    for (k = 0; k &lt; compoents - 1; k ++)</div><div class="line">        *out++ = (1 + sin(*in * frequency[k])) / 2;</div><div class="line">    *out++ = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161221-3.png" alt="使用CGShading绘制径向渐变"></p>
<hr>
<p>参考文章：<a href="http://southpeak.github.io/categories/translate/" target="_blank" rel="external">南峰子翻译的Quartz2D编程指南</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Pattern&quot;&gt;&lt;a href=&quot;#Pattern&quot; class=&quot;headerlink&quot; title=&quot;Pattern&quot;&gt;&lt;/a&gt;Pattern&lt;/h2&gt;&lt;p&gt;Pattern可翻译为样式、模型。类似于iOS中自定义的view，可以重复多次把自定义的view添加到控制器的view上。样式(Pattern)是绘制操作的一个序列，可以重复的绘制到一个图形上下文上。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Quartz2D" scheme="http://markmiao.com/tags/Quartz2D/"/>
    
  </entry>
  
  <entry>
    <title>Quartz 2D（二）颜色和颜色空间、变换</title>
    <link href="http://markmiao.com/2016/12/19/Quartz2D2/"/>
    <id>http://markmiao.com/2016/12/19/Quartz2D2/</id>
    <published>2016-12-19T02:51:34.000Z</published>
    <updated>2016-12-21T07:02:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="颜色和颜色空间"><a href="#颜色和颜色空间" class="headerlink" title="颜色和颜色空间"></a>颜色和颜色空间</h2><p>不同设备的颜色处理方式各不相同，每种设备都有各自的颜色值范围。就是使用指定函数解析一组数值组成的颜色信息，比如RGB颜色、CMYK颜色。</p>
<a id="more"></a>
<p>在不同颜色空间下，蓝色的色值</p>
<table>
<thead>
<tr>
<th style="text-align:left">颜色空间</th>
<th style="text-align:left">蓝色的色值</th>
<th style="text-align:left">色值对应的参数含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">HSB</td>
<td style="text-align:left">240度，100%，100%</td>
<td style="text-align:left">色相，饱和度，亮度</td>
</tr>
<tr>
<td style="text-align:left">RGB</td>
<td style="text-align:left">0，0，1</td>
<td style="text-align:left">红，绿，蓝</td>
</tr>
<tr>
<td style="text-align:left">CMYK</td>
<td style="text-align:left">1，1，0，0</td>
<td style="text-align:left">蓝绿、品红、黄、黑</td>
</tr>
<tr>
<td style="text-align:left">BGR</td>
<td style="text-align:left">1，0，0</td>
<td style="text-align:left">蓝，绿，红</td>
</tr>
</tbody>
</table>
<h2 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h2><p>使用函数<code>CGContextSetAlpha</code>设置全局透明度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextSetAlpha(context, 0.5);</div></pre></td></tr></table></figure>
<p>使用函数<code>CGContextClearRect</code>清除图形上下文的alpha通道。在创建透明遮罩或者窗口完全透明的时候使用。</p>
<h2 id="创建颜色空间"><a href="#创建颜色空间" class="headerlink" title="创建颜色空间"></a>创建颜色空间</h2><h3 id="设备依赖颜色空间"><a href="#设备依赖颜色空间" class="headerlink" title="设备依赖颜色空间"></a>设备依赖颜色空间</h3><p><strong>iOS不支持设备依赖颜色空间。</strong></p>
<ol>
<li>lba非线性转换，使用<code>CGColorSpaceCreateLab</code>创建</li>
<li>ICC颜色空间，国际色彩联盟定义的，使用<code>CGColorSpaceCreateICCBased</code>创建</li>
<li>标准化RGB颜色空间，使用<code>CGColorSpaceCreateCalibratedRGB</code>创建</li>
<li>标准化灰度颜色空间，使用<code>CGColorSpaceCreateCalibratedGray</code>创建</li>
</ol>
<h3 id="通用颜色空间"><a href="#通用颜色空间" class="headerlink" title="通用颜色空间"></a>通用颜色空间</h3><p><strong>iOS不支持通用颜色空间。</strong></p>
<p>但是macOS应用程序通常情况下使用通用颜色空间，而不使用设备颜色空间。</p>
<p>使用函数<code>CGColorSpaceCreateWithName</code>创建通用颜色空间，传入固定常量：</p>
<ol>
<li><code>kCGColorSpaceGenericGray</code>，指定通用灰色</li>
<li><code>kCGColorSpaceGenericRGB</code>，指定通用RGB</li>
<li><code>kCGColorSpaceGenericCMYK</code>，指定通用CMYK</li>
</ol>
<h3 id="设备颜色空间"><a href="#设备颜色空间" class="headerlink" title="设备颜色空间"></a>设备颜色空间</h3><p>设备颜色空间主要用于IOS应用程序。通过以下函数创建设备颜色空间：</p>
<p><code>CGColorSpaceCreateDeviceGray</code> 创建设备依赖灰度颜色空间。</p>
<p>快速设置依赖灰度颜色空间的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CGContextSetGrayStrokeColor(context, 0.5, 1);</div><div class="line">CGContextSetGrayFillColor(context, 0.5, 1);</div></pre></td></tr></table></figure>
<p>还可以使用该函数获取灰度图片，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)getGrayImage:(UIImage*)sourceImage &#123;</div><div class="line">    CGFloat width = sourceImage.size.width;</div><div class="line">    CGFloat height = sourceImage.size.height;</div><div class="line">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();</div><div class="line">    CGContextRef context = CGBitmapContextCreate(nil,width,height,8,0,colorSpace,kCGImageAlphaNone);</div><div class="line">    CGColorSpaceRelease(colorSpace);</div><div class="line">    if (context == NULL) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    CGContextDrawImage(context,CGRectMake(0, 0, width, height), sourceImage.CGImage);</div><div class="line">    UIImage *grayImage = [UIImage imageWithCGImage:CGBitmapContextCreateImage(context)];</div><div class="line">    CGContextRelease(context);</div><div class="line">    return grayImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161215-0.png" alt="正常图片和灰度处理的图片"></p>
<p><code>CGColorSpaceCreateDeviceRGB</code> 创建设备依赖RGB颜色空间，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGFloat colors[4] = &#123;0.3, 1.0, 0.9, 1.0&#125;;</div><div class="line">CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</div><div class="line">CGColorRef color = CGColorCreate(colorSpace, colors);</div><div class="line">CGContextSetFillColorWithColor(context, color);</div><div class="line">CGContextFillRect(context, CGRectMake(100, 50, 100, 50));</div><div class="line">CGColorSpaceRelease(colorSpace);</div><div class="line">CGColorRelease(color);</div></pre></td></tr></table></figure>
<p>以及快速设置设备依赖RGB颜色空间的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CGContextSetRGBStrokeColor(context, 0.3, 1.0, 0.9, 1.0);</div><div class="line">CGContextSetRGBFillColor(context, 0.3, 1.0, 0.9, 1.0);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161215-1.png" alt="设备依赖RGB颜色空间"></p>
<p><code>CGColorSpaceCreateDeviceCMYK</code> 创建设备依赖CMYK颜色空间，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGFloat colors[] = &#123;80, 100, 0, 0, 1.0&#125;;</div><div class="line">CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceCMYK();</div><div class="line">CGColorRef color = CGColorCreate(colorSpace, colors);</div><div class="line">CGContextSetFillColorWithColor(context, color);</div><div class="line">CGContextFillRect(context, CGRectMake(100, 50, 100, 50));</div><div class="line">CGColorSpaceRelease(colorSpace);</div><div class="line">CGColorRelease(color);</div></pre></td></tr></table></figure>
<p>以及快速设置设备依赖CMYK颜色空间的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CGContextSetCMYKStrokeColor(context, 80, 100, 0, 0, 1.0);</div><div class="line">CGContextSetCMYKFillColor(context, 80, 100, 0, 0, 1.0);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161215-2.png" alt="设备依赖CMYK颜色空间"></p>
<h2 id="设置和创建颜色"><a href="#设置和创建颜色" class="headerlink" title="设置和创建颜色"></a>设置和创建颜色</h2><p>通过函数<code>CGContextSetStrokeColorWithColor</code>和<code>CGContextSetFillColorWithColor</code>分别填充路径颜色和设置线框颜色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextSetLineWidth(context, 20);</div><div class="line">CGContextAddRect(context, CGRectMake(100, 50, 100, 50));</div><div class="line">CGContextSetStrokeColorWithColor(context, [UIColor blueColor].CGColor);</div><div class="line">CGContextStrokePath(context);</div><div class="line">CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor);    </div><div class="line">CGContextFillRect(context, CGRectMake(100, 50, 100, 50));</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161215-3.png" alt="填充路径设置线框"></p>
<h2 id="设置再现意图"><a href="#设置再现意图" class="headerlink" title="设置再现意图"></a>设置再现意图</h2><p>“再现意图”用于指定如何将源颜色空间的颜色映射到图形上下文的目标颜色空间的颜色范围内。调用函数<code>CGContextSetRenderingIntent</code>设置再现意图，传入枚举类型<code>CGColorRenderingIntent</code></p>
<ol>
<li>kCGRenderingIntentDefault：使用默认的渲染意图。</li>
<li>kCGRenderingIntentAbsoluteColorimetric：绝对色度渲染意图。将输出设备颜色域外的颜色映射为输出设备域内与之最接近的颜色。这可以产生一个裁减效果，因为色域外的两个不同的颜色值可能被映射为色域内的同一个颜色值。当图形使用的颜色值同时包含在源色域及目标色域内时，这种方法是最好的。常用于logo或者使用专色(spot color)时。</li>
<li>kCGRenderingIntentRelativeColorimetric：相对色度渲染意图。转换所有的颜色(包括色域内的)，以补偿图形上下文的白点与输出设备白点之间的色差。kCGRenderingIntentPerceptual：感知渲染意图。通过压缩图形上下文的色域来适应输出设备的色域，并保持源颜色空间的颜色之间的相对性。感知渲染意图适用于相片及其它复杂的高细度图片。</li>
<li>kCGRenderingIntentSaturation：饱和度渲染意图。把颜色转换到输出设备色域内时，保持颜色的相对饱和度。结果是包含亮度、饱和度颜色的图片。饱和度意图适用于生成低细度的图片，如描述性图表。</li>
</ol>
<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><p>变换是使用Quartz内置的变换函数对绘图进行平移、旋转和缩放变换。</p>
<h2 id="修改CTM"><a href="#修改CTM" class="headerlink" title="修改CTM"></a>修改CTM</h2><p>CTM是Current Transformation Matrix，当前变换矩阵。可以操作CTM来平移、旋转、缩放page，绘制对象在page上，自然也会变换。</p>
<p>通过<code>CGContextDrawImage</code>函数绘制图片到page上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextDrawImage(context, CGRectMake(20, 40, 100, 150), [UIImage imageNamed:@&quot;img&quot;].CGImage);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161215-4.png" alt="将图片绘制到page上"></p>
<p>可以看到，图片是上下颠倒的。是因为iOS的UIKit坐标是以左上角为原点，y轴向下，Quartz 2D的图形绘制引擎坐标是左下角为原点，y轴向上。因为坐标轴上下相反，所以图片上下颠倒。macOS的坐标布局和Quartz 2D一样，以左下角为坐标原点，y轴向上。</p>
<p>注意要先进行CTM变换操作，再<code>CGContextDrawImage</code>画图。</p>
<h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><p>调用函数<code>CGContextTranslateCTM</code>指定沿x轴和y轴的平移位置。沿x轴平移100，沿y轴平移50：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextTranslateCTM(context, 100, 50);</div></pre></td></tr></table></figure>
<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>调用函数<code>CGContextRotateCTM</code>指定旋转角度，是以坐标原点为中心，旋转指定角度。这个坐标原点是指iOS的UIKit的左上角坐标原点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextRotateCTM(context, M_PI_4);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161215-5.png" alt="旋转前与旋转后的图片比较"></p>
<p>函数传入的是弧度值，可以定义以下方法，传入角度值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static inline double radians (double degrees) &#123;return degrees * M_PI/180;&#125;</div></pre></td></tr></table></figure>
<p>等价于上面的旋转函数调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextRotateCTM(context, radians(45.));</div></pre></td></tr></table></figure>
<h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>调用函数<code>CGContextScaleCTM</code>实现缩放操作，也是以坐标原点为中心，x，y，w，h皆缩放为指定比例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextScaleCTM(context, 0.5, 0.5);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161215-6.png" alt="缩放前后的图片比较"></p>
<h3 id="累计变换操作"><a href="#累计变换操作" class="headerlink" title="累计变换操作"></a>累计变换操作</h3><p>上文说道，使用<code>CGContextDrawImage</code>函数画的图片上下颠倒，可以使用累计变换操作将图片扶正。累计变换操作的执行顺序不同，会导致不同结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CGRect imgRect = CGRectMake(100, 40, 100, 130);</div><div class="line">CGContextTranslateCTM(context, imgRect.size.width + imgRect.origin.x * 2, imgRect.size.height + imgRect.origin.y * 2);</div><div class="line">CGContextRotateCTM(context, M_PI);</div><div class="line">CGContextDrawImage(context, imgRect, [UIImage imageNamed:@&quot;img&quot;].CGImage);</div></pre></td></tr></table></figure>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161216-0.png" alt="图片扶正结果"></p>
<h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>仿射变换可以实现与CTM函数相同的变换操作，使用仿射变换函数构造矩阵，调用函数<code>CGContextConcatCTM</code>应用于CTM，达到变换效果。</p>
<p>仿射变换函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CGAffineTransformMakeTranslation</td>
<td style="text-align:left">构造平移矩阵，指定移动x,y值</td>
</tr>
<tr>
<td style="text-align:left">CGAffineTransformTranslate</td>
<td style="text-align:left">在现有的变换操作基础上使用平移操作</td>
</tr>
<tr>
<td style="text-align:left">CGAffineTransformMakeRotation</td>
<td style="text-align:left">构造旋转矩阵，指定旋转弧度</td>
</tr>
<tr>
<td style="text-align:left">CGAffineTransformRotate</td>
<td style="text-align:left">在现有的变换操作基础上使用旋转操作</td>
</tr>
<tr>
<td style="text-align:left">CGAffineTransformMakeScale</td>
<td style="text-align:left">构造缩放矩阵，指定x,y拉伸或收缩坐标</td>
</tr>
<tr>
<td style="text-align:left">CGAffineTransformScale</td>
<td style="text-align:left">在现有的变换操作基础上使用旋转操作</td>
</tr>
</tbody>
</table>
<p>构造变换矩阵的函数应用，执行结果和上文中图片一样，等价于上文中CTM函数变换操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//平移</div><div class="line">CGAffineTransform translation = CGAffineTransformMakeTranslation(100, 50);</div><div class="line">CGContextConcatCTM(context, translation);</div><div class="line">//旋转</div><div class="line">CGAffineTransform rotation = CGAffineTransformMakeRotation(M_PI_4);</div><div class="line">CGContextConcatCTM(context, rotation);</div><div class="line">//缩放</div><div class="line">CGAffineTransform scale = CGAffineTransformMakeScale(0.5, 0.5);</div><div class="line">CGContextConcatCTM(context, scale);</div></pre></td></tr></table></figure>
<p>在当前变换的基础上叠加变换操作，和上文中的累计变换操作等价：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CGAffineTransform translate = CGAffineTransformTranslate(CGContextGetCTM(context), 100, 50);</div><div class="line">CGAffineTransform rotate = CGAffineTransformRotate(translate, M_PI_4);</div><div class="line">CGAffineTransform scale = CGAffineTransformScale(rotate, 0.5, 0.5);</div><div class="line">CGContextConcatCTM(context, scale);</div></pre></td></tr></table></figure>
<hr>
<p>参考文章：<a href="http://southpeak.github.io/categories/translate/" target="_blank" rel="external">南峰子翻译的Quartz2D编程指南</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;颜色和颜色空间&quot;&gt;&lt;a href=&quot;#颜色和颜色空间&quot; class=&quot;headerlink&quot; title=&quot;颜色和颜色空间&quot;&gt;&lt;/a&gt;颜色和颜色空间&lt;/h2&gt;&lt;p&gt;不同设备的颜色处理方式各不相同，每种设备都有各自的颜色值范围。就是使用指定函数解析一组数值组成的颜色信息，比如RGB颜色、CMYK颜色。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Quartz2D" scheme="http://markmiao.com/tags/Quartz2D/"/>
    
  </entry>
  
  <entry>
    <title>Quartz 2D（一）概念、图形上下文、路径</title>
    <link href="http://markmiao.com/2016/12/13/Quartz2D1/"/>
    <id>http://markmiao.com/2016/12/13/Quartz2D1/</id>
    <published>2016-12-13T08:59:51.000Z</published>
    <updated>2016-12-13T09:47:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>Quartz 2D是二维图形绘制引擎，可以实现N多图形图像的操作功能，如基本路径的绘制、透明度、描影、绘制阴影、透明层、颜色管理、反锯齿、PDF文档生成和PDF元数据访问。</p>
<a id="more"></a>
<h2 id="画布Page"><a href="#画布Page" class="headerlink" title="画布Page"></a>画布Page</h2><p>在图像操作过程中使用了<code>绘画者模型</code>，绘制过程是将绘制层铺到画布上，这个画布称为<code>Page</code>。类似于Photoshop中，将每个图层叠加放在画布上，形成最后的图像。</p>
<h2 id="图形上下文Graphics-Context"><a href="#图形上下文Graphics-Context" class="headerlink" title="图形上下文Graphics Context"></a>图形上下文Graphics Context</h2><p><code>图形上下文(Graphics Context)</code>是一个数据类型<code>CGContextRef</code>，它存放了Quartz 2D绘制的图形输出信息，可以看做是图形到设备输出的介质工具。Quartz 2D绘制的图形可以放到多种设备上，比如：PDF文件、显示器窗口、bitmap(位图)、view的Layer层等等，这就需要不同的<code>Graphics Context</code>来完成输出到不同设备上的工作。这好比人要上高速需要汽车，去海上需要船，去天空需要飞机，这里人相当于图形，高速路、海、天空相当于设备，而汽车、船、飞机就是<code>Graphics Context</code>。</p>
<p><code>Graphics Context</code>的几种类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. Bitmap Graphics Context</div><div class="line">2. PDF Graphics Context</div><div class="line">3. Window Graphics Context</div><div class="line">4. Layer Context</div><div class="line">5. Post Graphics Context</div></pre></td></tr></table></figure>
<h2 id="Quartz-2D的数据类型"><a href="#Quartz-2D的数据类型" class="headerlink" title="Quartz 2D的数据类型"></a>Quartz 2D的数据类型</h2><p>Quartz 2D API属于Code Graphics框架，所以Quartz 2D的数据类型是以CG开头的。有以下数据类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1. CGPathRef：用于向量图，可创建路径，并进行填充或描画(stroke)</div><div class="line">2. CGImageRef：用于表示bitmap图像和基于采样数据的bitmap图像遮罩。</div><div class="line">3. CGLayerRef：用于表示可用于重复绘制(如背景)和幕后(offscreen)绘制的绘画层</div><div class="line">4. CGPatternRef：用于重绘图</div><div class="line">5. CGShadingRef、CGGradientRef：用于绘制渐变</div><div class="line">6. CGFunctionRef：用于定义回调函数，该函数包含一个随机的浮点值参数。当为阴影创建渐变时使用该类型</div><div class="line">7. CGColorRef, CGColorSpaceRef：用于告诉Quartz如何解释颜色</div><div class="line">8. CGImageSourceRef,CGImageDestinationRef：用于在Quartz中移入移出数据</div><div class="line">9. CGFontRef：用于绘制文本</div><div class="line">10. CGPDFDictionaryRef, CGPDFObjectRef, CGPDFPageRef, CGPDFStream, CGPDFStringRef, and CGPDFArrayRef：用于访问PDF的元数据</div><div class="line">11. CGPDFScannerRef, CGPDFContentStreamRef：用于解析PDF元数据</div><div class="line">12. CGPSConverterRef：用于将PostScript转化成PDF。在iOS中不能使用。</div></pre></td></tr></table></figure>
<h2 id="图形状态"><a href="#图形状态" class="headerlink" title="图形状态"></a>图形状态</h2><p>Quartz通过修改图形状态来修改绘制结果，图形状态直接决定了图形的最终渲染结果。图形状态包含用于绘制程序的参数，绘制参数改变了，图形自然就变了。比如修改了填充色值，图形颜色就变了。</p>
<h2 id="iOS中使用Graphics-Context绘制图形"><a href="#iOS中使用Graphics-Context绘制图形" class="headerlink" title="iOS中使用Graphics Context绘制图形"></a>iOS中使用Graphics Context绘制图形</h2><p>在iOS中要想用Quartz 2D在屏幕上绘图，需要自定义一个UIView，在UIView的<code>- (void)drawRect:(CGRect)rect</code>方法中实现绘图操作，这个方法会在UIView显示在屏幕上和需要被刷新的时候调用。创建上下文的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上下文中绘制图形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    //获取图形上下文</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    //设置红色透明度0.5的填充色</div><div class="line">    CGContextSetRGBFillColor(context, 1, 0, 0, 0.5);</div><div class="line">    //填充一个矩形frame为(10, 20, 100, 40)</div><div class="line">    CGContextFillRect(context, CGRectMake(10, 20, 100, 40));</div><div class="line">    //设置蓝色透明度0.5的填充色</div><div class="line">    CGContextSetRGBFillColor(context, 0, 0, 1, 0.5);</div><div class="line">    //填充一个矩形frame为(10, 20, 40,  100)</div><div class="line">    CGContextFillRect(context, CGRectMake(10, 20, 40, 100));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161209-0.png?raw=true" alt="显示结果"></p>
<p>注意：设置填充色和填充矩形的方法顺序不能颠倒，不然填充色填充不到想填充的矩形中。得不到填充色填充的会是黑色。</p>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>路径可以构建出多种图形，可以是点、直线、弧线、不规则线、规则或不规则形状，可以对闭合路径进行填充行程面。使用路径绘制出想要的图形，有两步：创建路径和绘制路径。创建出点、线等路径，使用函数<code>CGContextDrawPath</code>绘制路径。</p>
<h3 id="点"><a href="#点" class="headerlink" title="点"></a>点</h3><p>点是依靠x、y值固定的位置，可作为路径的起始点位置。比如要画一个线段，必须要有一个起点和一个终点，两点确定一条线段。使用函数<code>CGContextMoveToPoint</code>来确定起始点，传入图形上下文和x,y坐标点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//确定一个坐标为(10,10)的点</div><div class="line">CGContextMoveToPoint(context, 10, 10);</div></pre></td></tr></table></figure>
<h3 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h3><p>有起始点，再指定一个终点位置就能确定一条直线了，使用函数<code>CGContextAddLineToPoint</code>来指定终点位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">	  //获取图形上下文</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    //设置起点</div><div class="line">    CGContextMoveToPoint(context, 20, 20);</div><div class="line">    //起点延长至终点位置</div><div class="line">    CGContextAddLineToPoint(context, 50, 50);</div><div class="line">    //绘制路径</div><div class="line">    CGContextDrawPath(context, kCGPathStroke);    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以使用<code>CGContextAddLineToPoint</code>函数指定多个位置点，线段会一个接一个画下去，形成折线图形。也可以使用<code>CGContextAddLines</code>函数一次性指定多个位置点，完成折线图形，此时无需指定起始点，第一个点默认为起始点(即使用<code>CGContextMoveToPoint</code>指定起始点也无效)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//一个一个点继续加</div><div class="line">CGContextMoveToPoint(context, 20, 20);    </div><div class="line">CGContextAddLineToPoint(context, 50, 50);</div><div class="line">CGContextAddLineToPoint(context, 30, 80);</div><div class="line"></div><div class="line">//一次性指定多个点</div><div class="line">CGPoint pos[3] = &#123;CGPointMake(80, 20), CGPointMake(20, 50), CGPointMake(100, 200)&#125;;</div><div class="line">CGContextAddLines(context, pos, 3);</div></pre></td></tr></table></figure>
<p>由于<code>CGContextAddLineToPoint</code>函数必须得有<code>CGContextMoveToPoint</code>函数固定起始点，<code>CGContextAddLines</code>函数默认第一个点为起始点，所以<code>CGContextAddLines</code>后面可以跟着<code>CGContextAddLineToPoint</code>继续加点画线，能连成一组折线，而<code>CGContextMoveToPoint</code>+<code>CGContextAddLineToPoint</code>画线后面不能跟<code>CGContextAddLines</code>，会画成两组无关联的折线。</p>
<h3 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h3><p>画圆弧提供了两个函数，一个是<code>CGContextAddArc</code>，依次指定<code>图形上下文</code>、<code>圆心坐标</code>、<code>半径</code>、<code>起始弧度</code>、<code>终止弧度</code>、<code>画线顺时针(1)或逆时针(0)</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextAddArc(context, 100, 200, 30, 0, M_PI, 0);</div><div class="line">CGContextDrawPath(context, kCGPathStroke);</div></pre></td></tr></table></figure>
<p>第二个函数是<code>CGContextAddArcToPoint</code>，三点+半径确定一个圆弧。<code>CGContextMoveToPoint</code>函数确定第一个点，<code>CGContextAddArcToPoint</code>添加第二个点、第三个点和还有半径。原理：以第二点为中心，分别向第一点、第三点延长两条射线，射线夹角小于180°的一侧，以指定半径画圆弧，圆弧与射线相切。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextMoveToPoint(context, 100, 100);</div><div class="line">CGContextAddArcToPoint(context, 100, 150, 150, 150, 50);</div><div class="line">CGContextDrawPath(context, kCGPathStroke);</div></pre></td></tr></table></figure>
<h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><p>画Bezier曲线也提供了两个函数，函数<code>CGContextAddCurveToPoint</code>用于画三次Bezier曲线，由一个起点、一个终点和两个控制点构成一条三次Bezier曲线。当两个控制点在起点和终点连线的同侧时，曲线会只有一个拱向，在不同侧时有两个拱向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextMoveToPoint(context, 100, 100);</div><div class="line">CGContextAddCurveToPoint(context, 150, 50, 200, 200, 300, 100);</div><div class="line">CGContextDrawPath(context, kCGPathStroke);</div></pre></td></tr></table></figure>
<p>画二次Bezier曲线，使用函数CGContextAddQuadCurveToPoint。以当前点为起始点，指定一个控制点一个终点，确定一条二次Bezier曲线。控制点决定了曲线拱的方向，该函数只能创建一个拱向的Bezier曲线，而且曲线不可能交叉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextMoveToPoint(context, 100, 100);</div><div class="line">CGContextAddQuadCurveToPoint(context, 200, 200, 300, 100);</div><div class="line">CGContextDrawPath(context, kCGPathStroke);</div></pre></td></tr></table></figure>
<h3 id="闭合路径"><a href="#闭合路径" class="headerlink" title="闭合路径"></a>闭合路径</h3><p>Quartz 2D提供函数<code>CGContextClosePath</code>来闭合路径。就是将终点和起点用直线连接起来，使整个路径闭合。对于直线、弧、曲线等不能自动闭合的路径，如果想完成路径闭合必须调用该函数。</p>
<p>调用了<code>CGContextClosePath</code>完成闭合路径后，再调用<code>Add...</code>添加路径的函数，添加直线、弧线、曲线等路径，会从闭合路径的起始点开始。如果没有完成闭合路径函数的调用，则从终点继续开始新添加的路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextMoveToPoint(context, 100, 100);</div><div class="line">CGContextAddCurveToPoint(context, 150, 50, 150, 200, 300, 100);</div><div class="line">CGContextClosePath(context);</div><div class="line">CGContextAddLineToPoint(context, 200, 500);</div><div class="line">CGContextDrawPath(context, kCGPathStroke);</div></pre></td></tr></table></figure>
<h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><p>使用函数<code>CGContextAddRect</code>来画矩形，函数中的<code>rect</code>中x,y是矩形左上角，宽高是矩形的宽高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextAddRect(context, CGRectMake(20, 20, 100, 40));</div><div class="line">CGContextDrawPath(context, kCGPathStroke);</div></pre></td></tr></table></figure>
<h3 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h3><p>使用函数<code>CGContextAddEllipseInRect</code>来画椭圆，是以矩形来确定椭圆。坐标参数意义和矩形一样，以确定的矩形内切画出的椭圆。矩形的圆心即是椭圆的圆心，矩形的宽高即是椭圆的长轴短轴，当矩形的宽高相等时，椭圆就是一个圆了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">CGContextAddEllipseInRect(context, CGRectMake(0, 0, 30, 50));</div><div class="line">CGContextDrawPath(context, kCGPathStroke);</div></pre></td></tr></table></figure>
<h2 id="创建路径"><a href="#创建路径" class="headerlink" title="创建路径"></a>创建路径</h2><ul>
<li>在开始绘制路径前，调用 CGContextBeginPath 或 UI。</li>
<li>直线、弧、曲线开始于当前点。空路径没有当前点；我们必须调用CGContextMoveToPoint来设置第一个子路径的起始点，或者调用一个便利函数来隐式地完成该任务。</li>
<li>如果要闭合当前子路径，调用函数 CGContextClosePath。随后路径将开始一个新的子路径，即使我们不显示设置一个新的起始点。</li>
<li>当绘制弧时，Quartz 将在当前点与弧的起始点间绘制一条直线。</li>
<li>添加椭圆和矩形的 Quartz 程序将在路径中添加新的闭合子路径。</li>
<li>我们必须调用绘制函数来填充或者描边一条路径，因为创建路径时并不会绘制路径。</li>
<li>Quartz 提供了两个数据类型来创建可复用路径 CGPathRef 和 CGMutablePathRef。</li>
<li>Quartz 提供了一个类似于操作图形上下文的 CGPath 的函数集合。这些路径函数操作 CGPath 对象，而不是图形上下文。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1.	CGPathCreateMutable 取代 CGContextBeginPath</div><div class="line">2.	CGPathMoveToPoint 取代 CGContextMoveToPoint</div><div class="line">3.	CGPathAddLineToPoint 取代 CGContexAddLineToPoint</div><div class="line">4.	CGPathAddCurveToPoint 取代 CGContexAddCurveToPoint</div><div class="line">5.	CGPathAddEllipseInRect 取代 CGContexAddEllipseInRect</div><div class="line">6.	CGPathAddArc 取代 CGContexAddArc</div><div class="line">7.	CGPathAddRect 取代 CGContexAddRect</div><div class="line">8.	CGPathCloseSubpath 取代 CGContexClosePath</div></pre></td></tr></table></figure>
<p>如果想要添加一个路径到图形上下文，可以调用CGContextAddPath。路径将保留在图形上下文中，直到Quartz绘制它。我们可以调用CGContextAddPath再次添加路径。</p>
<h2 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h2><p>通过图形上下文加上一系列创建路径的函数得到最终的路径，还需要绘制路径操作，才能使得路径呈现。如上文中一直用到的绘制路径的函数操作<code>CGContextDrawPath(context, kCGPathStroke);</code>。</p>
<p>绘制路径分为描边和填充，描边是绘制路径的边框，填充是绘制路径所包含的区域。</p>
<h3 id="影响描边的属性"><a href="#影响描边的属性" class="headerlink" title="影响描边的属性"></a>影响描边的属性</h3><table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">解释</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CGContextSetLineWidth</td>
<td style="text-align:left">描边路径的宽度</td>
<td style="text-align:left">单位是用户空间单位</td>
</tr>
<tr>
<td style="text-align:left">CGContextSetLineJoin</td>
<td style="text-align:left">指定描边的连接点样式</td>
<td style="text-align:left">枚举类型:Miter(尖角),Round(圆角),Bevel(平角)</td>
</tr>
<tr>
<td style="text-align:left">CGContextSetLineCap</td>
<td style="text-align:left">指定直线端点样式</td>
<td style="text-align:left">枚举类:Butt,Round,Square</td>
</tr>
<tr>
<td style="text-align:left">CGContextSetMiterLimit</td>
<td style="text-align:left">转角的量级</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">CGContextSetLineDash</td>
<td style="text-align:left">虚线模式</td>
<td style="text-align:left">指定虚线数组和虚线相位控制虚线大小和位置</td>
</tr>
<tr>
<td style="text-align:left">CGContextSetStrokeColorSpace</td>
<td style="text-align:left">描边颜色空间</td>
<td style="text-align:left">封装了颜色和颜色空间的CGColorRef</td>
</tr>
<tr>
<td style="text-align:left">CGContextSetStrokeColor</td>
<td style="text-align:left">设置描边颜色</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">CGContextSetStrokePattern</td>
<td style="text-align:left">笔触模式</td>
</tr>
</tbody>
</table>
<h3 id="填充路径"><a href="#填充路径" class="headerlink" title="填充路径"></a>填充路径</h3><p>填充规则有两种：非零缠绕数规则（nonzero winding number rule）、偶数-奇数规则（even-odd rule）。</p>
<p>默认的填充规则为非零缠绕数规则。方法或枚举带有“EO”的为偶数-奇数规则。</p>
<p>非零缠绕数的填充规则与绘制的方向有关、偶数-奇数规则则与方向无关。如图。</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/eosampleone.gif" alt="非零缠绕数规则和偶数奇数规则"></p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CGContextEOFillPath</td>
<td style="text-align:left">使用偶数奇数规则填充当前路径</td>
</tr>
<tr>
<td style="text-align:left">CGContextFillPath</td>
<td style="text-align:left">使用非零缠绕数规则填充当前路径</td>
</tr>
<tr>
<td style="text-align:left">CGContextFillRect</td>
<td style="text-align:left">快速填充一个矩形</td>
</tr>
<tr>
<td style="text-align:left">CGContextFillRects</td>
<td style="text-align:left">快速填充N个矩形</td>
</tr>
<tr>
<td style="text-align:left">CGContextFillEllipseInRect</td>
<td style="text-align:left">快速填充一个椭圆形</td>
</tr>
<tr>
<td style="text-align:left">CGContextDrawPath</td>
<td style="text-align:left">填充或描边路径</td>
</tr>
</tbody>
</table>
<p>CGContextDrawPath函数的使用：</p>
<ul>
<li>CGContextDrawPath(context, kCGPathFill) 填充路径。</li>
<li>CGContextDrawPath(context, kCGPathEOFill) 使用奇偶规则填充路径。</li>
<li>CGContextDrawPath(context, kCGPathStroke) 描边路径。</li>
<li>CGContextDrawPath(context, kCGPathFillStroke) 填充并描边路径。</li>
<li>CGContextDrawPath(context, kCGPathEOFillStroke) 使用奇偶规则填充并描边路径。</li>
</ul>
<h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><p>混合模式是Quartz将绘图绘制到背景上的方式，其实就是前景图和背景图怎么混合叠加。叠加公式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = (alpha * foreground) + (1 - alpha) *background</div></pre></td></tr></table></figure>
<p>Quartz默认使用普通混合模式，也就是<code>kCGBlendModeNormal</code>。下面举例几个混合模式的样式，案例样式的代码见下一节<code>裁剪路径</code>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">kCGBlendModeNormal</th>
<th style="text-align:center">kCGBlendModeMultiply</th>
<th style="text-align:center">kCGBlendModeScreen</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161213-0.png" alt="普通模式"></td>
<td style="text-align:center"><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161213-1.png" alt="正片叠底"></td>
<td style="text-align:center"><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161213-2.png" alt="屏幕混合"></td>
</tr>
</tbody>
</table>
<p>16种混合模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">kCGBlendModeNormal,		//普通</div><div class="line">kCGBlendModeMultiply,		//正片叠底</div><div class="line">kCGBlendModeScreen,		//屏幕</div><div class="line">kCGBlendModeOverlay,		//叠加</div><div class="line">kCGBlendModeDarken,		//暗化</div><div class="line">kCGBlendModeLighten,		//亮化</div><div class="line">kCGBlendModeColorDodge,		//色彩减淡</div><div class="line">kCGBlendModeColorBurn,		//色彩加深</div><div class="line">kCGBlendModeSoftLight,		//柔光</div><div class="line">kCGBlendModeHardLight,		//强光</div><div class="line">kCGBlendModeDifference,		//差值</div><div class="line">kCGBlendModeExclusion,		//排除</div><div class="line">kCGBlendModeHue,			//色相</div><div class="line">kCGBlendModeSaturation,		//饱和度</div><div class="line">kCGBlendModeColor,		//颜色</div><div class="line">kCGBlendModeLuminosity,		//亮度</div></pre></td></tr></table></figure>
<h2 id="裁剪路径"><a href="#裁剪路径" class="headerlink" title="裁剪路径"></a>裁剪路径</h2><p>裁剪是一个遮罩，会遮住不允许绘制的地方。裁剪区域是一个闭合路径，Quartz只会渲染裁剪区域里面的东西，外面的东西不渲染。通过函数<code>CGContextClip</code>裁剪，具体的裁剪代码和执行结果如下，注意代码位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">/** 裁剪 */</div><div class="line">CGContextBeginPath(context);</div><div class="line">CGContextAddArc(context, 200, 200, 150, 0, 2 * M_PI, 0);</div><div class="line">CGContextClosePath(context);</div><div class="line">CGContextClip(context);</div><div class="line"></div><div class="line">CGContextSetRGBFillColor(context, 0.5, 0.2, 1, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(100, 50, 50, 300));</div><div class="line">CGContextSetRGBFillColor(context, 0.8, 0.3, 0.1, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(150, 50, 50, 300));</div><div class="line">CGContextSetRGBFillColor(context, 0.5, 0.1, 0.4, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(200, 50, 50, 300));</div><div class="line">CGContextSetRGBFillColor(context, 0, 0.5, 0.1, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(250, 50, 50, 300));</div><div class="line">    </div><div class="line">//设置混合模式，自行替换上述16中混合模式查看效果</div><div class="line">CGContextSetBlendMode(context, kCGBlendModeMultiply); </div><div class="line"></div><div class="line">CGContextSetRGBFillColor(context, 0.5, 0.2, 1, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(20, 100, 350, 50));</div><div class="line">CGContextSetRGBFillColor(context, 0.8, 0.3, 0.1, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(20, 150, 350, 50));</div><div class="line">CGContextSetRGBFillColor(context, 0.5, 0.1, 0.4, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(20, 200, 350, 50));</div><div class="line">CGContextSetRGBFillColor(context, 0, 0.5, 0.1, 1);</div><div class="line">CGContextFillRect(context, CGRectMake(20, 250, 350, 50));</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/QQ20161213-3.png" alt="裁剪路径和混合模式的执行结果"></p>
<hr>
<p>参考文章：<a href="http://southpeak.github.io/categories/translate/" target="_blank" rel="external">南峰子翻译的Quartz2D编程指南</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Quartz 2D是二维图形绘制引擎，可以实现N多图形图像的操作功能，如基本路径的绘制、透明度、描影、绘制阴影、透明层、颜色管理、反锯齿、PDF文档生成和PDF元数据访问。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Quartz2D" scheme="http://markmiao.com/tags/Quartz2D/"/>
    
  </entry>
  
  <entry>
    <title>iOS时间问题</title>
    <link href="http://markmiao.com/2016/12/08/iOS%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    <id>http://markmiao.com/2016/12/08/iOS时间问题/</id>
    <published>2016-12-08T02:38:39.000Z</published>
    <updated>2016-12-08T03:37:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发中，经常会遇到各种各样的时间问题，8小时时差，时间戳，求时间间隔，农历等等。解决办法网上比比皆是，但大多零零散散，很多资料并没有说明其中问题。这里集中总结一下，以便于以后查阅和供大家参考。有我自己的理解，错漏之处请大家吐槽。</p>
<a id="more"></a>
<h2 id="NSDate的8小时问题"><a href="#NSDate的8小时问题" class="headerlink" title="NSDate的8小时问题"></a>NSDate的8小时问题</h2><h3 id="NSDate转字符串时间"><a href="#NSDate转字符串时间" class="headerlink" title="NSDate转字符串时间"></a>NSDate转字符串时间</h3><p>初始化一个<code>NSDate</code>时间<code>[NSDate date]</code>，获取的是零时区的时间（格林尼治的时间: 年-月-日 时:分:秒: +时区），而北京时间是东八区时间，因为时区不同，所以打印的时间相差了8小时。此刻表示的时间是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSLog(@&quot;date时间 = %@&quot;, date);</div><div class="line"></div><div class="line">NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</div><div class="line">[formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss Z&quot;];</div><div class="line">NSString *dateStr = [formatter stringFromDate:date];</div><div class="line">NSLog(@&quot;字符串时间 = %@&quot;, dateStr);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-12-07 10:44:24.470 timeTest[32743:2995134] date时间 = 2016-12-07 02:44:24 +0000</div><div class="line">2016-12-07 10:44:24.471 timeTest[32743:2995134] 字符串时间 = 2016-12-07 10:44:24 +0800</div></pre></td></tr></table></figure>
<p>打印结果前面的时间是北京时间：<code>2016-12-07 10:44:24.470</code>。而<code>date</code>打印出来的时间显示少了8小时，因为它表示的是<code>零时区(+0000)</code>时间<code>02:44:24</code>。此刻对应东八区的北京时间就是<code>10:44:24</code>。只是时区不同，表示的时间点是一样的。好比1公斤和2斤，重量是一样的。<code>[NSDate date]</code>获取的时间单位是<code>零时区(+0000)</code>，我们所要的北京时间的单位是<code>东八区(+0800)</code>。</p>
<p>系统会默认<code>[NSDate date]</code>获取的时间为零时区时间，而经过<code>NSDateFormatter</code>转化为字符串时间就是当前所在时区的准确时间，并没有8小时误差。</p>
<h3 id="转字符串时间的时区设定"><a href="#转字符串时间的时区设定" class="headerlink" title="转字符串时间的时区设定"></a>转字符串时间的时区设定</h3><p>上文中NSDate时间转为字符串时间并没有设置<code>NSDateFormatter</code>的<code>timeZone</code>。不设置会默认使用当前所在的时区，与设置系统时区<code>formatter.timeZone = [NSTimeZone systemTimeZone]</code>的效果是一样的。</p>
<p>也可以设置时区，获取指定时区的字符串时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</div><div class="line">[formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</div><div class="line">formatter.timeZone = [NSTimeZone timeZoneWithName:@&quot;Asia/Shanghai&quot;];//东八区时间</div><div class="line">NSString *dateStr = [formatter stringFromDate:date];</div><div class="line">NSLog(@&quot;字符串时间 = %@&quot;, dateStr);</div></pre></td></tr></table></figure>
<p>这时获取的时间就是东八区时间，哪怕手机拿到零时区的格林尼治，获取的也是东八区的时间，因为这里指定时区了。也有如下时区指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">formatter.timeZone = [NSTimeZone timeZoneWithName:@&quot;Asia/Tokyo&quot;];//东九区时间</div><div class="line">formatter.timeZone = [NSTimeZone timeZoneWithName:@&quot;GMT&quot;];//零区时间</div></pre></td></tr></table></figure>
<p>通过下面方法可得到系统支持的时区对应的字符串常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSArray *zones = [NSTimeZone knownTimeZoneNames];</div><div class="line">for (NSString *zone in zones) &#123;</div><div class="line">   NSLog(@&quot;时区名 = %@&quot;, zone);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/timezone.jpg?raw=true" alt="时区对照表"></p>
<h3 id="字符串时间转NSDate"><a href="#字符串时间转NSDate" class="headerlink" title="字符串时间转NSDate"></a>字符串时间转NSDate</h3><p>字符串时间转为NSDate时间也会有时区问题。也会遇到有所谓的8小时误差，其实就是时区不同。比如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</div><div class="line">[formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss Z&quot;];</div><div class="line">NSDate *newDate = [formatter dateFromString:@&quot;2016-12-07 14:06:24 +0800&quot;];</div><div class="line">NSLog(@&quot;newDate = %@&quot;, newDate);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-12-07 14:12:17.468 timeTest[34279:3155380] newDate = 2016-12-07 06:06:24 +0000</div></pre></td></tr></table></figure>
<p><code>NSDateFormatter</code>的指定格式是：<code>@&quot;yyyy-MM-dd HH:mm:ss Z&quot;</code>。这里面的<code>Z</code>指的是时区。要转化的字符串时间格式必须和这个格式匹配，上面给定的字符串时间是：<code>@&quot;2016-12-07 14:06:24 +0800&quot;</code>，是一个东八区时间，转化为NSDate后是零区时间<code>2016-12-07 06:06:24 +0000</code>，字面显示上少了8小时，其实时间一样。</p>
<p>其实如果上面给定的字符串时间为<code>@&quot;2016-12-07 14:06:24 +0000&quot;</code>，转化出来的NSDate时间会完全一样，因为字符串时间为零时区时间，不存在时区误差。大家可以试一下。</p>
<p>当不指定字符串时间的时区时，即没有后面的<code>+0800</code>，同时要把<code>NSDateFormatter</code>时间格式里的<code>Z</code>去掉，保证格式匹配。系统会认为字符串时间是系统所在时区的时间，转化为NSDate时间是零时区时间。</p>
<p>同样，也可以使用<code>formatter.timeZone = [NSTimeZone timeZoneWithName:@&quot;GMT&quot;];</code>这种方式指定字符串时间的时区，和用<code>Z</code>对应<code>+0000</code>是一样的。</p>
<h3 id="NSDate转当前时区的NSDate时间"><a href="#NSDate转当前时区的NSDate时间" class="headerlink" title="NSDate转当前时区的NSDate时间"></a>NSDate转当前时区的NSDate时间</h3><p>因为<code>[NSDate date]</code>得出的时间是零时区时间，当我们要获取当前所在时区的NSDate时间时，通常会用以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSTimeZone *zone = [NSTimeZone systemTimeZone];</div><div class="line">NSInteger interval = [zone secondsFromGMTForDate:date];</div><div class="line">NSDate *localDate = [date  dateByAddingTimeInterval:interval];</div><div class="line">NSLog(@&quot;localDate = %@&quot;,localDate);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-12-07 14:49:03.777 timeTest[34519:3183548] localDate = 2016-12-07 14:49:03 +0000</div></pre></td></tr></table></figure>
<p>上面代码中<code>zone</code>是当前时区，<code>interval</code>是当前时区和零时区时间的差值，最后结果<code>localDate</code>是零时区时间<code>date</code>加上这个差值<code>interval</code>，得到当前时区的NSDate时间。更有甚者，在开发中直接加<code>8*60*60</code>或<code>28800</code>这样的值，因为相差8小时嘛。这样在东八区没问题，在其他时区时间就错了。</p>
<p>其实这种做法是不科学的，因为得到的最终时间还是零时区时间，时间后面明显是<code>+0000</code>，在使用中一般不显示时区，所以认为当做当前时区的时间使用也未尝不可。此为大坑！</p>
<p>坑1：这时如果转为字符串时间，又会增加8小时。因为做时间转换的时候，系统会认为这个NSDate是零时区，得到的字符串时间是东八区的。</p>
<p>解决办法是：将错就错，字符串时间也设置为零时区的字符串时间。从深坑跌入更深的坑！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSTimeZone *zone = [NSTimeZone systemTimeZone];</div><div class="line">NSInteger interval = [zone secondsFromGMTForDate:date];</div><div class="line">NSDate *localDate = [date dateByAddingTimeInterval:interval];</div><div class="line"></div><div class="line">NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</div><div class="line">[formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</div><div class="line">formatter.timeZone = [NSTimeZone timeZoneWithName:@&quot;UTC&quot;];</div><div class="line">NSString *dateStr = [formatter stringFromDate:localDate];</div><div class="line">NSLog(@&quot;字符串时间 = %@&quot;, dateStr);</div></pre></td></tr></table></figure>
<p>这里的<code>@&quot;UTC&quot;</code>是指世界标准时间，也是现在用的时间标准，东八区比这个时间也是快8小时，这里填<code>@&quot;GMT&quot;</code>也是可以的。</p>
<p>坑2：在与后台交互时，有时需要<code>+0000</code>时区，这时只能手动拼接字符串更改这个时区字段，改为正确的时区。</p>
<p><strong>所以，在开发中尽量不要这么做，当时间要求显示、存储或与后台交互的时候，使用字符串时间！不要使用转化的NSDate。</strong></p>
<h2 id="时间换算，时间戳的概念"><a href="#时间换算，时间戳的概念" class="headerlink" title="时间换算，时间戳的概念"></a>时间换算，时间戳的概念</h2><h3 id="当前时间转时间戳"><a href="#当前时间转时间戳" class="headerlink" title="当前时间转时间戳"></a>当前时间转时间戳</h3><p>时间戳是指1970年1月1日0时0分0秒到当前时间的秒数。注意：这里的当前时间是指零时区的NSDate时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSTimeInterval timeIn = [date timeIntervalSince1970];</div><div class="line">NSLog(@&quot;时间戳 = %.0f&quot;, timeIn);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-12-07 15:41:04.000 timeTest[34994:3232390] 时间戳 = 1481096464</div></pre></td></tr></table></figure>
<h3 id="时间戳转当前时间"><a href="#时间戳转当前时间" class="headerlink" title="时间戳转当前时间"></a>时间戳转当前时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSTimeInterval timeIn = [date timeIntervalSince1970];</div><div class="line">NSDate *newDate = [NSDate dateWithTimeIntervalSince1970:timeIn];</div><div class="line">NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];</div><div class="line">[dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss Z&quot;];</div><div class="line">NSString *newTime = [dateFormatter stringFromDate:newDate];</div><div class="line">NSLog(@&quot;初始化时间 = %@，时间戳=%.0f，时间戳转为NSDate时间 = %@，转为字符串时间 = %@&quot;, date, timeIn, newDate, newTime);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-12-07 16:11:56.146 timeTest[35186:3253589] 初始化时间 = 2016-12-07 08:11:56 +0000，时间戳=1481098316，时间戳转为NSDate时间 = 2016-12-07 08:11:56 +0000，转为字符串时间 = 2016-12-07 16:11:56 +0800</div></pre></td></tr></table></figure>
<p>注意时间戳使用的NSDate时间是当前零时区的时间！当前零时区时间！当前零时区时间！重要的事情说三遍！不要进行NSDate转当前时区的NSDate时间，再转时间戳。下面是验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSLog(@&quot;系统零时区NSDate时间 = %@&quot;, date);    </div><div class="line">NSTimeInterval timeIn = [date timeIntervalSince1970];</div><div class="line">NSLog(@&quot;系统零时区NSDate时间转化为时间戳 = %.0f&quot;, timeIn);</div><div class="line">NSTimeZone *zone = [NSTimeZone systemTimeZone];</div><div class="line">NSInteger interval = [zone secondsFromGMTForDate:date];</div><div class="line">NSDate *localDate = [date  dateByAddingTimeInterval:interval];</div><div class="line">NSLog(@&quot;转化为本地NSDate时间 = %@&quot;, localDate);</div><div class="line">NSTimeInterval timeIn2 = [localDate timeIntervalSince1970];</div><div class="line">NSLog(@&quot;本地NSDate时间转化为时间戳 = %.0f&quot;, timeIn2);</div><div class="line">NSDate *detaildate = [NSDate dateWithTimeIntervalSince1970:timeIn];</div><div class="line">NSDate *detaildate2 = [NSDate dateWithTimeIntervalSince1970:timeIn2];</div><div class="line">NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];</div><div class="line">[dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss Z&quot;];</div><div class="line">NSString *newTime = [dateFormatter stringFromDate:detaildate];</div><div class="line">NSString *newTime2 = [dateFormatter stringFromDate:detaildate2];</div><div class="line">NSLog(@&quot;最终转为字符串时间1 = %@， 时间2 = %@&quot;, newTime, newTime2);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2016-12-07 16:13:57.834 timeTest[35211:3255842] 系统零时区NSDate时间 = 2016-12-07 08:13:57 +0000</div><div class="line">2016-12-07 16:13:57.834 timeTest[35211:3255842] 系统零时区NSDate时间转化为时间戳 = 1481098438</div><div class="line">2016-12-07 16:13:57.835 timeTest[35211:3255842] 转化为本地NSDate时间 = 2016-12-07 16:13:57 +0000</div><div class="line">2016-12-07 16:13:57.835 timeTest[35211:3255842] 本地NSDate时间转化为时间戳 = 1481127238</div><div class="line">2016-12-07 16:13:57.836 timeTest[35211:3255842] 最终转为字符串时间1 = 2016-12-07 16:13:57 +0800， 时间2 = 2016-12-08 00:13:57 +0800</div></pre></td></tr></table></figure>
<p>问题解释详见上文的<code>NSDate转当前时区的NSDate时间</code>。</p>
<h2 id="时间操作与比较"><a href="#时间操作与比较" class="headerlink" title="时间操作与比较"></a>时间操作与比较</h2><h3 id="时间初始化和比较方法"><a href="#时间初始化和比较方法" class="headerlink" title="时间初始化和比较方法"></a>时间初始化和比较方法</h3><p>几个时间初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//初始化当前时间，返回零时区时间</div><div class="line">NSDate *date = [NSDate date];</div><div class="line">//以当前时间为准，正数超前指定秒数，负数延后指定秒数</div><div class="line">NSDate *laterDate = [NSDate dateWithTimeIntervalSinceNow:60];</div><div class="line">//以2001-01-01 00:00:00 +0000为基准，正数超前指定秒数，负数延后指定秒数</div><div class="line">NSDate *newDate = [NSDate dateWithTimeIntervalSinceReferenceDate:60];</div><div class="line">//以1970-01-01 00:00:00 +0000为基准，正数超前指定秒数，负数延后指定秒数</div><div class="line">NSDate *newDate1 = [NSDate dateWithTimeIntervalSince1970:60];</div><div class="line">//实例方法，以指定时间为基准，正数超前指定秒数，负数延后指定秒数</div><div class="line">NSDate *newDate2 = [date dateByAddingTimeInterval:60];</div><div class="line">//很久以后的某一天</div><div class="line">NSDate *newDate3 = [NSDate distantFuture];</div><div class="line">//很久以前的某一天</div><div class="line">NSDate *newDate4 = [NSDate distantPast];</div></pre></td></tr></table></figure>
<p>几个时间比较方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//比较两个时间是否相等</div><div class="line">- (BOOL)isEqualToDate:(NSDate *)otherDate;</div><div class="line">//两个时间比较，返回较早时间</div><div class="line">- (NSDate *)earlierDate:(NSDate *)anotherDate;</div><div class="line">//两个时间比较，返回较晚时间</div><div class="line">- (NSDate *)laterDate:(NSDate *)anotherDate;</div><div class="line">//两个时间比较，返回枚举类型</div><div class="line">- (NSComparisonResult)compare:(NSDate *)other;</div></pre></td></tr></table></figure>
<p>几个计算时间间隔的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//返回实例时间与refDate时间间隔秒数</div><div class="line">- (NSTimeInterval)timeIntervalSinceDate:(NSDate *)refDate;</div><div class="line">//返回实例时间与当前时间间隔秒数</div><div class="line">- (NSTimeInterval)timeIntervalSinceNow;</div><div class="line">//返回实例时间的时间戳</div><div class="line">- (NSTimeInterval)timeIntervalSince1970;</div><div class="line">//返回实例时间和2001-01-01 00:00:00 +0000的间隔秒数</div><div class="line">- (NSTimeInterval)timeIntervalSinceReferenceDate;</div><div class="line">//返回当前时间和2001-01-01 00:00:00 +0000的间隔秒数</div><div class="line">+ (NSTimeInterval)timeIntervalSinceReferenceDate;</div></pre></td></tr></table></figure>
<h3 id="获取年月日时分秒周时区"><a href="#获取年月日时分秒周时区" class="headerlink" title="获取年月日时分秒周时区"></a>获取年月日时分秒周时区</h3><p>oc里的时间坑太多，根本没办法像其他语言那样直接time.year就能获取年份。要想获取NSDate的年月日需要使用日历对象<code>NSCalendar</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [NSDate date];</div><div class="line">NSCalendar *cal = [NSCalendar currentCalendar];</div><div class="line">NSDateComponents *dateComps = [cal components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay|NSCalendarUnitHour|NSCalendarUnitMinute|NSCalendarUnitSecond|NSCalendarUnitWeekday|NSCalendarUnitWeekOfMonth|NSCalendarUnitWeekOfYear|NSCalendarUnitTimeZone fromDate:date];</div><div class="line">NSLog(@&quot;时间 = %@&quot;, date);</div><div class="line">NSLog(@&quot;年=%ld,月=%ld,日=%ld,时=%ld,分=%ld,秒=%ld,周=%ld,本月第%ld周,本年第%ld周,时区=%@&quot;, dateComps.year, dateComps.month, dateComps.day, dateComps.hour, dateComps.minute, dateComps.second, dateComps.weekday, dateComps.weekOfMonth, dateComps.weekOfYear, dateComps.timeZone.name);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-12-07 17:20:41.639 timeTest[35734:3311752] 时间 = 2016-12-07 09:20:41 +0000</div><div class="line">2016-12-07 17:20:41.640 timeTest[35734:3311752] 年=2016,月=12,日=7,时=17,分=20,秒=41,周=4,本月第2周,本年第50周,时区=Asia/Shanghai</div></pre></td></tr></table></figure>
<p><code>NSDateComponents</code>创建方法中添加的枚举<code>NSCalendarUnit</code>，是后面要获取的年月日时分秒必须对应添加的。比如要获取年<code>dateComps.year</code>，就需要添加枚举<code>NSCalendarUnitYear</code>。</p>
<p>可以看到，<code>[NSDate date]</code>时间可以使用<code>NSCalendar</code>直接获取当前时区的时分秒，打印的<code>时</code>和<code>时区</code>即可看出。这是<code>[NSCalendar currentCalendar]</code>日历对象初始化的原因，也可以用<code>[[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian]</code>指定Identifier的方式初始化阳历日历。可以试试指定Identifier为<code>NSCalendarIdentifierChinese</code>，打印的是中国农历。</p>
<p><code>dateComps.weekOfMonth</code>是今天属于本月的第几周。</p>
<p><code>dateComps.weekOfYear</code>是今天属于本年的第几周。</p>
<p><code>dateComps.weekday</code>是星期，这个和日常使用有些不同。上述程序打印的是<code>周=4</code>，但2016-12-07是<code>周三</code>。这里<code>weekday</code>的对应关系是：周日-1，周一-2，周二-3，周三-4，周四-5，周五-6，周六-7。毕竟国外惯例周日是每周的第一天。</p>
<h2 id="农历"><a href="#农历" class="headerlink" title="农历"></a>农历</h2><p>获取农历的工具方法，可根据需求添加农历节日和二十四节气</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">+ (NSString *)LunarForSolarYear:(int)wCurYear Month:(int)wCurMonth Day:(int)wCurDay</div><div class="line">&#123;</div><div class="line">    //农历日期名</div><div class="line">    NSArray *cDayName =  [NSArray arrayWithObjects:@&quot;*&quot;,@&quot;初一&quot;,@&quot;初二&quot;,@&quot;初三&quot;,@&quot;初四&quot;,@&quot;初五&quot;,@&quot;初六&quot;,@&quot;初七&quot;,@&quot;初八&quot;,@&quot;初九&quot;,@&quot;初十&quot;,@&quot;十一&quot;,@&quot;十二&quot;,@&quot;十三&quot;,@&quot;十四&quot;,@&quot;十五&quot;,@&quot;十六&quot;,@&quot;十七&quot;,@&quot;十八&quot;,@&quot;十九&quot;,@&quot;二十&quot;,@&quot;廿一&quot;,@&quot;廿二&quot;,@&quot;廿三&quot;,@&quot;廿四&quot;,@&quot;廿五&quot;,@&quot;廿六&quot;,@&quot;廿七&quot;,@&quot;廿八&quot;,@&quot;廿九&quot;,@&quot;三十&quot;,nil];</div><div class="line">    //农历月份名</div><div class="line">    NSArray *cMonName =  [NSArray arrayWithObjects:@&quot;*&quot;,@&quot;正月&quot;,@&quot;二月&quot;,@&quot;三月&quot;,@&quot;四月&quot;,@&quot;五月&quot;,@&quot;六月&quot;,@&quot;七月&quot;,@&quot;八月&quot;,@&quot;九月&quot;,@&quot;十月&quot;,@&quot;冬月&quot;,@&quot;腊月&quot;,nil];</div><div class="line">    //公历每月前面的天数</div><div class="line">    const int wMonthAdd[12] = &#123;0,31,59,90,120,151,181,212,243,273,304,334&#125;;</div><div class="line">    //农历数据</div><div class="line">    const int wNongliData[100] = &#123;2635,333387,1701,1748,267701,694,2391,133423,1175,396438</div><div class="line">        ,3402,3749,331177,1453,694,201326,2350,465197,3221,3402</div><div class="line">        ,400202,2901,1386,267611,605,2349,137515,2709,464533,1738</div><div class="line">        ,2901,330421,1242,2651,199255,1323,529706,3733,1706,398762</div><div class="line">        ,2741,1206,267438,2647,1318,204070,3477,461653,1386,2413</div><div class="line">        ,330077,1197,2637,268877,3365,531109,2900,2922,398042,2395</div><div class="line">        ,1179,267415,2635,661067,1701,1748,398772,2742,2391,330031</div><div class="line">        ,1175,1611,200010,3749,527717,1452,2742,332397,2350,3222</div><div class="line">        ,268949,3402,3493,133973,1386,464219,605,2349,334123,2709</div><div class="line">        ,2890,267946,2773,592565,1210,2651,395863,1323,2707,265877&#125;;</div><div class="line">    static int nTheDate,nIsEnd,m,k,n,i,nBit;</div><div class="line">    //计算到初始时间1921年2月8日的天数：1921-2-8(正月初一)</div><div class="line">    nTheDate = (wCurYear - 1921) * 365 + (wCurYear - 1921) / 4 + wCurDay + wMonthAdd[wCurMonth - 1] - 38;</div><div class="line">    if((!(wCurYear % 4)) &amp;&amp; (wCurMonth &gt; 2))</div><div class="line">        nTheDate = nTheDate + 1;</div><div class="line">    //计算农历天干、地支、月、日</div><div class="line">    nIsEnd = 0;</div><div class="line">    m = 0;</div><div class="line">    while(nIsEnd != 1) &#123;</div><div class="line">        if(wNongliData[m] &lt; 4095)</div><div class="line">            k = 11;</div><div class="line">        else</div><div class="line">            k = 12;</div><div class="line">        n = k;</div><div class="line">        while(n&gt;=0) &#123;</div><div class="line">            //获取wNongliData(m)的第n个二进制位的值</div><div class="line">            nBit = wNongliData[m];</div><div class="line">            for(i=1;i&lt;n+1;i++)</div><div class="line">                nBit = nBit/2;</div><div class="line">            nBit = nBit % 2;</div><div class="line">            </div><div class="line">            if (nTheDate &lt;= (29 + nBit)) &#123;</div><div class="line">                nIsEnd = 1;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            nTheDate = nTheDate - 29 - nBit;</div><div class="line">            n = n - 1;</div><div class="line">        &#125;</div><div class="line">        if(nIsEnd)</div><div class="line">            break;</div><div class="line">        m = m + 1;</div><div class="line">    &#125;</div><div class="line">    wCurYear = 1921 + m;</div><div class="line">    wCurMonth = k - n + 1;</div><div class="line">    wCurDay = nTheDate;</div><div class="line">    if (k == 12) &#123;</div><div class="line">        if (wCurMonth == wNongliData[m] / 65536 + 1)</div><div class="line">            wCurMonth = 1 - wCurMonth;</div><div class="line">        else if (wCurMonth &gt; wNongliData[m] / 65536 + 1)</div><div class="line">            wCurMonth = wCurMonth - 1;</div><div class="line">    &#125;</div><div class="line">    //生成农历月</div><div class="line">    NSString *szNongliMonth;</div><div class="line">    if (wCurMonth &lt; 1) &#123;</div><div class="line">        szNongliMonth = [NSString stringWithFormat:@&quot;闰%@&quot;,(NSString *)[cMonName objectAtIndex:-1 * wCurMonth]];</div><div class="line">    &#125;else&#123;</div><div class="line">        szNongliMonth = (NSString *)[cMonName objectAtIndex:wCurMonth];</div><div class="line">    &#125;</div><div class="line">    //生成农历日</div><div class="line">    NSString *szNongliDay = [cDayName objectAtIndex:wCurDay];</div><div class="line">    //合并</div><div class="line">    NSString *lunarDate = [NSString stringWithFormat:@&quot;%@-%@&quot;,szNongliMonth,szNongliDay];</div><div class="line">    return lunarDate;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发中，经常会遇到各种各样的时间问题，8小时时差，时间戳，求时间间隔，农历等等。解决办法网上比比皆是，但大多零零散散，很多资料并没有说明其中问题。这里集中总结一下，以便于以后查阅和供大家参考。有我自己的理解，错漏之处请大家吐槽。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://markmiao.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS10" scheme="http://markmiao.com/tags/iOS10/"/>
    
  </entry>
  
  <entry>
    <title>我想做个APP，多长时间，多少钱</title>
    <link href="http://markmiao.com/2016/11/30/%E6%88%91%E6%83%B3%E5%81%9A%E4%B8%AAAPP%EF%BC%8C%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4%EF%BC%8C%E5%A4%9A%E5%B0%91%E9%92%B1/"/>
    <id>http://markmiao.com/2016/11/30/我想做个APP，多长时间，多少钱/</id>
    <published>2016-11-30T08:38:32.000Z</published>
    <updated>2016-11-30T09:13:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在一个阳光明媚的下午，我正瘫坐在椅子上改bug。忽然有人给我发微信：“我想做个app，多长时间，多少钱？”</p>
<p>从我从业iOS开发到现在，这个问题被问过无数次，比那句：“你是程序员，那你会修电脑吗？”还要令人烦。毕竟那只是句玩笑话，而这句在其他人（更多时候是你的boss，经理这些非程序员出身的IT内行人）看来是你的专业，是你必须要知道的，你能回答不知道吗？显得你太不专业了。但这句话最专业、最负责任的回答就是：“我不知道！”</p>
<a id="more"></a>
<p>问我问题的是朋友的朋友，一个在传统行业浸淫多年的人，立志要突破传统行业的束缚，做互联网浪潮中的弄潮儿。当时听他说这句话的时候我有点懵逼：互联网浪潮中的弄潮儿？指示十多年前马云、马化腾那一批吗？现在互联网都蔓延成海了，哪还有潮让你浪，能做一条杂鱼苟延残喘的活下去就不错了。</p>
<p>我真想回答“我不知道”，毕竟还有好多bug等着我改呢，没必要在这浪费时间。但又想到毕竟有过一面之缘，直接回答不知道，是不是显得有点不给面子？在这个问题上，很多时候就是这么栽进坑里的。</p>
<p>“什么类型的app？”这句话发出去，毫无疑问的掉坑里了。他给我发了个app截图，说：“跟这个差不多，不用那么复杂，简单点就行。”</p>
<p>我一看，好嘛，淘宝？！你还真是打算做弄潮儿啊！我说：“淘宝啊？得十多年吧。”加了一个呵呵的表情，一方面想表达我认为你是在开玩笑，我也是开玩笑的回复，另一方面是我想呵呵你一脸。其实我也不算敷衍，淘宝03年成立，做到现在也十多年了。</p>
<p>他明显没有get到我的意思，反而埋怨我没get到他的点。说：“我的意思是淘宝这个类型的app，肯定不用跟淘宝似的那么复杂。简单点，有个列表，可以卖东西就行，几天能弄出来？重要的是要快！”看这意思是：我已想到一个天才创意，就差一个能把创意转化成app的高效程序员了，一定要高效，几天就能做出来，上架使用，推广全国。</p>
<p>这时我能想到的最靠谱的建议是：花钱收购现有的，你觉得最符合你创意理念的那款app。当然这个看似调侃实则靠谱的回答是没办法说出口的。我语重心长的回答道：“电商类app，只保留必要功能：商品展示、登录注册、购物车、下单支付、订单记录，精简到最简单，只是iOS客户端的实现代码也不可能几天内写完。“</p>
<p>本以为我这么说对方会重新估量开发一款app的复杂度，没想到对方急了：”不用考虑那么复杂，先做出一个最简单的，其他的慢慢迭代。就告诉我最快多长时间能搞定，大概花多少钱就行。“</p>
<p>这就是耍流氓了，好话说了一火车，油盐不进。我要还妄想改变他的想法，我就是2B了。索性开门见山的说：三个月。在团队完备，不改需求的前提下。找个人兼职外包，按平均日薪结算。</p>
<p>对方没再回话，不知道是听从我的建议去紧张筹备项目小组了，还是觉得我是个菜狗，这么点小事竟然张口就说三个月，三个月吃屎都赶不上热乎的了。我估计是后者的概率大。喝了口水抖擞抖擞精神，继续改我的bug。遥想当年我也曾豪言壮语，但到最后都跌的遍体鳞伤……</p>
<p>此类情况遇到N多次了，像这种无关自己工作的外部人士咨询行情的还好，毕竟你只需要给出自己认为合理的建议即可。人家也不一定采纳，说不定只是做个对比筛选，事后成功与否都事不关己。但多数情况下是boss或部门经理会问你这个问题，那回答的时候就不是这样轻轻松松侃侃而谈了。毕竟，说出去的话是要兑现的，挖了坑自己填不上，是要栽进去的。</p>
<p>我认为：任何没有完整功能逻辑原型图就问开发时间的都是耍流氓，有原型图问开发时间事后改需求的都是耍无赖。这两者的共同点就是玩死人不偿命。</p>
<p>为什么开发不能像其他行业那样精准预估工期呢？因为开发工作的变数太大。以最常见的app登录功能举例，常见的登录方式有：账号+密码、手机号+验证码和第三方平台登录。手机+验证码需要找短信服务商，要考虑验证码的送达速度和费用问题。第三方登录需要注册账号，创建应用，以及认证开发者资质。腾讯开放平台创建应用需要填写appid，要想有appid需要在iTunes Connect里创建应用，在此之前必须有苹果的开发者账号，申请开发者账号是要公司级还是个人级的？公司级的需要提供邓白氏码。所有这一切都需要时间审核，部分资质认证、账号注册需要花钱。</p>
<p>以上是平台账号问题，下面说开发问题。有登录就得有注册，要保证用户的唯一性，需要有一个唯一标识。以手机号作为唯一标识的话，采用第三方登录的没有手机号，分配独立用户id作为唯一标示的话，先用手机号登录，再用微信登录，就会产生两个用户，如何实现绑定手机号合并用户呢？还有是否保留账号+密码注册呢？如果保留的话还需要有找回密码功能，找回密码是要邮箱验证还是手机验证码验证呢……</p>
<p>一款app并不是简简单单找个码农，噼里啪啦敲一顿键盘就能完成的。至少需要以下几种角色：产品经理，能拍板项目功能逻辑出原型图，把控整个项目进度和团队配合；设计师，根据原型图做高保真交互设计；服务端工程师，做后台数据处理，提供客户端所需接口；客户端工程师，实现app所有的功能逻辑，性能优化，上架应用市场；测试工程师，测试app功能逻辑的正确性和性能。这些只是角色标配，并非每个角色都对应一个人。比如客户端可能需要Android、iOS、WP多个开发工程师，开发往往会兼任测试工作，后台有时会代理产品经理工作。又或者你是精通设计的全栈工程师，对产品又有资深造诣，那便可以身兼所有角色。所以这里又牵扯到团队协作，再默契的团队都会存在沟通成本，只是成本高低的问题。全栈工程师单人开发，没有沟通成本的单兵作战，时间成本会大大增加。所以说：程序开发是一个充满无数不可预知变化的职业，不可能精准预估工期。</p>
<p>道理我们都懂，那开发一个app到底要多长时间呢？预估工期虽然令人讨厌，但确实是一个客户端程序员该具备的能力。当看到原型图预估时间的时候，往往只估算了敲app代码的时间，而且还是个理想化时间。认为自己胸怀万码，光标到处bug灰飞烟灭，功能实现如有神助，代码编译一次通过，简直是码生赢家啊。现实会毫不留情的给你狠狠地一巴掌。比如一个原型图上有10个界面，都是最简单的push跳转，用Storyboard一个小时就能画完，剩下七个小时写数据展示，so easy啊，然后洋洋得意的告诉boss一天就能搞定。然后Storyboard代码版本冲突了，解决冲突用了仨小时，接口响应方式没指明，参数格式写错了，调了仨小时。六个小时过去后，慌了……</p>
<p>之所以不可预估，是因为存在太多的不确定因素。一些不确定因素会因为经验积累而变为确定因素，另一些不确定因素却会一直存在。程序员拿到需求的时候，需要有一个心理预估，每个功能模块多久能完成，哪些逻辑是我以前写过的，哪些框架是需要谷歌才会用的，哪些页面目前还不能确定实现方法。对每个模块分配一个时间块，不求预估准确，但求时间精确，最后把这些时间块加起来，然后乘一个π值，得到的便是一个相对合理的开发工期预估。随着经验积累，慢慢地不需要乘π值了，乘2.5，乘2，乘1.5……能乘以1那就是大神了，乘以0.x就超神了。其实有经验的产品经理也会以这种方式来计算程序员的工期预估，毕竟有经验的产品经理都是被程序员不擅长工期预估而坑过无数次的。唉，相爱相杀，产品狗何苦为难程序猿，程序猿何苦坑害产品狗。</p>
<p>还有开发一个app要多少钱？这个问题其实不应该问程序员，毕竟程序员大多是写死程序、拿死工资的码农。即便是外包公司的程序员也不会接触到公司业务，除非是谈过外包项目，很有经验的产品负责人才能明白这里的行情。我没在外包公司待过，但私下里接过外包项目，大概了解过外包行情。</p>
<p>找个人接外包一般会有两种工资算法，一种是按日薪支付，一种是按预算均分。按日薪支付是指预估出该项目大概需要多长时间，并与甲方谈妥时间点，找产品做原型，找设计出图，找程序员开发，并按日支付项目参与者在职岗位的平均日薪，当然参与者需要在规定时间内完成工作。按预算均分是指该项目甲方一共能给多少预算，开发该项目的所有人员均分这笔预算。这种方式适合熟人团队开发小项目，例如之前接的一个小项目三万块，后台、iOS、Android一人一万，原型图和设计是甲方提供的，开发时间总计两周。其实有时间的话，还是蛮乐意接这种小外包的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个阳光明媚的下午，我正瘫坐在椅子上改bug。忽然有人给我发微信：“我想做个app，多长时间，多少钱？”&lt;/p&gt;
&lt;p&gt;从我从业iOS开发到现在，这个问题被问过无数次，比那句：“你是程序员，那你会修电脑吗？”还要令人烦。毕竟那只是句玩笑话，而这句在其他人（更多时候是你的boss，经理这些非程序员出身的IT内行人）看来是你的专业，是你必须要知道的，你能回答不知道吗？显得你太不专业了。但这句话最专业、最负责任的回答就是：“我不知道！”&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://markmiao.com/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="APP开发" scheme="http://markmiao.com/tags/APP%E5%BC%80%E5%8F%91/"/>
    
      <category term="外包" scheme="http://markmiao.com/tags/%E5%A4%96%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>微信报名系统H5页面开发</title>
    <link href="http://markmiao.com/2016/11/28/%E5%BE%AE%E4%BF%A1%E6%8A%A5%E5%90%8D%E7%B3%BB%E7%BB%9FH5%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    <id>http://markmiao.com/2016/11/28/微信报名系统H5页面开发/</id>
    <published>2016-11-28T01:58:29.000Z</published>
    <updated>2016-11-28T02:16:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作需要，用HTML5写一个微信的内置网页，是一个参会报名流程。上次写html还是上学时交作业，现在着实有些手忙脚乱了，现学现用、磕磕绊绊，项目总算告一段落，到了要总结一下的时候了。简单记录了做这个项目时所遇到的问题，有些问题在网上能搜到解决办法，有些问题是为了实现效果耍的小聪明。</p>
<a id="more"></a>
<h2 id="工具以及框架"><a href="#工具以及框架" class="headerlink" title="工具以及框架"></a>工具以及框架</h2><p>由于我只负责h5界面(<del>让我负责java后台也做不来。我对好多语言都有兴趣，对java就是提不起兴趣，或许是因为大学学java学烦了。</del>)，所以就用了<a href="http://www.dcloud.io/" target="_blank" rel="external">HBuilder</a>只码web界面，这个开发工具开发h5网页来说很便利，比如它有代码提醒、边改边看模式、手机端网页运行、运行到iPhone上等等功能，但也有不好用的地方，比如快捷键、搜索方式等。</p>
<p>还有开发微信内置web网页必不可少的工具：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1455784140&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信web开发者工具</a>。很不幸的说开发到中期才发现这个工具，明明就在微信JS-SDK下面就是视而不见。目前这个工具已经升级为开发小程序专用编译器，不能调试微信内置web页面。</p>
<p>当然还有谷歌浏览器Google Chrome，浏览器来说，我之前是火狐党，开发这个项目才用了谷歌浏览器。谷歌的开发者工具挺好用的，有错误调试，样式修改，多种手机屏幕调试。还有<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信JS-SDK说明文档</a>火狐浏览器上目录点击无效，谷歌浏览器就可以调转到相应内容。还有一点，项目中用到了一个别人写好的<code>picker</code>控件，在火狐浏览器上打开一团糟，谷歌浏览器完美运行，幸运的是微信内置浏览器也运行无误。重点说明：我不是火狐黑，项目之外依旧继续用火狐。这时可以感觉到web开发做浏览器兼容还是有很多工作的。</p>
<p>开发微信用的东西肯定要用微信提供的开发样式库<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1455784134&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">WeUI</a>，毕竟风格相近直接拿来用就行，即便是不一样，改起来也方便很多。包括微信的JS-SDK的<a href="http://203.195.235.76/jssdk/" target="_blank" rel="external">demo示例代码</a></p>
<p>还有号称最接近原生APP体验的高性能前端框架<a href="http://dev.dcloud.net.cn/mui/" target="_blank" rel="external">MUI</a>，项目中的picker就是用的这里的。</p>
<h2 id="微信分享调用和地图功能"><a href="#微信分享调用和地图功能" class="headerlink" title="微信分享调用和地图功能"></a>微信分享调用和地图功能</h2><h3 id="分享功能重写，调用地图"><a href="#分享功能重写，调用地图" class="headerlink" title="分享功能重写，调用地图"></a>分享功能重写，调用地图</h3><p>微信分享和地图调用都使用了微信提供的JS-SDK，公众平台有详细的说明文档。这里只记录一些调用步骤和遇到的问题。</p>
<p>微信分享不用单独去写，微信内置网页右上角会自动加入分享功能，默认分享出去的网页样式标题为页面标题，图片为网页中第一张图片，简介也是第一段文字。如果想自定义这些样式内容，就需要重写分享方法。</p>
<p>引入js文件，建议调用<code>https</code>的js地址，如果页面启用了<code>https</code>，使用<code>http</code>的js地址在iOS9中将无法调用sdk</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"https://res.wx.qq.com/open/js/jweixin-1.0.0.js"</span> type=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>调用config方法，配置权限验证</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">wx.config(&#123;</div><div class="line">	<span class="attr">debug</span>: <span class="literal">true</span>,<span class="comment">//开启调试模式，一直有alert出现。发布页面时改为false</span></div><div class="line">	appId: <span class="string">'wx1234567890032222'</span>,<span class="comment">//微信公众号唯一标示。</span></div><div class="line">	timestamp: timestamp,<span class="comment">//时间戳</span></div><div class="line">	nonceStr: nonceStr,<span class="comment">//随机串</span></div><div class="line">	signature: signature,<span class="comment">//签名</span></div><div class="line">	jsApiList: [</div><div class="line">		<span class="string">'checkJsApi'</span>,<span class="comment">//验证客户端版本是否支持sdk</span></div><div class="line">		<span class="string">'onMenuShareTimeline'</span>,<span class="comment">//分享朋友圈</span></div><div class="line">		<span class="string">'onMenuShareAppMessage'</span>,<span class="comment">//发送给朋友</span></div><div class="line">		<span class="string">'openLocation'</span>,<span class="comment">//地图</span></div><div class="line">		<span class="string">'showOptionMenu'</span><span class="comment">//开启右上角按钮内页面分享按钮</span></div><div class="line">	]</div><div class="line">&#125;);</div><div class="line"></div><div class="line">wx.ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="comment">// 1 判断当前版本是否支持指定 JS 接口，支持批量判断</span></div><div class="line">	wx.checkJsApi(&#123;</div><div class="line">		<span class="attr">jsApiList</span>: [<span class="string">'getNetworkType'</span>, <span class="string">'previewImage'</span>],</div><div class="line">		<span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	<span class="comment">// 地理位置</span></div><div class="line">	<span class="built_in">document</span>.querySelector(<span class="string">'#openLocation'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		wx.openLocation(&#123;</div><div class="line">			<span class="attr">latitude</span>: <span class="number">22.537180</span>,<span class="comment">//纬度</span></div><div class="line">			longitude: <span class="number">113.976250</span>,<span class="comment">//经度</span></div><div class="line">			name: <span class="string">'xxxx酒店'</span>,<span class="comment">//位置名</span></div><div class="line">			address: <span class="string">'地址说明'</span>,</div><div class="line">			<span class="attr">scale</span>: <span class="number">14</span>,<span class="comment">//地图缩放级别范围从1~28</span></div><div class="line">			infoUrl: <span class="string">''</span><span class="comment">//在查看位置界面底部显示的超链接,可点击跳转</span></div><div class="line">		&#125;);</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="comment">// 2.1 监听“分享给朋友”，按钮点击、自定义分享内容及分享结果接口</span></div><div class="line">	wx.onMenuShareAppMessage(&#123;</div><div class="line">		<span class="attr">title</span>: <span class="string">'分享标题'</span>,</div><div class="line">		<span class="attr">desc</span>: <span class="string">'分享简介'</span>,</div><div class="line">		<span class="attr">link</span>: <span class="string">'https://www.baidu.com'</span>,<span class="comment">//分享地址</span></div><div class="line">		imgUrl: <span class="string">'http://oalg33nuc.bkt.clouddn.com/image/wechatshareimg.jpg'</span>,<span class="comment">//分享图片的地址</span></div><div class="line">	&#125;);</div><div class="line"></div><div class="line">	<span class="comment">// 2.2 监听“分享到朋友圈”按钮点击、自定义分享内容及分享结果接口</span></div><div class="line">	wx.onMenuShareTimeline(&#123;</div><div class="line">		<span class="attr">title</span>: <span class="string">'分享标题'</span>,</div><div class="line">		<span class="attr">desc</span>: <span class="string">'分享简介'</span>,</div><div class="line">		<span class="attr">link</span>: <span class="string">'https://www.baidu.com'</span>,<span class="comment">//分享地址</span></div><div class="line">		imgUrl: <span class="string">'http://oalg33nuc.bkt.clouddn.com/image/wechatshareimg.jpg'</span>,<span class="comment">//分享图片的地址</span></div><div class="line">	&#125;);</div><div class="line">	</div><div class="line">	wx.showOptionMenu();<span class="comment">//显示微信右上角点开的分享按钮</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这一块前端网页还是比较简单的，因为所需要的<code>签名signature</code>等参数都是后台算好给的。生成签名需要<code>jsapi_ticket</code>，要拿到<code>jsapi_ticket</code>需要<code>access_token</code>，获取<code>access_token</code>的步骤和在iOS原生应用中做微信分享是一样的，拿<code>appid</code>和<code>secret</code>等参数调用接口获取<code>access_token</code>。</p>
<h3 id="分享按钮显示-隐藏"><a href="#分享按钮显示-隐藏" class="headerlink" title="分享按钮显示/隐藏"></a>分享按钮显示/隐藏</h3><p>分享按钮的显示问题，有时候要求只要指定页面分享出去，其他页面不能要分享，要隐藏掉分享按钮(发给朋友/分享到朋友圈/复制链接/收藏/邮件等等等)。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG65.jpeg?raw=true" alt="显示按钮"></th>
<th style="text-align:center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG66.jpeg?raw=true" alt="隐藏按钮"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>显示的页面需要在<code>wx.config</code>的<code>jsApiList:[]</code>里面添加<code>showOptionMenu</code>。并调用<code>wx.showOptionMenu();</code>显示方法。</p>
<p>隐藏的页面需要在<code>wx.config</code>的<code>jsApiList:[]</code>里面添加<code>hideOptionMenu</code>。并调用<code>wx.hideOptionMenu();</code>隐藏方法。</p>
<p>有隐藏就要对应有显示，比如第一个页面不作操作默认显示。第二个页面隐藏了，返回第一个页面分享按钮也会被隐藏。所以第一个页面要有显示调用。</p>
<h2 id="MUI的Picker使用问题"><a href="#MUI的Picker使用问题" class="headerlink" title="MUI的Picker使用问题"></a>MUI的Picker使用问题</h2><h3 id="调用MUI的Picker"><a href="#调用MUI的Picker" class="headerlink" title="调用MUI的Picker"></a>调用MUI的Picker</h3><p>用的MUI框架里的picker，调用起来还是很方便的，<code>layer: 2</code>是联级数量，支持多级picker，如果是单级的layer省略不写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cityPicker = <span class="keyword">new</span> $.PopPicker(&#123;</div><div class="line">	<span class="attr">layer</span>: <span class="number">2</span></div><div class="line">&#125;);</div><div class="line">cityPicker.setData(cityData);</div><div class="line"><span class="keyword">var</span> showCityPickerButton = <span class="built_in">document</span>.getElementById(<span class="string">'showCityPicker'</span>);</div><div class="line"><span class="keyword">var</span> cityResult = <span class="built_in">document</span>.getElementById(<span class="string">'selectCityContent'</span>);</div><div class="line">showCityPickerButton.addEventListener(<span class="string">'tap'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">	<span class="built_in">document</span>.activeElement.blur();</div><div class="line">	cityPicker.show(<span class="function"><span class="keyword">function</span>(<span class="params">items</span>) </span>&#123;</div><div class="line">		alert(items[<span class="number">0</span>].text + <span class="string">' '</span> + items[<span class="number">1</span>].text);<span class="comment">//点击确认时的选择结果</span></div><div class="line">		<span class="comment">//返回 false 可以阻止选择框的关闭</span></div><div class="line">		<span class="comment">//return false;</span></div><div class="line">	&#125;);</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h3 id="PopPicker在软键盘弹出时不能完全隐藏"><a href="#PopPicker在软键盘弹出时不能完全隐藏" class="headerlink" title="PopPicker在软键盘弹出时不能完全隐藏"></a>PopPicker在软键盘弹出时不能完全隐藏</h3><p>用的时候还有点问题，在火狐浏览器里，picker的cell都挤在一起了，根本无法滑动。至于是什么原因我也没有研究，因为在微信内置浏览器里可以用。还有另一个bug是不能不改的，iOS中有问题，Android中没问题。就是在输入信息页面，直接点击靠近屏幕下边缘的输入框，页面向上偏移，滑动页面时原本隐藏的picker粗线了。如下左图，右图才是它该有的样子。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG67.jpeg?raw=true" alt="picker出现了"></th>
<th style="text-align:center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG68.jpeg?raw=true" alt="正常的样子，不该出现"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>需要在mui.poppicker.js中增加初始化、show和hide方法中display的改变。解决办法如下，或见<a href="http://ask.dcloud.net.cn/article/603" target="_blank" rel="external">iOS键盘弹出后PopPicker出现的临时解决方法</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//init构造函数最后增加两行：</span></div><div class="line">self.panel.style.display = <span class="string">'none'</span>;</div><div class="line">self.body.style.display = <span class="string">'none'</span>;</div><div class="line"></div><div class="line"><span class="comment">//显示</span></div><div class="line">show: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">	<span class="comment">//增加以下2行</span></div><div class="line">	self.panel.style.display = <span class="string">'block'</span>;</div><div class="line">	self.body.style.display = <span class="string">'block'</span>;</div><div class="line">	self.callback = callback;</div><div class="line">	self.mask.show();</div><div class="line">	<span class="built_in">document</span>.body.classList.add($.className(<span class="string">'poppicker-active-for-page'</span>));</div><div class="line">	self.panel.classList.add($.className(<span class="string">'active'</span>));</div><div class="line">	<span class="comment">//处理物理返回键</span></div><div class="line">	self.__back = $.back;</div><div class="line">	$.back = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		self.hide();</div><div class="line">	&#125;;</div><div class="line">&#125;,</div><div class="line"><span class="comment">//隐藏</span></div><div class="line">hide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">	<span class="keyword">if</span> (self.disposed) <span class="keyword">return</span>;</div><div class="line">	self.panel.classList.remove($.className(<span class="string">'active'</span>));</div><div class="line">	self.mask.close();</div><div class="line">	<span class="built_in">document</span>.body.classList.remove($.className(<span class="string">'poppicker-active-for-page'</span>));</div><div class="line">	</div><div class="line">	<span class="comment">//增加以下2行</span></div><div class="line">	self.panel.style.display = <span class="string">'none'</span>;</div><div class="line">	self.body.style.display = <span class="string">'none'</span>;</div><div class="line">	</div><div class="line">	<span class="comment">//处理物理返回键</span></div><div class="line">	$.back=self.__back;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="MUI的样式mui-min-css与微信的weui-min-css冲突"><a href="#MUI的样式mui-min-css与微信的weui-min-css冲突" class="headerlink" title="MUI的样式mui.min.css与微信的weui.min.css冲突"></a>MUI的样式mui.min.css与微信的weui.min.css冲突</h3><p>因为做的是微信内置网页，所以使用了微信提供的<code>weui.min.css</code>样式，在做picker的时候，需要导入MUI的<code>mui.min.css</code>样式。这样一来<code>weui.min.css</code>里的很多div样式被覆盖了，写好的样式变成一团糟。只能放弃使用<code>mui.min.css</code>。</p>
<p>因为只用了picker，<code>mui.min.css</code>的作用并不多，只有在picker出现时，后面的半透明蒙版。去掉<code>mui.min.css</code>后，这层蒙版便不再出现了。这个问题还是挺大的，影响交互，picker显示时，还可以编辑输入框。</p>
<p>阅遍<code>mui.min.css</code>终于找到这层蒙版的样式控制，把下面这段css代码拿出来，放到自定义的css样式内即可。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.mui-backdrop</span> &#123;</div><div class="line">	<span class="attribute">position</span>: fixed;</div><div class="line">	<span class="attribute">z-index</span>: <span class="number">998</span>;</div><div class="line">	<span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">	<span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">	<span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">	<span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">	<span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0, 0, 0, .3)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="iOS第三方输入法遮盖输入框"><a href="#iOS第三方输入法遮盖输入框" class="headerlink" title="iOS第三方输入法遮盖输入框"></a>iOS第三方输入法遮盖输入框</h2><p>这是一个非常头疼的问题，之前一直没有发现，因为我根本不用第三方输入法。iOS原生输入法已经很强大了，搞不懂为什么还有人用搜狗百度之流的垃圾输入法，难道仅仅为了皮肤吗？Too naive。</p>
<p>即使用其他输入法，按顺序点击输入框，或者点击网页内弹出的软键盘上面自带工具条上的左右箭头键，切换输入框，这样操作也不会出现输入法遮盖输入框问题。而且这个问题在Android上也不存在。</p>
<p>唯独，一上来就点击页面底下的输入框，第三方输入法弹出缓慢，页面偏移距离计算错误，出现了输入法遮盖输入框的问题。好多网页出现这种问题，比如：各大门户网站的登录界面。</p>
<p>解决办法有点low，但还是比较完美的解决了这个bug，定义js方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">	SCROLLY = <span class="number">300</span>;</div><div class="line">	TIMER_NAME = <span class="number">200</span>;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">textfocusClick</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">			<span class="keyword">if</span>(<span class="built_in">window</span>.scrollY &lt; SCROLLY) &#123;</div><div class="line">				<span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">400</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;, TIMER_NAME)</div><div class="line">	&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>会被输入法遮盖的输入框调用方法:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"userNameInput"</span> <span class="attr">onclick</span>=<span class="string">"textfocusClick()"</span> <span class="attr">placeholder</span>=<span class="string">"请输入"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>定义的js方法，第三方输入法弹出时window.scrollY的值小于系统输入法弹出的，我大致试验出一个300的值(网络上给出的100等小值根本不行)。如果小于这个值就说明是第三方输入法首次弹出，要偏移页面<code>window.scrollTo(0, 400);</code>，偏移的数值根据需要设定。输入法本身就弹出了，再切换输入框，window.scrollY值会和系统输入法的一样，不会小于SCROLLY，所以不能偏移页面。因为网页会自动偏移，再进行代码偏移，会出现页面闪动。</p>
<p>输入框添加的是<code>onclick</code>点击事件，只有在点击输入框获取焦点的时候才调用，在用工具条上的切换按钮切换输入框焦点时不会调用。</p>
<h2 id="警示框的悬浮显示"><a href="#警示框的悬浮显示" class="headerlink" title="警示框的悬浮显示"></a>警示框的悬浮显示</h2><p>警示框不固定在页面上，不随页面滑动而滑动，要求悬浮在导航条下面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">	<span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</div><div class="line">		<span class="keyword">var</span> t = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</div><div class="line">		box.style.top = t + <span class="string">"px"</span>;</div><div class="line">	&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>设置警示框div的id为<code>box</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position:absolute;width: 100%;height: 45px; left: 0px;"</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="placeholder样式"><a href="#placeholder样式" class="headerlink" title="placeholder样式"></a>placeholder样式</h2><p>自定义输入框placeholder的文字样式，包括字号大小，字体颜色等，css样式如下。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* all */</span></div><div class="line"><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123;<span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="attribute">padding-top</span>: <span class="number">2px</span>;&#125;</div><div class="line"><span class="selector-pseudo">::-moz-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125;  <span class="selector-tag">firefox</span> 19+ </div><div class="line"><span class="selector-pseudo">:-ms-input-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125; <span class="comment">/* ie */</span></div><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:-moz-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125;</div><div class="line"></div><div class="line"><span class="comment">/* individual: webkit */</span></div><div class="line"><span class="selector-id">#field2</span><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#00f</span>; &#125;</div><div class="line"><span class="selector-id">#field3</span><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#090</span>; <span class="attribute">background</span>:lightgreen; <span class="attribute">text-transform</span>:uppercase; &#125;</div><div class="line"><span class="selector-id">#field4</span><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123; <span class="attribute">font-style</span>:italic; <span class="attribute">text-decoration</span>:overline; <span class="attribute">letter-spacing</span>:<span class="number">3px</span>; <span class="attribute">color</span>:<span class="number">#999</span>; &#125;</div><div class="line"></div><div class="line"><span class="comment">/* individual: mozilla */</span></div><div class="line"><span class="selector-id">#field2</span><span class="selector-pseudo">::-moz-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#00f</span>; &#125;</div><div class="line"><span class="selector-id">#field3</span><span class="selector-pseudo">::-moz-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#090</span>; <span class="attribute">background</span>:lightgreen; <span class="attribute">text-transform</span>:uppercase; &#125;</div><div class="line"><span class="selector-id">#field4</span><span class="selector-pseudo">::-moz-placeholder</span> &#123; <span class="attribute">font-style</span>:italic; <span class="attribute">text-decoration</span>:overline; <span class="attribute">letter-spacing</span>:<span class="number">3px</span>; <span class="attribute">color</span>:<span class="number">#999</span>; &#125;</div></pre></td></tr></table></figure>
<h2 id="正则使用"><a href="#正则使用" class="headerlink" title="正则使用"></a>正则使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myreg = <span class="regexp">/^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(17[0-9]&#123;1&#125;)|(18[0-9]&#123;1&#125;))+\d&#123;8&#125;)$/</span>;</div><div class="line"><span class="keyword">if</span>(myreg.test(phoneNumText)) &#123;</div><div class="line">	alert(<span class="string">"手机号正确"</span>)；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作需要，用HTML5写一个微信的内置网页，是一个参会报名流程。上次写html还是上学时交作业，现在着实有些手忙脚乱了，现学现用、磕磕绊绊，项目总算告一段落，到了要总结一下的时候了。简单记录了做这个项目时所遇到的问题，有些问题在网上能搜到解决办法，有些问题是为了实现效果耍的小聪明。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML5" scheme="http://markmiao.com/categories/HTML5/"/>
    
    
      <category term="HTML5" scheme="http://markmiao.com/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>记四天的香港旅程</title>
    <link href="http://markmiao.com/2016/11/22/%E8%AE%B0%E5%9B%9B%E5%A4%A9%E7%9A%84%E9%A6%99%E6%B8%AF%E6%97%85%E7%A8%8B/"/>
    <id>http://markmiao.com/2016/11/22/记四天的香港旅程/</id>
    <published>2016-11-22T08:00:57.000Z</published>
    <updated>2016-11-27T05:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前在豆瓣发过此文，但总感觉时间匆匆过于潦草，想再改改。一拖一个多月过去了，即时游记拖成了回忆录，我怕再过些日子，回忆录就忘的只剩目录了。</p>
<p>读万卷书的意志已消磨光了，行万里路的兴趣慢慢燃起来了。以前讨厌旅游，现在也想有时间多出去玩玩，毕竟还是个爱玩的宝宝。本文记录了我和晓为期四天的香港旅行，这一次不再是文长无图，谨慎入坑。而是图文并茂，欢迎阅读。</p>
<a id="more"></a>
<h2 id="起程，香港"><a href="#起程，香港" class="headerlink" title="起程，香港"></a>起程，香港</h2><p><img src="/img/WechatIMG171.jpeg" alt="香港维多利亚港"></p>
<p>香港，在我印象里只存在于电视电影，好像是个虚构出来的地方，就像“从前有座山”里的那座山。</p>
<p>当听晓说要去香港的时候，我第一反应是拒绝的。我已经过了那个青春热血的古惑仔年纪，为啥要去香港？在我印象中香港最著名的是铜锣湾，铜锣湾最牛逼的是扛把子浩南哥，充满了刀光剑影，弥漫着青春期荷尔蒙。我已步入90后空巢老人的行列了，哪经得起年轻人的折腾。</p>
<p>晓用眼神告诉我香港势在必行，我的一切反对理论都是荒谬且不靠谱的。好！去！反对的理论是荒谬的，赞成的回答是睿智的。现在知道作为一个程序猿是怎么交到女朋友的了吧？！</p>
<p>既然决定去了，做攻略，买机票，订酒店一系列的事接踵而至。乱七八糟的事都是第一次弄，我这磨磨蹭蹭的性格不可避免的产生了诸多麻烦。不过现在也总算是顺利坐上了从北京西站开往深圳的火车，开始了第一篇游记。</p>
<p><img src="/img/WechatIMG188.jpeg" alt="18:42去北京西站的地铁换乘路上"></p>
<p>都说性格决定命运，看来我是充满坎坷的命运。我总是天真的认为车到山前必有路，船到桥头自然直。一切有所布局，便能水到渠成。却不想水到了，渠还没成，一浪拍在了沙滩上。这就是空有决胜千里之外的愿望，没有运筹帷幄之中的能力。</p>
<p>机票一定要提前订，提前订，提前订，重要的事情说三遍。临近起程的日子机票打折的几率太小了，除非人品爆棚，折扣大概能接受就订。我就是吃了磨叽的亏，临近出发前一周，发现机票涨价了。这时买当然不甘心了，但他娘的谁知道往后他是涨是降啊，不会要含着热泪买高价票吧？权衡再三买了到深圳的动车卧铺票。虽然要在火车上睡一晚上，但是时间上来说会比坐飞机好点。</p>
<p>之所以到深圳是因为我不争气的家乡，港澳通只能L签，进香港只能跟团。所以要到深圳找旅游团开过关单子，然后才能过海关进港。过关服务淘宝一搜一大把，5块钱搞定。</p>
<p>买回程机票时也经历价格波动的调戏，我中午看票还3.1折，下午准备买的时候就变成5折了。我当时十分清楚地感觉到了晓眼中的杀气，我也追悔莫及为啥中午不买！可喜的是第二天回到了3.1折，立刻买了！竟然有种得了便宜的窃喜感。</p>
<p>除了被机票折磨，就是被手机卡摧残。淘宝了一张香港四天无限4G卡，提前五天买的，当天下午就发货了，快递信息在第二天更新完停留了四天，手机卡从深圳发出后失联了！出发前一天和卖家交涉，卖家给的答复是最近寄往北京的件都慢。我也是悲催，赶上了。出发当天和卖家打了一早上嘴仗，快递信息总算更新了，手机卡也总算拿到了。</p>
<p>临了临了，晚节不保，临上动车前还被ATM机调戏了一把。候车室里破旧的ATM机，我真怕它吃我卡。我的担心倒是没发生，但也让我心惊肉跳了一把。插了卡，输了密码，输了取款金额，手机收到扣款信息……然后就是漫长的等待，我估计等了大概两分钟，屏幕突然煞白，出现了操作失败请联系发卡行的字样。完犊子了，扣了钱，钱没出来，MLG……脏话还没骂完，银行卡被吐出来了，手机上收到了入款信息。吓得我赶紧换了一个ATM机。</p>
<p>现在回想起来，好像没什么开心的事。唯一开心的事就是晓现在心情不错，所以我也很开心。希望我们这次香港之旅玩的快乐，我的游记写的有趣。</p>
<p><img src="/img/WechatIMG172.jpeg" alt="北京西站进站前的雾霾天"></p>
<h2 id="过关，入港"><a href="#过关，入港" class="headerlink" title="过关，入港"></a>过关，入港</h2><p>迷迷瞪瞪睡了一夜，早上7点25到深圳北站。从窗外望去，满眼翠绿，偶尔闪过的那种热带地区才有的大叶树让我们觉得新鲜。</p>
<p>下动车后，晓拉着我说：你看你看，那都有树。我看了一眼说：你要淡定，要装作经常来的样子，别整的跟山炮进城似的。晓心情好，白瞪了我一眼，嘟囔了一句：你才山炮呢。</p>
<p>在深圳北站逗留了很短的时间，坐地铁赶到福田口岸，拿了5块钱买的入关团签表，排队过关。排队的人不是很多，相比较北京工作日早高峰地铁排队情况来说。过关很容易，出示港澳通和团签表，海关看都没看我一眼，戳了个印就过了。出了中国海关，入香港海关，流程一样，第二次连团签表都不看了。</p>
<p><img src="/img/WechatIMG173.jpeg" alt="中国海关"></p>
<p>从福田口岸的落马洲站到尖沙咀，坐港铁40港币！100块可用额度的八达通一下扣款近一半，有点蒙圈，顿时感觉北京地铁真良心，即使涨价后也还是良心的有些可爱。</p>
<p>还发现香港地铁是没有安检的，我一直不认为北京地铁安检能检出什么危险物品，倒是对限流和秩序维持起到了很大的作用，毕竟中国人多而且大家都忙，限流和秩序很有必要。</p>
<p>第一天没去远的地方逛。吃了顿茶餐厅和麦当劳，去了趟维多利亚港和海港城。</p>
<p>香港茶餐厅挺出名的，之前一直听说，这次有机会试一试了。食物偏西式，甜腻甜腻的，吃一点就有点腻。然后两个人两份煲仔饭外加六个翅中，风卷残云后，就剩骨头了，看来再腻的饭饿疯了也能吃下去。</p>
<p><img src="/img/WechatIMG175.jpeg" alt="在茶餐厅风卷残云的吃了一顿"></p>
<p>下午实在没找到啥好吃的，就去吃麦当劳了。无意中看到麦当劳的招聘广告，服务员月薪10000港币，合人民币8600多。在香港当服务员至少要会三门语言：粤语、 英语、普通话。去好多店里，服务员打招呼都是：雷吼啊、hello、你好。看你说什么话，再以相同的话接待你。我想说：哎呀大妹子，你这有秋裤不？会不会给服务员干懵逼了。</p>
<p>原计划第一站是星光大道，我想去看看李小龙的雕像。星光大道就在维多利亚港旁边，我们住在尖沙咀，走到维多利亚港也就十多分钟的路程。</p>
<p><img src="/img/WechatIMG176.jpeg" alt="去维多利亚港的路上"></p>
<p>我们在维多利亚港周围顶着烈日转了半个多小时，被晒成傻逼了，还是没找到星光大道。我找到一位看起来和蔼可亲的大爷，问他星光大道怎么走？就是有李小龙雕像那个，说着还拉了一个架势。大爷呲着大牙一笑，操着一口粤语普通话说：一年前就关啦！我有些懵逼，啥玩意？大爷又重复了一遍：去年就关啦，在装修，三年后开放，现在进不去啦！我勒个去，大陆消息封锁太严密了吧，网上没人说星光大道关张大吉了啊！</p>
<p>星光大道没见到，转身去了海港城。听说这里是香港最大的购物商城，里面应有尽有，别管男女老少肯定有你中意的东西。事实是没骗我，每一件我都中意，就是买不起。我问晓：这都是啥牌子？晓说：轻奢品牌。我说：这才轻奢呢？重奢不得死去！晓又白瞪了我一眼，嘟囔了一句：山炮。语气我听出来了，这次不是娇嗔，是真在骂我。</p>
<p><img src="/img/WechatIMG177.jpeg" alt="海港城外的海港"></p>
<p>我的消费层次一直很low逼，以前是地摊货，现在是商城，去逛高端点的商城，比如西单大悦城，我还是有点自惭形秽。逛海港城，真感觉像山炮进城。我就是那种别人在炫富我都看不出来的人。努力装作经常来的样子，转角看到了一个熟悉的品牌H&amp;M，立马有种亲切感，像是low逼的品味有地儿接住了。重申不是说H&amp;M品牌low，意思是H&amp;M大众亲民，品牌知名度广。</p>
<p>维多利亚港的景色还是挺美的，特别是夜景。灯火璀璨映照着海面，真有点影视剧里的感觉。坐游轮，欣赏夜景，浑身没有半两品味的我也感觉到了好惬意啊！潮湿的海风，晴朗的夜空，三三两两的外国人席地而坐，好多游人在拍夜景，还时不时有一群海鸥飞过，这才叫生活嘛。</p>
<p><img src="/img/WechatIMG178.jpeg" alt="维多利亚港夜景"></p>
<p>坐天星小轮去中环码头，那里有个湾仔码头可以吃水饺（开玩笑了，提起湾仔码头第一反应就是水饺）。来香港一定要乘坐一次天星小轮，两元港币横渡维多利亚港。夜色下海水有种很深邃的感觉，我问晓：这里有鲨鱼吗？晓说：没有，你跳船游过去吧。我说：我怕被人当成海怪打死。</p>
<p><img src="/img/WechatIMG179.jpeg" alt="乘坐天星小轮"></p>
<p>之前也听说维多利亚港晚上8点有盛大的烟花表演，事实呢？好多年都没有了。虽然有些遗憾，但是夜景还是让我们满足。</p>
<p>香港，毕竟还是离我们很远。说只有影视剧的印象是有些夸张，但真实的香港与在大陆的所见所闻还是有些差距的。</p>
<h2 id="海洋公园，蜡像馆"><a href="#海洋公园，蜡像馆" class="headerlink" title="海洋公园，蜡像馆"></a>海洋公园，蜡像馆</h2><p>来香港的第二天，去海洋公园和杜莎夫人蜡像馆。万圣节主题的海洋公园还是挺有趣的，在山上的蜡像馆还是挺折腾人的。</p>
<p><img src="/img/WechatIMG189.jpeg" alt="俯视海洋公园的游乐场"></p>
<p>海洋公园十点开门，之前查过攻略，不过临行前忘记了。早早坐港铁到金钟站，坐海洋公园巴士赶到海洋馆，提前了半个多小时。其实还是提前点好，人少，玩什么看什么基本都不用排队，下午三点多就差不多玩完了，出园的时候看到有好多人都在排队，那种感觉——爽！</p>
<p>相比较大陆的景区，香港海洋公园的通票通的非常彻底，园内的任何娱乐设施，任何展馆，任何场地，包括万圣节节日主题表演场馆都可以进去，没有额外费用，也没有人查票。晓说：除了吃的。这可以理解，毕竟不是自助餐式海洋公园。其实也可以说这是总价票，所有娱乐费用都缴过了，玩不玩当然没人管你。</p>
<p>游玩的顺序有些失策，初进海洋公园，我俩有些控记不住几己，见了啥都想上去玩一番，上来就玩了个大转盘，脑浆子都快被从耳朵眼里甩出去了。以至于晓一直有些头晕不适，加上10月份的香港还是艳阳高照仲夏时节，我俩脑袋都有些晕晕乎乎，碰上其他的刺激娱乐都有些望而却步。</p>
<p><img src="/img/WechatIMG190.jpeg" alt="差点甩吐了的大转盘"></p>
<p>海洋公园感觉娱乐设施比海洋动物多，过山车、魔天轮、太阳神车……我说：连个海龟都没有，为啥叫海洋公园，叫香港欢乐谷得了。现在回想起来，倒是真没看见海龟哎。玩大转盘把晓的脑水给咣当的活了浆糊，玩过山车时晓本打算不上了，工作人员说：这个很平稳不晃，不会晕的。然后就脑子就彻底成糊糊了，后来的“翻天覆地”我一个人上了，然后我也糊糊了。</p>
<p><img src="/img/WechatIMG191.jpeg" alt="我在上面，差点吐了整个海洋公园"></p>
<p>其实这些刺激娱乐还好，无一例外的把我们晃晕了。后来的海洋列车，虽然没晕，但是失望啊。一辆像是装了甲的火车，我们俩一致认为这个会进入海底隧道，透过如同游轮上的圆形玻璃窗能看到幽蓝深邃的海底世界。列车开动了，我俩激动的像是看见狗粮的榴莲（榴莲是我家养的一只金毛），我们还一直担心一会儿会不会有大乌贼撞到窗户上来。车里灯光闪烁，音乐环绕，头顶上一块一块屏幕放映着海底影像，我说：这气氛渲染的还蛮不错的。时间一分一秒的过去，窗户外面不但没有蓝色的海洋，连萤火虫屁股大的光都没有。我好像意识到：这灯光音乐和头顶的屏幕不是气氛渲染，这就是该项目的正主。不一会儿，窗户亮了，到站了！什么破烂玩意儿，坐地铁看了集动物世界预告片。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="/img/WechatIMG192.jpeg" alt="启动前的海洋列车"></th>
<th style="text-align:center"><img src="/img/WechatIMG193.jpeg" alt="启动起来的海洋列车"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>万圣节快要到了，海洋公园开了好多万圣节主题场馆，有各种鬼屋。我进了一间校园鬼屋，说真的还真有点阴森恐怖感，阴森的环境布置，妖异的背景音乐，灰暗的灯光，时不时的惨叫声……有点要被吓尿了的感觉。我一直在提醒自己这是假的，微笑着向各个扮演鬼怪的工作人员打招呼，他们看着我微笑，也就不一惊一乍的吓我了，还会扭曲身体跳舞给我看。何况入场馆的时候，人也跟我说了：善待工作人员，不要殴打他们。所以我要微笑。</p>
<p><img src="/img/WechatIMG194.jpeg" alt="华为赞助的照妖宫殿"></p>
<p>海洋公园当然也是有海洋动物的，海狮、海豚、鲨鱼、企鹅、北极狐等等，我们一个馆一个馆的转，一会冷，一会热，动物们都自由自在的享受着美食，真不知道是人度假来看动物，还是来受罪给动物看的。</p>
<p>有几个时间段有海豚表演，海豚真的特别聪明，做各种弹跳动作，做完一系列动作才去问饲养员要吃的。不像我家榴莲，拿着零食叫它坐，它会在坐下的同时冷不丁的一口抢走你手中的零食。这就是聪明到能上舞台的动物明星和一个蠢萌到把心眼全都用到吃上的饭桶狗的差别，其实我还是喜欢饭桶狗。</p>
<p><img src="/img/WechatIMG195.jpeg" alt="等着看海豚表演的观众席"></p>
<p>出场馆的时候看到好多cosplay万圣节主题人物的，吸血鬼、女巫、河童……我去和一个女巫合影，晓给拍照，晓说：你亲她。我还没嘟嘴亲呢，女巫说：真的不能亲吆，假装可以。我心想：你这一脸的白粉，假装我也假装不来啊。准备拍的时候，一只吸血鬼闪过来凑热闹，又快速的闪跑了，不知做了什么表情，周围的人一阵嬉笑，只可惜没拍到。</p>
<p><img src="/img/WechatIMG196.jpeg" alt="和我打招呼的河童"></p>
<p>从海洋公园出来，去杜莎夫人蜡像馆。蜡像馆在山顶，那个巴士站就叫山顶。从金钟站坐15路巴士，走过好多盘山道，才到山顶。这是一个像大商场的地方，有好几栋商场大厦。我们来回找了好一阵也没看到蜡像馆，反而看到了好多狗狗，广场上，室外餐厅里都有各种狗。晓倒是挺兴奋的，到处跟狗打招呼。我只能跟人打招呼去问蜡像馆在哪里，一问才知道，在其中一个商场的地下。</p>
<p><img src="/img/WechatIMG197.jpeg" alt="在杜莎夫人蜡像馆处俯视香港"></p>
<p>我是在大众点评上买的票，票据兑换证明以邮件形式发过来的，这个证明必须打印出来，然后去兑换入场门票。在蜡像馆所在大厦的对面大厦有个ePhone店，那里可以打印。价格不菲，建议提前打印好。</p>
<p>几经折腾终于进蜡像馆了，其实我所期待的小龙哥死亡游戏里一身黄衣的经典造型就在场馆外，不用买票就可以拍照合影。</p>
<p><img src="/img/WechatIMG198.jpeg" alt="在场馆门口的小龙哥"></p>
<p>蜡像馆里有各种人物蜡像，古今中外、各国明星、政客领袖、影视人物等等，反正种类是挺多的。去蜡像馆就是合影，是所有游客共同的目的。热门人物身边会一个接一个的有人和他过去合照，冷门人物就得不到游客的垂怜。比如古天乐、吴彦祖身边都排着队照相，曾志伟身边就寥寥无几。每个照相的都摆尽姿势，各种猥琐恶搞，挎胳膊搂肩算正常的，更甚者掏裆袭胸摸大腿。绝大多数蜡像都不限制拍照，也不限制抚摸，只有一少部分拍照是需要花钱的，比如习总书记的。开心的是还有漫威里的钢铁侠、金刚狼、绿巨人，简直惟妙惟肖，终于近距离袭了钢铁侠的胸，摸了金刚狼的爪，捅了绿巨人的嘴。哈哈哈~~</p>
<p><img src="/img/WechatIMG199.jpeg" alt="你们喜欢的哥哥"></p>
<p>有些失望的是蜡像馆竟然没有万圣节主题，按说相比较海洋公园，蜡像馆才更适合弄一些惊悚恐怖元素。比如棺材里的僵尸蜡像、闸刀下的断头饿鬼、真人扮演蜡像吓唬游客……还是很有万圣节恶趣味的。估计是短时间内难以做出品质很高的蜡像，游览快结束的时候，有视频演示蜡像制作过程，甄子丹奉献出自己的老脸取模型，然后再做蜡像，看起来挺高端的。</p>
<p>从蜡像馆回去的时候差不多六点了。路过铜锣湾，去逛了一下崇光百货。晓美其名曰的要帮同事带口红，然后同事没要，她自己买了一管口红一盒粉。谁告诉我香港化妆品便宜的？出来跟我下个月一起啃馒头聊人生。</p>
<h2 id="铜锣湾，迪士尼"><a href="#铜锣湾，迪士尼" class="headerlink" title="铜锣湾，迪士尼"></a>铜锣湾，迪士尼</h2><p>昨天去海洋公园去早了，今天打算晚点去迪士尼。先去趟铜锣湾逛逛街，昨晚的确没逛尽兴。相比较昨天的不尽兴，今天迪士尼之行不是不尽兴，而是败兴。乘兴而来，败兴而归。</p>
<p>早上去铜锣湾吃饭，铜锣湾出名的不仅有陈浩南，还有购物和美食。前两天见识到了香港人早上起的晚，绝大多数店面十点以后开门，更有甚者十二点一点开门。今天出门已经比较晚了，对于几日游的游客来说，晚出门简直就是对时间最罪恶的浪费。刻意晚点出门还是有点早，即便是周一工作日香港还是醒的很晚。</p>
<p>去铜锣湾的一栋大厦吃早餐，去了一家营业了的早茶餐厅。一进门服务员问我俩：两位喝什么茶？我说：不喝茶吃饭。晓说：早茶馆，得喝茶。哦，我又山炮了。一壶大麦茶，几种面食有叉烧包、烧卖、小笼包、饺子，外加一碗白粥，白粥是咸的，但味道还挺好。面食里只有饺子的味道有些符合北方人口味，其他的还都是偏甜偏腻。</p>
<p><img src="/img/WechatIMG200.jpeg" alt="早茶餐厅里的虾仁烧麦，虾真的好多"></p>
<p>在等上菜的时候，晓发现了一个问题：整个早茶餐厅用餐的全部都是老人，甚至服务员也都是老人，刚刚问我们喝什么茶的是个领班，看样子也有五十多岁了，在这里面算年轻人了。给我们端粥的老人有六七十岁了，颤颤巍巍，我怕她一个托不住把粥浇我头上。难道这是老年餐厅？还是在香港只有老年人有闲情逸致去早早的喝早茶，年轻人要么上班要么睡觉？</p>
<p>迪士尼，坐城铁就可以到，很方便。有一条迪士尼专线，列车设计就是迪士尼风格。去了迪士尼才让我真正领略到了什么是身处童话世界，各种动画里的音乐场景人物，不单单是人穿着皮套扮演那么简单。迪士尼真的挺适合带着孩子一起来，孩子丰富的想象力，只有迪士尼能让他的想象变为现实。</p>
<p><img src="/img/WechatIMG202.jpeg" alt="迪士尼大门前"></p>
<p><img src="/img/WechatIMG203.jpeg" alt="迪士尼的标志米老鼠"></p>
<p>先去看的人猿泰山，人猿泰山的树屋在一个岛上，需要坐木筏子过去。大树上是泰山的家，我看见人猿泰山里的大花豹，走过去时突然一声豹吼吓了我们俩一跳，豹子是动画里的样子，周围环境也完全和动画里一样，氛围太逼真，以至于听到那声豹吼时以为豹子会突然扑过来。</p>
<p><img src="/img/WechatIMG204.jpeg" alt="人猿泰山里的大花豹"></p>
<p>迷离山庄是香港迪士尼全球独有的主题园区，传说是亨利爵士与他的助手小猴子阿拔游历世界，收集了各种奇珍异宝，保存在迷离大宅里。我们一起坐游览车游览迷离大宅，在小猴子的带领下，简直就是进入了博物馆奇妙夜。一条金光闪闪的龙忽然活了，仰头吐出一串星光，星光飘过，迷离大宅里的藏品仿佛活了一样，眼前的雕像在唱歌，壁画在说话，钢琴会自己弹奏，大炮会发射炮弹，冰冷的寒风刮起冰雪世界，食人花向我们张开大口，木乃伊在裹尸布里扭动，尸鳖爬了出来……一切都太真实了，视觉，听觉，触觉，嗅觉全方位能感知到周围的奇幻世界。我们根本无暇去拍照，被眼前的景象惊呆了，有原始人拉满弓向我们射箭，箭仿佛擦过我们的脸颊，把小猴子钉在墙上了；壁画上一个美丽的少女在唱歌，突然满头金发变成一条条的蛇，少女变成了一个蛇妖；冷风吹过，把周围的世界都冰封了起来，看到镜子里的自己也被冰封住了。</p>
<p><img src="/img/WechatIMG205.jpeg" alt="迷离大宅里的藏品"></p>
<p><img src="/img/WechatIMG206.jpeg" alt="开启梦幻之旅的小猴子阿拔"></p>
<p>还有坐过山车穿过的灰熊山谷，各种王子与公主故事的梦想花园，小熊维尼历险之旅，玩具总动员，明日世界星球大战，反斗奇兵，蒸汽火车，烟花表演，万圣节主题……还有好多游行表演。</p>
<p>但是我们看的玩的不过五分之一，因为天下雨了。外景场馆全部停止游玩，一场雨扫了所有兴致。</p>
<p><img src="/img/WechatIMG207.jpeg" alt="已经停止运行的旋转木马"></p>
<p>强烈建议计划去玩的朋友们把迪士尼之旅安排在前几天，一定要看好天气！千万别有雨有台风的时候去。一张票在七天工作日内可进去两次，一次玩不尽兴的可以再去一次。我们就是吃了天气与时间的亏，不但天公不作美，也没有时间再去一次了。</p>
<p>从迪士尼败兴而归，又回到铜锣湾。这次去了希慎广场，这里有全香港最大的Apple Store，我爱吃苹果，晓爱玩iPhone，然而并没有什么卵用，Apple Store不卖苹果，也没有iPhone7 Plus。还有占据三层楼的诚品书店，也没有什么卵用，我们已经变的只爱看手机不爱看书了。</p>
<p>然后我们频繁出入化妆品、服装、包包店，这是我们共同的兴趣爱好，至少我的游记里是这么写的。毕竟我只是游记编辑，还有审稿呢。我们快快乐乐的挑选着各种口红、各种霜、各种服装、各种包。我也是从旁给予十分中肯的评价意见：“恩，好看，好，不错……挺配你的……”。</p>
<h2 id="回程，最后的告别"><a href="#回程，最后的告别" class="headerlink" title="回程，最后的告别"></a>回程，最后的告别</h2><p>来香港的第四天，疲惫已经超过了兴奋。所以建议把重头戏安排在前两天，因为最后的时候，人也累了，兴趣也少了。</p>
<p><img src="/img/WechatIMG209.jpeg" alt="离港时的雨天"></p>
<p>原计划是要去一次南丫岛，由于时间距离天气等原因取消了。最后一天还是去逛街了，去了东涌站的东荟城名店仓，感受了一把“商场野餐”。去了机场免税店，狠狠的买了几大包吃的。</p>
<p>在香港的最后一天还在下雨，计划的行程也大部分完成。下午就要回北京了，剩余的时间说多不多，说少不少。也没什么特别想去的地方，索性不再折腾了。收拾好东西打算直接去机场，临走前逛逛机场免税店。</p>
<p>在去机场的港铁上改了主意，打算去一趟东涌站，那边有东荟城和奥特莱斯，都是折扣商场。好吧，还是逛街购物，反正到哪都是逛吃逛吃逛吃……</p>
<p>这次在东荟城逛倒是没逛出什么名堂，吃可是吃的尴尬到了天际。事情是这样的，逛商场时看到有卖快餐的。平时吃快餐吃的都快吐了，但这几天吃的满肚子油腻，都吃出便秘了，看见快餐有种他乡遇故知的感觉。</p>
<p>我们俩一人打包了一份，量还很大。买完之后发现没地方吃，记得商场里有个麦当劳，想去那里找个地方吃。辗转找到麦当劳，队排的跟北京地铁里似的，一个位置都没有，而且人都是在吃汉堡薯条，我俩坐下哼哧哼哧的吃盒饭也不合适啊。我双手托着两盒快餐外加一盒水果，和晓四目相对懵逼的杵在商场里。</p>
<p>杵在那里总不是个事，打算去拿行李去机场再吃。行李寄存在地下二层，那是一个僻静的停车场。盒饭有汤有水也不好带，我看四周没啥人，建议就在这野餐得了，铺了张纸席地而坐吃起来了。</p>
<p>偶尔下来一两个人，我俩感觉尴尬的要死。仗着人生地不熟，谁也不认识谁，索性甩开腮帮子，撩开后槽牙吃吧！这时下来四五个大学生，看到我们在吃饭就乐了，是那种尴尬的乐。啥情况？我还没缓过尴尬的劲，她们就在另一个角上也坐下吃东西！好吧，同是天涯沦落人，就看谁能尬过谁。她们人多明显占优势，有说有笑的，我俩就尴尬了。我脸皮厚还好点，晓已经尴尬的吃不下了，我大概扒拉了几口，拿了行李赶紧走了，“商场野餐”也算是完美落幕。</p>
<p><img src="/img/WechatIMG210.jpeg" alt="香港机场"></p>
<p>到了机场，办理登机手续，退八达通。剩了七八百港币，本打算兑换成人民币，可是机场兑换点汇率太低，100元港币只能兑换82元人民币。就没有兑换，然后就都花了，都花了，花了……</p>
<p>机场免税店的东西挺多，也不算贵，我俩帮朋友带，买了自己吃，啥也想尝尝，最后买了两大包，最终没有辜负作为两个吃货的尊严。进机场安检的时候，安检人员指着一个图片问：有这款手机吗？我一看是三星note7，连忙摇头说没有！看来note7不能上飞机不是传言。</p>
<p>登机前，外面还在下雨。在香港待了四天，两天半好天，一天半下雨。计划的行程也差不多完成了：</p>
<ol>
<li><p>星光大道，封闭装修没去成功，没见到小龙哥的雕像，没见到明星们的手印，失败。</p>
</li>
<li><p>维多利亚海港，欣赏了夜景，但是没看到烟花，多少年前就没有了。</p>
</li>
<li><p>坐天星小轮，两元港币横渡维多利亚港，欣赏海岸线上香港大厦灯光璀璨，最值最赞的香港旅游体验。</p>
</li>
<li><p>海洋公园，玩的刺激，看的精彩。重点是没怎么排队，虽有小遗憾但也很值了。</p>
</li>
<li><p>杜莎夫人蜡像馆，虽然路途很辗转，但最终看到的蜡像也是蛮不错的。</p>
</li>
<li><p>铜锣湾，购物很丰富，美食也很多。既需要时间慢慢去发掘，又需要钱去支持发掘。</p>
</li>
<li><p>迪士尼，真正的童话世界。一场雨留下了太多遗憾，我从未如此讨厌过下雨。会有弥补遗憾的那一天。</p>
</li>
<li><p>海港城，轻奢品牌商场，应有尽有，总有你中意的一款，购物者的天堂，钞票的焚烧炉。</p>
</li>
<li><p>东荟城，折扣商城，各种品牌折扣。有时间逛的话肯定能淘换到实惠的好东西。</p>
</li>
<li><p>免税店，国际机场都会有免税店。会有一些特产和吸引人的品牌，而且价格也不贵，不买一些会感觉不甘心。</p>
</li>
</ol>
<p>坐上回北京的飞机，时间过的好快。四天香港之旅结束了，这是我第一次出大陆，虽然有各种遗憾（好像每次旅行，都会有遗憾），但总归还是一次不错的旅行。流水账式的记录下这次旅行，也算给以后的回忆留一个依据吧。上天貌似感觉我们这趟旅程还不够坎坷，最后还加了个彩蛋，下飞机打车回家，大半夜的赶上北五环查车，几十辆大卡车被查了，堵车堵了一个多小时，到家都快凌晨了。进家门的那一刻，我们俩对视了一下，不由得苦笑，简直是身心俱疲……</p>
<h2 id="附，个人攻略"><a href="#附，个人攻略" class="headerlink" title="附，个人攻略"></a>附，个人攻略</h2><p>看到这里的要么是真爱，要么是无聊。附上一些个人攻略，希望对要去香港的朋友们有一点点帮助。</p>
<ol>
<li><p>L签的旅客不能直接进港，从深圳过海关，可以在淘宝上买相应口岸的过关服务，在过关前拿单子过关即可，好用还不贵。回来的时候可以从香港直飞即可。</p>
</li>
<li><p>最好提前兑换港币，过关时兑换得排队，汇率差别也很大。国内各大银行差不多都可兑换，需要提前预约。预约好也可以兑换小面值港币，并不是只能兑换1千面值。即便是1千面值也可在香港境内破开，虽然好多店铺不收1千面值的，但充八达通是可以的。</p>
</li>
<li><p>八达通可以在港铁进站时买，不用提前淘宝，使用不超过30天退会有9港币手续费，可以用八达通在各种店面刷卡付款。也有其他的套票卡，比如三天不限次乘坐港铁，包含一次或两次机场线。</p>
</li>
<li><p>淘宝可以买到几天的香港无限流量卡，强烈建议几个人就买几张卡。开热点容易断，信号不好，太麻烦。</p>
</li>
<li><p>记得带英标转接插头，有的酒店里会提供，万一不提供会产生很多不必要的麻烦。</p>
</li>
<li><p>海关其实查的不严，只要证件齐全有效，带台iPhone完全没问题，并不像网上说的那样一台iPhone自用都要报税。你把iPhone拼成铠甲披身上被查也不能怨政府。</p>
</li>
<li><p>在大众点评上可以买迪士尼，海洋公园，蜡像馆的门票，会发一封兑换票据的邮件，迪士尼和海洋公园的邮件不用打印，直接扫码入园，迪士尼如果买餐券的话需要兑换。蜡像馆的邮件必须打印，不然不给你兑票。虽然大众点评上都说的是需要打印。</p>
</li>
<li><p>去机场可以不坐机场线，因为机场线特别贵。可以坐到东涌站，坐机场巴士到机场，几块钱即可搞定。</p>
</li>
<li><p>买水要去大型超市买，会便宜一半，4-5港币一瓶，外面小店以及港铁里的7-Eleven都8-9港币，依云这类神水都20多港币。</p>
</li>
<li><p>旅馆里每天会给你补充到两瓶水，即使喝不完也要藏起来或带出去，不然也不会多给你一瓶。毕竟一瓶水好几块钱呢。（这一条酒店不同可能不一样）</p>
</li>
<li><p>最后一个，香港是靠左边走的。时刻记住靠左边，特别是在港铁站里去坐扶梯的时候，靠右走过去会发现是反方向的扶梯，栏杆隔的很严密，只能退回来再去左边。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在豆瓣发过此文，但总感觉时间匆匆过于潦草，想再改改。一拖一个多月过去了，即时游记拖成了回忆录，我怕再过些日子，回忆录就忘的只剩目录了。&lt;/p&gt;
&lt;p&gt;读万卷书的意志已消磨光了，行万里路的兴趣慢慢燃起来了。以前讨厌旅游，现在也想有时间多出去玩玩，毕竟还是个爱玩的宝宝。本文记录了我和晓为期四天的香港旅行，这一次不再是文长无图，谨慎入坑。而是图文并茂，欢迎阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="记事" scheme="http://markmiao.com/categories/%E8%AE%B0%E4%BA%8B/"/>
    
    
      <category term="生活" scheme="http://markmiao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="游记" scheme="http://markmiao.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
</feed>
