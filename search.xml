<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue与App交互</title>
    <url>/2020/12/11/vuenative/</url>
    <content><![CDATA[<p>app开发经常会内嵌h5页面，原生app与h5页面相互调用，完成数据传递。一套h5页面能多端运行，实现跨平台，这就是常见的Hybrid app（混合app）</p>
<a id="more"></a>

<h2 id="WKWebView"><a href="#WKWebView" class="headerlink" title="WKWebView"></a>WKWebView</h2><h3 id="通过-url-向-vue-传参"><a href="#通过-url-向-vue-传参" class="headerlink" title="通过 url 向 vue 传参"></a>通过 url 向 vue 传参</h3><p>在原生WKWebView中加载URL时，以拼接方式向h5页面传参：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urlStr = <span class="string">"https://markmiao.com/app/request?data=123"</span></span><br><span class="line"><span class="keyword">let</span> request = <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: urlStr)!)</span><br><span class="line">webView.load(request)</span><br></pre></td></tr></table></figure>

<p>vue中接收传递数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.data &#x3D; this.$route.query.data</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>&amp;</code>符号拼接多个参数传递：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urlStr = <span class="string">"https://markmiao.com/app/request?data=123&amp;index=1"</span></span><br></pre></td></tr></table></figure>

<p>URL是有长度限制的，如果要传递的数据很多，可以采用<code>evaluateJavaScript</code>，在原生中调用vue中的js方法传递数据。</p>
<h3 id="evaluateJavaScript-向-vue-传参"><a href="#evaluateJavaScript-向-vue-传参" class="headerlink" title="evaluateJavaScript 向 vue 传参"></a>evaluateJavaScript 向 vue 传参</h3><p><code>evaluateJavaScript</code>接收的是一个字符串方法名，传参时需要将json对象的参数转为json字符串，用单引号包裹放到字符串方法中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> funStr = <span class="string">"vueFunctionStr('\(jsonStr)')"</span> <span class="comment">//vueFunctionStr是vue中的方法名，jsonStr是json字符串的传参</span></span><br><span class="line"><span class="keyword">self</span>.webView.evaluateJavaScript(funStr) &#123; (any, error) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="type">XDLog</span>(<span class="string">"调用失败 = \(error.debugDescription)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vue的方法接收数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted () &#123; <span class="comment">// 在window中注册方法</span></span><br><span class="line">  <span class="built_in">window</span>.vueFunctionStr = <span class="keyword">this</span>.vueFunctionStr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vueFunctionStr (jsonStr) &#123;</span><br><span class="line">  <span class="keyword">let</span> jsonDict = <span class="built_in">JSON</span>.parse(jsonStr)</span><br><span class="line">  <span class="built_in">console</span>.log(jsonDict)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="vue-向-WKWebView传参"><a href="#vue-向-WKWebView传参" class="headerlink" title="vue 向 WKWebView传参"></a>vue 向 WKWebView传参</h3><p>h5也可以通过调用原生方法传参，<code>WKWebView</code>需要添加方法监听，<code>vueFunction</code>是要监听的方法名。</p>
<p>在 <code>WKScriptMessageHandler</code>方法中接收传参，<code>message.name</code>是方法名，<code>message.body</code>是传递参数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加监听</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">		<span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line">		<span class="keyword">self</span>.webView.configuration.userContentController.add(<span class="keyword">self</span>, name: <span class="string">"vueFunction"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除监听</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">		<span class="keyword">super</span>.viewWillDisappear(animated)</span><br><span class="line">    <span class="keyword">self</span>.webView.configuration.userContentController.removeScriptMessageHandler(forName: <span class="string">"vueFunction"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WebViewController</span>: <span class="title">WKScriptMessageHandler</span>, <span class="title">WKNavigationDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userContentController</span><span class="params">(<span class="number">_</span> userContentController: WKUserContentController, didReceive message: WKScriptMessage)</span></span> &#123;</span><br><span class="line">        <span class="type">XDLog</span>(<span class="string">"vue调用原生 = \(message.name), \(message.body)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">	  <span class="comment">// 获取h5网页title</span></span><br><span class="line">  	<span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, didFinish navigation: WKNavigation!)</span></span> &#123;</span><br><span class="line">        webView.evaluateJavaScript(<span class="string">"document.title"</span>) &#123; (title, error) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> titleStr = title <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.navigationItem.title = titleStr</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.navigationItem.title = <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在vue中通过<code>window.webkit</code>调用原生方法，传参：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.webkit) &#123;</span><br><span class="line">	<span class="comment">// vueFunction 是在WKWebView中监听的方法名，postMessage后面是要传递的json对象参数</span></span><br><span class="line">  <span class="built_in">window</span>.webkit.messageHandlers.vueFunction.postMessage(&#123;</span><br><span class="line">    data: <span class="number">123</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h2><p>uni-app是一款跨平台框架，可以以一套代码编译成iOS/Android/各种小程序，一套代码多端运行。</p>
<p>uni-app完全是vue的开发方式，API高度类似小程序，相比原生性能和拓展性都是问题。框架本身也存在一些bug，好在官方迭代很快。</p>
<h3 id="通过-url-向-vue-传参-1"><a href="#通过-url-向-vue-传参-1" class="headerlink" title="通过 url 向 vue 传参"></a>通过 url 向 vue 传参</h3><p>uni-app有<code>web-view</code>组件，用来加载网页，可以通过<code>src</code>的URL地址向vue传参：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;web-view src&#x3D;&quot;https:&#x2F;&#x2F;markmiao.com&#x2F;app&#x2F;request?data&#x3D;123&quot;&gt;&lt;&#x2F;web-view&gt;</span><br></pre></td></tr></table></figure>

<p>vue接收参数和上面一样，也是通过<code>this.$route.query.data</code></p>
<h3 id="vue-向-uni-app-传参"><a href="#vue-向-uni-app-传参" class="headerlink" title="vue 向 uni-app 传参"></a>vue 向 uni-app 传参</h3><p>参考文章：<a href="https://ask.dcloud.net.cn/article/35083" target="_blank" rel="noopener">在web-view加载的本地及远程HTML中调用uni的API及网页和vue页面通讯</a></p>
<p>vue 向 uni-app 传参需要引入uni-app提供的sdk，vue中只需要在<code>public/index.html</code>文件中引入即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://js.cdn.aliyun.dcloud.net.cn/dev/uni-app/uni.webview.1.5.1.js?rev=1.0.0"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果要兼容小程序，还需要引入微信js-sdk，如果引入需要在前面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"//res.wx.qq.com/open/js/jweixin-1.4.0.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在vue中调用<code>uni.postMessage</code>方法向uni-app传参：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">uni.postMessage(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    to: <span class="string">'appFunction'</span>, <span class="comment">//方法名</span></span><br><span class="line">    data: &#123; <span class="comment">//传递参数</span></span><br><span class="line">      data: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在uni-app中的 <code>getMessage</code>方法中得到传参：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getMessage: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dataDict = e.detail.data[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"方法名 = "</span> + dataDict.to + <span class="string">"传参 = "</span> + dataDict.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>火星坐标转GPS坐标</title>
    <url>/2020/12/06/map2/</url>
    <content><![CDATA[<p>火星坐标（GCJ02）转GPS坐标（WGS84）没有标准的方法，网上倒是有很多第三方的。最近在做一款产品，要求非常精确的将火星坐标转换成GPS坐标。</p>
<a id="more"></a>

<p>我试过很多种方法，<a href="https://github.com/JackZhouCn/JZLocationConverter-Swift" target="_blank" rel="noopener">JZLocationConverter-Swift</a> 算误差比较小了，有几米的误差。我找到另一种方法：二分法取中心点，逐步逼近。几乎可以算是零误差了，但有个问题。</p>
<h2 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h2><p>先说这个转换方法的逻辑，步骤如下：</p>
<ol>
<li><p>火星坐标 A 转换GPS坐标 A1，对 A 的经纬度（lng，lat）分别 + - 0.5，得到4个值:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">最小经度</span> <span class="attr">minLng:</span> <span class="string">lng</span> <span class="bullet">-</span> <span class="number">0.5</span></span><br><span class="line"><span class="string">最大经度</span> <span class="attr">maxLng:</span> <span class="string">lng</span> <span class="string">+</span> <span class="number">0.5</span></span><br><span class="line"><span class="string">最小纬度</span> <span class="attr">minLat:</span> <span class="string">lat</span> <span class="bullet">-</span> <span class="number">0.5</span></span><br><span class="line"><span class="string">最大纬度</span> <span class="attr">maxLat:</span> <span class="string">lat</span> <span class="string">+</span> <span class="number">0.5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以组成4个火星坐标：*<em>注：方位只在东北半球适用，火星坐标也只中国用 : ( *</em></p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">左下角：a (<span class="keyword">min</span>Lng, <span class="keyword">min</span>Lat)</span><br><span class="line">右下角：b (<span class="keyword">max</span>Lng, <span class="keyword">min</span>Lat)</span><br><span class="line">左上角：c (<span class="keyword">min</span>Lng, <span class="keyword">max</span>Lat)</span><br><span class="line">右上角：d (<span class="keyword">max</span>Lng, <span class="keyword">max</span>Lat)</span><br></pre></td></tr></table></figure>
</li>
<li><p>这4个坐标点得到一个正方形区域 M，A 是中心点，它们都属于火星坐标系</p>
</li>
<li><p><strong>重点：将M区域 a，b，c，d 4个坐标看作是GPS坐标！获取中心点坐标 P （P是GPS坐标，A是火星坐标，数值相等，位置不同）</strong></p>
</li>
<li><p>计算 P 与 A 的经纬度差，坐标系不同不能直接比较。将 P 转为火星坐标P1（<strong>有官方转换方法</strong>）</p>
</li>
<li><p>计算 P1 与 A 的经纬度相差之和 ( | P1lng - Alng | + | P1lat - Alat | ) &lt; 0.00001，则认为P1和A重叠，那 P 就是 A 对应的GPS坐标。</p>
</li>
<li><p>如果 &gt; 0.00001，二分法缩小区域，将a，b，c，d 4点转为火星坐标 a1，b1，c1，d1，以P1为准，计算A在P1的什么方位。看A在 P1-a1，P1-b1，P1-c1，P1-d1，哪个之间。</p>
</li>
<li><p>用二分法排除以外区域，比如：A在P1的左下角，就是A在P1-a1之间，得到新的区域：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">左下角：a（<span class="keyword">min</span>Lng, <span class="keyword">min</span>Lat)</span><br><span class="line">右下角：b ((<span class="keyword">min</span>Lng + <span class="keyword">max</span>Lng) / <span class="number">2</span>, <span class="keyword">min</span>Lat)</span><br><span class="line">左上角：c (<span class="keyword">min</span>Lng, (<span class="keyword">min</span>Lat + <span class="keyword">max</span>Lat) / <span class="number">2</span>)</span><br><span class="line">右上角：d ((<span class="keyword">min</span>Lng + <span class="keyword">max</span>Lng) / <span class="number">2</span>, (<span class="keyword">min</span>Lat + <span class="keyword">max</span>Lat) / <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>6 - 8 步骤循环30次，一般情况下能得到差距 &lt; 0.00001 的GPS坐标，即时达不到标准，结果也很接近。</p>
</li>
</ol>
<p>这个转换一句话解释：<strong>用已知的GPS坐标，逐步逼近要转换的火星坐标</strong></p>
<h2 id="算法漏洞"><a href="#算法漏洞" class="headerlink" title="算法漏洞"></a>算法漏洞</h2><p>在测试过程中，有一个坐标点出现了问题：上海虹桥机场2号航站楼 (latitude : 31.194248175984768  longitude : 121.32863948433301)</p>
<p>下面是算法输出的经纬度相差之和：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">左上，<span class="number">0.49360417451567073</span></span><br><span class="line">右下，<span class="number">0.24358081099306617</span></span><br><span class="line">右下，<span class="number">0.11855877737957243</span></span><br><span class="line">右下，<span class="number">0.05603884882789245</span></span><br><span class="line">右下，<span class="number">0.024777349920977798</span></span><br><span class="line">右下，<span class="number">0.00914639780950921</span></span><br><span class="line">右下，<span class="number">0.0025836297689565413</span></span><br><span class="line">左下，<span class="number">0.0013319084599991982</span></span><br><span class="line">右上，<span class="number">0.001330858958493053</span></span><br><span class="line">右上，<span class="number">0.001604743230569028</span></span><br></pre></td></tr></table></figure>

<p>坐标点在循环第10次，四角坐标点从GPS转为火星坐标系时，逃出了限定区域，这时已没法继续二分法逼近了，只能返回差距<code>0.001604743230569028</code>的坐标转换。</p>
<p>问题成因：GPS坐标在转换为火星坐标系时，四个点并非同步平移，正方形区域的GPS坐标，转为火星坐标时，就成了不规则的四边形，有时会把坐标点闪到外面。</p>
<p>正在想办法解决这个问题……</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 火星坐标 -&gt; GPS</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transformFromGCJToWGS</span><span class="params">(p:CLLocationCoordinate2D)</span></span> -&gt; <span class="type">CLLocationCoordinate2D</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> threshold = <span class="number">0.00001</span>;</span><br><span class="line">    <span class="keyword">var</span> minLat = p.latitude - <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">var</span> maxLat = p.latitude + <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">var</span> minLng = p.longitude - <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">var</span> maxLng = p.longitude + <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">var</span> delta = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">var</span> maxIteration = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> leftBottom = <span class="type">AMapCoordinateConvert</span>(<span class="type">CLLocationCoordinate2D</span>(latitude: minLat, longitude: minLng), .<span class="type">GPS</span>)</span><br><span class="line">        <span class="keyword">let</span> rightBottom = <span class="type">AMapCoordinateConvert</span>(<span class="type">CLLocationCoordinate2D</span>(latitude: minLat, longitude: maxLng), .<span class="type">GPS</span>)</span><br><span class="line">        <span class="keyword">let</span> leftUp = <span class="type">AMapCoordinateConvert</span>(<span class="type">CLLocationCoordinate2D</span>(latitude: maxLat, longitude: minLng), .<span class="type">GPS</span>)</span><br><span class="line">        <span class="keyword">let</span> rightUp = <span class="type">AMapCoordinateConvert</span>(<span class="type">CLLocationCoordinate2D</span>(latitude: maxLat, longitude: maxLng), .<span class="type">GPS</span>)</span><br><span class="line">        <span class="keyword">let</span> midPoint = <span class="type">AMapCoordinateConvert</span>(<span class="type">CLLocationCoordinate2D</span>(latitude : ((minLat + maxLat) / <span class="number">2</span>),longitude : ((minLng + maxLng) / <span class="number">2</span>)), .<span class="type">GPS</span>)</span><br><span class="line">        delta = fabs(midPoint.latitude - p.latitude) + fabs(midPoint.longitude - p.longitude);</span><br><span class="line">        maxIteration = maxIteration - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(maxIteration &lt;= <span class="number">0</span> || delta &lt;= threshold) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">CLLocationCoordinate2D</span>(latitude: (minLat + maxLat) / <span class="number">2</span>, longitude: (minLng + maxLng) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isContains(point: p, p1: leftBottom, p2: midPoint)) &#123;</span><br><span class="line">            maxLat = (minLat + maxLat) / <span class="number">2</span>;</span><br><span class="line">            maxLng = (minLng + maxLng) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isContains(point: p, p1: rightBottom, p2: midPoint)) &#123;</span><br><span class="line">            maxLat = (minLat + maxLat) / <span class="number">2</span>;</span><br><span class="line">            minLng = (minLng + maxLng) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isContains(point: p, p1: leftUp, p2: midPoint)) &#123;</span><br><span class="line">            minLat = (minLat + maxLat) / <span class="number">2</span>;</span><br><span class="line">            maxLng = (minLng + maxLng) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isContains(point: p, p1: rightUp, p2: midPoint))&#123;</span><br><span class="line">            minLat = (minLat + maxLat) / <span class="number">2</span>;</span><br><span class="line">            minLng = (minLng + maxLng) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">CLLocationCoordinate2D</span>(latitude: (minLat + maxLat) / <span class="number">2</span>, longitude: (minLng + maxLng) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isContains</span><span class="params">(point:CLLocationCoordinate2D , p1:CLLocationCoordinate2D, p2:CLLocationCoordinate2D)</span></span>-&gt;<span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (point.latitude &gt;= <span class="built_in">min</span>(p1.latitude, p2.latitude) &amp;&amp;</span><br><span class="line">                point.latitude &lt;= <span class="built_in">max</span>(p1.latitude, p2.latitude)) &amp;&amp;</span><br><span class="line">        (point.longitude &gt;= <span class="built_in">min</span>(p1.longitude,p2.longitude) &amp;&amp;</span><br><span class="line">            point.longitude &lt;= <span class="built_in">max</span>(p1.longitude, p2.longitude));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考链接：<a href="https://cloud.tencent.com/developer/article/1524369" target="_blank" rel="noopener">iOS地图开发2-坐标系的转换(swift)</a> </p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title>framework合并问题</title>
    <url>/2020/11/29/framework2/</url>
    <content><![CDATA[<p>上一篇关于静态库的文章：<a href="https://markmiao.com/2016/11/14/%E5%88%B6%E4%BD%9C-a%E5%92%8C-framework%E9%9D%99%E6%80%81%E5%BA%93/">制作.a和.framework静态库</a>。文章很老了，有许多问题，最近用Xcode12打包framework，遇到了一些问题，记录一下。</p>
<a id="more"></a>

<p>打包静态库常用脚本配置的方式，在Run Script添加脚本。编译之后，真机和模拟器的framework会完成合并。但Xcode升级之后脚本失效了，则分别打包，手动完成合并。</p>
<p>在编译时，要选中包的TARGET，分别在真机和模拟器下完成编译。在Products里面Show in Finder便能看到完成打包的framework文件。</p>
<p>xxx.framework文件夹中xxx文件，没有后缀名且体积最大，这就是静态库文件。</p>
<p>查看静态文件支持架构：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lipo -info 静态库xxx文件路径</span><br></pre></td></tr></table></figure>

<p>真机：arm64 armv7， 模拟器：arm64 x86_64 i386 </p>
<p>静态文件合并命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lipo -create 真机xxx文件路径 模拟器xxx文件路径 -output 新文件路径</span><br></pre></td></tr></table></figure>

<p>Xcode升级12之后，报错了：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">have the same architectures (<span class="name">arm64</span>) and can't be in the same fat output file</span><br></pre></td></tr></table></figure>

<p>因为两个静态文件都支持<code>arm64</code>，无法合并。</p>
<p>可以移除模拟器静态文件的<code>arm64</code>架构：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lipo 模拟器静态文件xxx -remove arm64 -output 移除后模拟器静态文件xxx名</span><br></pre></td></tr></table></figure>

<p>移除之后，重新查看支持架构，只有<code>armv7</code>，重新合并就没有问题了。</p>
<p>网上对于该问题的一些解决办法：</p>
<p><a href="https://stackoverflow.com/questions/64022291/ios-14-lipo-error-while-creating-library-for-both-device-and-simulator" target="_blank" rel="noopener">iOS 14, lipo error while creating library for both device and simulator</a></p>
<p><a href="https://blog.csdn.net/huawt520/article/details/109305833" target="_blank" rel="noopener">XCode12 模拟器静态库支持arm64架构引发的系列问题</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>静态库</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中的地图与坐标</title>
    <url>/2020/11/28/map/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>地图：系统地图（MKMapView），百度地图（BMKMapView），高德地图（MAMapView）</li>
<li>坐标系：GPS坐标系（WGS84），火星坐标系（GCJ02），百度坐标系（BD09）</li>
<li>定位：系统定位（CLLocationManager），百度定位SDK（BMKLocationManager），高德定位SDK（AMapLocationManager）</li>
</ul>
<a id="more"></a>

<h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><p>苹果系统地图在海外全球通用，为GPS坐标系。在国内使用的是高德数据，所以返回的经纬度是火星坐标系的。国内测试，超出国境线就无法获取经纬度数据。</p>
<p>百度地图的坐标系是自己的BD09，无法切换为其他坐标系。</p>
<p>高德地图坐标系是火星坐标系，无法切换为其他坐标系。</p>
<p><strong>地图的坐标系无法更改！！！</strong></p>
<h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>GPS坐标系是全球坐标系，国际标准。火星坐标系是中国的标准，是在GPS坐标的基础上做了一层加密。法律规定：在中国，地图产品不允许直接使用GPS坐标，至少使用一层加密的火星坐标系（GCJ02）。百度坐标系（BD09）则是在GCJ02的基础上又做了一层转换。</p>
<p>GPS坐标转为火星坐标或百度坐标，以及火星坐标和百度坐标相互转换，都有官方提供的方法：</p>
<p><a href="https://lbs.amap.com/api/ios-sdk/guide/computing-equipment/amap-calculate-tool/?sug_index=3" target="_blank" rel="noopener">高德提供的坐标转换</a></p>
<p><a href="http://lbs.baidu.com/index.php?title=iossdk/guide/tool/coordinate" target="_blank" rel="noopener">百度提供的坐标转换</a></p>
<p>但是！火星坐标和百度坐标不允许转换GPS坐标，至少没有官方提供转换方法。</p>
<p>网上有很多开源的转换工具，亲测了几种：</p>
<p><a href="https://github.com/JackZhouCn/JZLocationConverter-Swift" target="_blank" rel="noopener">JZLocationConverter-Swift</a> ： 在转换WGS84时会有误差，官方有说明</p>
<p><a href="https://cloud.tencent.com/developer/article/1524369" target="_blank" rel="noopener">iOS地图开发2-坐标系的转换(swift)</a> ： 里面的一些参数可做优化，亲测 GCJ02 -&gt; WGS84 非常精准。</p>
<p>虽然法律规定国内不能使用GPS坐标系，这仅限于地图产品。<strong>定位是可以直接获取GPS坐标的！</strong></p>
<p>如果定位数据要放到地图中使用，则要保证统一坐标系，不然会出现偏差。</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="系统定位"><a href="#系统定位" class="headerlink" title="系统定位"></a>系统定位</h3><p>系统定位返回的经纬度为GPS坐标。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> locationM = <span class="type">CLLocationManager</span>()</span><br><span class="line">locationM.delegate = <span class="keyword">self</span></span><br><span class="line">locationM.requestWhenInUseAuthorization() <span class="comment">//使用app时定位</span></span><br><span class="line">locationM.startUpdatingLocation() <span class="comment">//开始定位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 定位的代理方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">locationManager</span><span class="params">(<span class="number">_</span> manager: CLLocationManager, didUpdateLocations locations: [CLLocation])</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> locations.last != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"经纬度 = \(locations.last!.coordinate)"</span>)</span><br><span class="line">        manager.stopUpdatingLocation() <span class="comment">//停止定位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="百度定位SDK"><a href="#百度定位SDK" class="headerlink" title="百度定位SDK"></a>百度定位SDK</h3><p>百度定位SDK获取的经纬度默认为火星坐标系（GCJ02），百度地图中是百度坐标系（BD09），如果要定位的坐标放到地图里用，则需要统一坐标系，指定坐标系为<code>.BMK09LL</code>。</p>
<p>也可以获取其他坐标系中的定位坐标：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> locationM = <span class="type">BMKLocationManager</span>()</span><br><span class="line">locationM.delegate = <span class="keyword">self</span></span><br><span class="line">locationM.coordinateType = .<span class="type">BMK09LL</span> <span class="comment">//指定坐标系</span></span><br><span class="line">locationM.startUpdatingLocation()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bmkLocationManager</span><span class="params">(<span class="number">_</span> manager: BMKLocationManager, didUpdate location: BMKLocation?, orError error: Error?)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> coordinate = location?.location?.coordinate &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"经纬度 = \(coordinate)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高德定位SDK"><a href="#高德定位SDK" class="headerlink" title="高德定位SDK"></a>高德定位SDK</h3><p>高德的定位和地图SDK只使用了一种坐标系：火星坐标系（GCJ02）</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> locationM = <span class="type">AMapLocationManager</span>()</span><br><span class="line">locationM.delegate = <span class="keyword">self</span></span><br><span class="line">locationM.locatingWithReGeocode = <span class="literal">true</span> <span class="comment">//返回逆地理信息</span></span><br><span class="line">locationM.startUpdatingLocation() <span class="comment">//开始定位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 代理方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">amapLocationManager</span><span class="params">(<span class="number">_</span> manager: AMapLocationManager!, didUpdate location: CLLocation!, reGeocode: AMapLocationReGeocode!)</span></span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"经纬度 = \(location.coordinate)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<p><a href="https://www.jianshu.com/p/3cd701299cef" target="_blank" rel="noopener">iOS 火星坐标/地球坐标/百度坐标整理及解决方案汇总？如何转火星坐标？</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title>mRemind - 提醒你每一件小事</title>
    <url>/2020/05/08/mremind/</url>
    <content><![CDATA[<p><a href="https://apps.apple.com/cn/app/mremind-提醒你每一件小事/id1449698904?mt=12" target="_blank" rel="noopener"><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/mremindicon.png" alt="mRemind"></a></p>
<p>mRemind 是一款专为 macOS 设计的待办提醒应用，操作简单而功能强大。</p>
<a id="more"></a>

<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://apps.apple.com/cn/app/mremind-提醒你每一件小事/id1449698904?mt=12" target="_blank" rel="noopener"><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/badge-download-on-the-mac-app-store_s.png" alt=""></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当我们专注于工作或某项任务时，往往会忽略计划好的其他事情。当想起时，已经错过了最佳时间。</p>
<p>mRemind 是为解决这类烦恼而生的，它能帮你记录待办事项。当你把任务交给 mRemind 记录后，你便可以专注于当下工作，时间到了，mRemind 会提醒你的待办事项该做了。</p>
<p>mRemind，让你保持专注不遗漏。</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/mremindappstore.png" alt="mRemind"></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>在状态栏中一键添加待办提醒</li>
<li>查看添加的所有待办提醒</li>
<li>时间到了，通知栏提醒待办</li>
<li>在消息通知上可一键操作完成</li>
</ul>
<h2 id="mRemind基础功能"><a href="#mRemind基础功能" class="headerlink" title="mRemind基础功能"></a>mRemind基础功能</h2><ul>
<li><p>添加不超过3条的mRemind提醒</p>
</li>
<li><p>5/10/20/30分钟的倒计时提醒</p>
</li>
<li><p>全部提醒的完成/删除操作</p>
</li>
<li><p>其他 mRemind 提供的服务</p>
</li>
</ul>
<h2 id="mRemind高级版"><a href="#mRemind高级版" class="headerlink" title="mRemind高级版"></a>mRemind高级版</h2><ul>
<li><p>添加多条mRemind提醒</p>
</li>
<li><p>日期选择功能，可随意指定未来时间</p>
</li>
<li><p>自定义时间功能，可设置任意倒计时</p>
</li>
</ul>
<h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><p>订阅 mRemind高级版 解锁全部功能，您可自由选择月度订阅或年度订阅：</p>
<ul>
<li><p>按月订阅：¥6.00/月</p>
</li>
<li><p>按年订阅：¥60.00/年（推荐，约节省17%）</p>
</li>
</ul>
<p>确认订阅后，将向您的Apple ID账户收款。除非您在当前计费周期结束前至少24小时取消订单，否则项目会自动续订，您的账户将在当前计费周期结束前24小时内收取续订费用。当前订阅被激活后不可取消。购买后，您可在App Store的账户设置中管理您的订阅。</p>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>我们欢迎您对 mRemind 提出意见或建议，请邮件联系 <a href="mailto:i@markmiao.com">i@markmiao.com</a> ，我们会认真对待每一个反馈，将 mRemind 做的更好。</p>
<hr>
<p>隐私政策：<a href="https://markmiao.com/2018/12/25/yinsizhengce/">https://markmiao.com/2018/12/25/yinsizhengce/</a></p>
<p>使用条款：<a href="https://markmiao.com/2018/12/26/shiyongtiaokuan/">https://markmiao.com/2018/12/26/shiyongtiaokuan/</a></p>
]]></content>
      <categories>
        <category>macOS开发</category>
      </categories>
      <tags>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS开发笔记(2)</title>
    <url>/2020/04/29/macosdevelnote2/</url>
    <content><![CDATA[<h2 id="NSToolbar"><a href="#NSToolbar" class="headerlink" title="NSToolbar"></a>NSToolbar</h2><p>常用<code>NSToolbar</code>开发偏好设置界面，在xib中可以直接拖<code>NSToolbar</code>到<code>Window</code>中，可以自定义图片文字。</p>
<a id="more"></a>

<p>勾选<code>Behavior</code>中的<code>Selectable</code>，<code>NSToolbarItem</code>是可选中样式的。</p>
<p>设置某个<code>NSToolbarItem</code>默认选中，需要先设置默认选中的<code>NSToolbarItem</code>的<code>Identifier</code>，使用下面代码完成默认选中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">toolbar.selectedItemIdentifier = <span class="type">NSToolbarItem</span>.<span class="type">Identifier</span>(rawValue: <span class="string">"id"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Window按钮"><a href="#Window按钮" class="headerlink" title="Window按钮"></a>Window按钮</h2><p>控制window左上角关闭、最小化、最大化按钮的是否可用，以及显示隐藏。</p>
<p>可以在xib中勾选<code>Controls</code>中的<code>Close</code>、<code>Minimize</code>、<code>Resize</code>，控制按钮是否可用。或者使用代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.window?.standardWindowButton(.closeButton)?.isEnabled = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>使用代码可以隐藏按钮：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.window?.standardWindowButton(.miniaturizeButton)?.isHidden = <span class="literal">true</span></span><br><span class="line"><span class="keyword">self</span>.window?.standardWindowButton(.zoomButton)?.isHidden = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="NSButton"><a href="#NSButton" class="headerlink" title="NSButton"></a>NSButton</h2><p>设置按钮为蓝色背景，需要设置按钮的<code>Key Equivalent</code>为回车键</p>
<h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>macOS中<code>Label</code>继承自<code>NSTextField</code>，有两种：<code>Label</code> 和<code>Wrapping Label</code></p>
<p><code>Wrapping Label</code>为多行Label，无需设置Line Break为<code>Character Wrap</code></p>
<p>使用<code>Label</code> 设置Line Break也无法折行显示。</p>
<p>当<code>Label</code>仅作为文字显示时，鼠标移上不变光标显示，需要设置Action为<code>Sent On End Editing</code></p>
<h2 id="NSTableCellView"><a href="#NSTableCellView" class="headerlink" title="NSTableCellView"></a>NSTableCellView</h2><p>移除默认的Cell点击变蓝，设置NSTableView的<code>selectionHighlightStyle</code> :</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.selectionHighlightStyle = .<span class="keyword">none</span></span><br></pre></td></tr></table></figure>

<p>NSTableCellView根据存放的Label内容自适应高度，OSX 10.13以后，在xib中设置正确的约束，设置Row自适应高度即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.usesAutomaticRowHeights = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>无需指定默认高度<code>rowHeight</code>，亦无需实现row高度的代理方法<code>func tableView(_ tableView: NSTableView, heightOfRow row: Int) -&gt; CGFloat</code></p>
<p><a href="https://www.itranslater.com/qa/details/2325926279662535680" target="_blank" rel="noopener">基于视图的NSTableView，其行具有动态高度</a></p>
<h2 id="NSTextField"><a href="#NSTextField" class="headerlink" title="NSTextField"></a>NSTextField</h2><p>限制输入框<code>NSTextField</code>的输入内容，仅允许输入数字，需要自定义<code>Formatter</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Cocoa</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnlyIntegerValueFormatter</span>: <span class="title">NumberFormatter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">isPartialStringValid</span><span class="params">(<span class="number">_</span> partialString: String, newEditingString newString: AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?, errorDescription error: AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> partialString.isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 禁止输入非数字 &amp;&amp; 首位不能为0 &amp;&amp; 最多输入3位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>(partialString) != <span class="literal">nil</span> &amp;&amp; <span class="type">Int</span>(partialString)! &gt; <span class="number">0</span> &amp;&amp; partialString.<span class="built_in">count</span> &lt; <span class="number">4</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>macOS开发</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter笔记5-初探Widget布局</title>
    <url>/2020/03/19/flutter5/</url>
    <content><![CDATA[<p>Flutter核心思想：用Widget构建UI界面、万物皆Widget。</p>
<p>Flutter渲染思想：Widget描述UI，当Widget的状态改变，会重新构建UI。flutter会比对前后两者的差异，确定底层渲染树的最小更改。</p>
<a id="more"></a>

<h2 id="初探Widget布局"><a href="#初探Widget布局" class="headerlink" title="初探Widget布局"></a>初探Widget布局</h2><ul>
<li>Text：带样式的文本</li>
<li>Row和Column：水平/垂直布局</li>
<li>Container：矩形控件</li>
</ul>
<p>使用这些常用的Widget自定义一个导航栏样式：</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/flutterdemo20200319100137.png" alt="示例"></p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>对整个页面进行分解，分为导航栏和展示内容两部分，这两者垂直排布，所以使用<code>Column</code>，导航栏内控件水平排布，所以用<code>Row</code>。</p>
<p>先自定义导航栏，导航栏分四部分：矩形背景、标题、两个icon。矩形背景可以用<code>Container</code>，标题用<code>Text</code>, 标题与icon的布局用<code>Row</code>实现。自定义导航栏，标题和icon要求外部传值。</p>
<p>因为内容不变，导航栏使用<code>StatelessWidget</code>，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAppBar</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  MyAppBar(&#123;<span class="keyword">this</span>.titleStr, <span class="keyword">this</span>.leftIcon, <span class="keyword">this</span>.rightIcon&#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> titleStr;<span class="comment">//标题</span></span><br><span class="line">  <span class="keyword">final</span> IconData leftIcon;<span class="comment">//左边的icon</span></span><br><span class="line">  <span class="keyword">final</span> IconData rightIcon;<span class="comment">//右边的icon</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(<span class="comment">//导航栏矩形背景</span></span><br><span class="line">      height: <span class="number">100</span>,</span><br><span class="line">      padding: EdgeInsets.only(top:<span class="number">30</span>),</span><br><span class="line">      color: Colors.red,</span><br><span class="line">      child: Row(<span class="comment">//采用横向的Row布局</span></span><br><span class="line">        children: &lt;Widget&gt; [</span><br><span class="line">          IconButton(</span><br><span class="line">            icon: Icon(leftIcon, color: Colors.white,),</span><br><span class="line">            onPressed: <span class="keyword">null</span>,<span class="comment">//点击事件</span></span><br><span class="line">          ),</span><br><span class="line">          Expanded(<span class="comment">//标题填充展示</span></span><br><span class="line">            child: Text(</span><br><span class="line">              titleStr,</span><br><span class="line">              style: Theme.of(context).primaryTextTheme.title,<span class="comment">//标题的style</span></span><br><span class="line">              textAlign: TextAlign.center,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          IconButton(</span><br><span class="line">            icon: Icon(rightIcon, color: Colors.white,),</span><br><span class="line">            onPressed: <span class="keyword">null</span>,</span><br><span class="line">          ),</span><br><span class="line">        ]</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>展示内容部分比较简单，文本填充，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContent</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  MyContent(&#123;<span class="keyword">this</span>.contentStr&#125;);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> contentStr;<span class="comment">//显示内容外部传参</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Expanded(<span class="comment">//填充显示</span></span><br><span class="line">      child: Center(</span><br><span class="line">        child: Text(</span><br><span class="line">          contentStr,</span><br><span class="line">          style: TextStyle(</span><br><span class="line">            color: Colors.red,</span><br><span class="line">            fontSize: <span class="number">50</span>,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两部分组合在一个Widget中，使用<code>Column</code>布局，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStateless</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Material(</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          MyAppBar(titleStr: <span class="string">'Hello World'</span>, leftIcon: Icons.menu, rightIcon: Icons.track_changes),<span class="comment">//导航栏，传递参数</span></span><br><span class="line">          MyContent(contentStr: <span class="string">'Hello Flutter'</span>),<span class="comment">//显示内容部分，传递参数</span></span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>demo的完整代码见工程中的 <a href="https://github.com/mxdios/flutter-demo" target="_blank" rel="noopener">flutter_widgets</a></strong></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter笔记4-UI框架</title>
    <url>/2020/03/18/flutter4/</url>
    <content><![CDATA[<p>flutter是跨平台的UI框架，非UI层面的任务，通过插件机制与iOS或Android通讯。</p>
<a id="more"></a>

<h2 id="UIView-与-Widget"><a href="#UIView-与-Widget" class="headerlink" title="UIView 与 Widget"></a>UIView 与 Widget</h2><p>UIView是iOS中最常用的视图控件，Widget并不完全等同于UIView，它可以被称为“声明和构造 UI 的方法”。UIView是可变的，直接对UIView修改并不会导致重新创建实例。Widget不可变，只能通过修改Widget的state来使其改变。</p>
<p>两种Widget：有状态的 <code>StatefulWidget</code> 和无状态的<code>StatelessWidget</code>， <code>StatefulWidget</code>有一个<code>State</code>对象，用来存储状态。</p>
<p>示例：Text，Text继承自无状态Widget：<code>class Text extends StatelessWidget</code>，只能渲染初始化时的内容。想变更Text内容，需要放到<code>StatefulWidget</code>中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangedText</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;<span class="comment">//有状态的StatefulWidget</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ChangedTextState createState() =&gt; _ChangedTextState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ChangedTextState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ChangedText</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> titleText = <span class="string">'hello world'</span>;<span class="comment">//初始化</span></span><br><span class="line">  <span class="keyword">void</span> _textBtnClik() &#123;  </span><br><span class="line">    setState(() &#123;</span><br><span class="line">      titleText = <span class="string">'hello flutter'</span>;<span class="comment">//修改变量</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Widget _changedTextView() &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Column (</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(titleText),<span class="comment">//Text赋值变量</span></span><br><span class="line">          FloatingActionButton(</span><br><span class="line">            onPressed: _textBtnClik, <span class="comment">//点击按钮修改变量</span></span><br><span class="line">            child: Icon(Icons.add_circle),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    ); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'home'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: _changedTextView()</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改变量要在<code>setState()</code>方法中修改，会为State对象触发<code>build()</code>方法，会让UI更新。如果不在该方法中，直接更改变量值，可更改变量，UI不会更新。</p>
<p><em>VS Code支持代码块，输入state时能快速创建自定义StatefulWidget</em></p>
<h2 id="布局约束"><a href="#布局约束" class="headerlink" title="布局约束"></a>布局约束</h2><p>iOS中有storybody和xib布局，直接对视图设置约束，或者用代码设置约束，来适配屏幕。在flutter中也可以通过代码设置约束。</p>
<p>比如自定义按钮可以添加padding：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">  color: Colors.blue,</span><br><span class="line">  padding: EdgeInsets.only(top:<span class="number">10</span>,bottom: <span class="number">10</span>, left: <span class="number">60</span>, right: <span class="number">60</span>),</span><br><span class="line">  child: Text(<span class="string">'Btn'</span>),</span><br><span class="line">  onPressed: _textBtnClik, </span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<h2 id="添加移除组件"><a href="#添加移除组件" class="headerlink" title="添加移除组件"></a>添加移除组件</h2><p>在iOS原生开发中，可以使用 <code>addSubview()</code>和<code>removeFromSuperview()</code> 添加移除控件，flutter中没有这类方法。flutter的视图添加移除可以动态解决，在Widget中动态添加视图，未添加上的便是移除了。Widget不可变，更改State后会重绘一个Widget代替原来的Widget，所以动态添加便完成了添加移除组件操作。</p>
<p>示例代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ChangedTextState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ChangedText</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">String</span> text = <span class="string">'hello wrold'</span>;</span><br><span class="line">  <span class="built_in">bool</span> textBool = <span class="keyword">true</span>;</span><br><span class="line">  _textBtnClik() &#123;  </span><br><span class="line">    setState(() &#123;</span><br><span class="line">      index ++;</span><br><span class="line">      textBool = !textBool;<span class="comment">//bool值控制添加组件</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  _viewShow() &#123;<span class="comment">//返回不同的组件</span></span><br><span class="line">    <span class="keyword">if</span> (textBool) &#123;</span><br><span class="line">      <span class="keyword">return</span> Text(text);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Text(<span class="string">'<span class="subst">$index</span>'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Widget _changedTextView() &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: </span><br><span class="line">      Column (</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          _viewShow(),<span class="comment">//添加组件</span></span><br><span class="line">          FlatButton(</span><br><span class="line">            color: Colors.blue,</span><br><span class="line">            padding: EdgeInsets.only(top:<span class="number">10</span>,bottom: <span class="number">10</span>, left: <span class="number">60</span>, right: <span class="number">60</span>),</span><br><span class="line">            child: Text(<span class="string">'Btn'</span>),</span><br><span class="line">            onPressed: _textBtnClik, <span class="comment">//按钮控制bool值</span></span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    ); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="声明式UI"><a href="#声明式UI" class="headerlink" title="声明式UI"></a>声明式UI</h2><p>通过上面的组件添加移除可以看出flutter的UI操作和原生iOS的区别，原生iOS对UI操作，是对UI组件直接进行命令操作，比如：执行<code>addSubview()</code>和<code>removeFromSuperview()</code> 添加移除UI。</p>
<p>在flutter中Widget是不可变的，只有调用<code>setState()</code>方法触发Widget重建，这时是构造了一个新的Widget实例。</p>
<blockquote>
<p>框架使用 RenderObjects 管理传统 UI 对象的职责（比如维护布局的状态）。 RenderObjects 在帧之间保持不变， Flutter 的轻量级 widget 通知框架在状态之间修改 RenderObjects， Flutter 框架则处理其余部分。</p>
</blockquote>
<p>这就是flutter中的声明式UI</p>
<p><strong>demo的完整代码见工程中的 <a href="https://github.com/mxdios/flutter-demo" target="_blank" rel="noopener">flutter_ios</a></strong></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter笔记3-收藏交互</title>
    <url>/2020/03/12/flutter3/</url>
    <content><![CDATA[<p>demo的功能如下：对词组列表加收藏功能，跳转到收藏夹页面，更改整个APP的主题。</p>
<ul>
<li>添加交互</li>
<li>页面跳转</li>
<li>更改主题</li>
</ul>
<a id="more"></a>

<h2 id="添加收藏图标"><a href="#添加收藏图标" class="headerlink" title="添加收藏图标"></a>添加收藏图标</h2><p>所有动态功能的实现还是在 <code>State</code> 中去做，找到 <code>ListTile</code>在后面增加收藏图标，类似iOS中UITableViewCell中的accessoryView，但添加方法不一样。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget _cellView(WordPair name) &#123;</span><br><span class="line">  <span class="keyword">return</span> ListTile(</span><br><span class="line">    title: Text(</span><br><span class="line">      name.asPascalCase</span><br><span class="line">    ),</span><br><span class="line">    trailing: Icon( <span class="comment">//在trailing上添加Icon，Icons的图标很多，favorite是个心形</span></span><br><span class="line">      Icons.favorite,</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样便为每一个Tile增加了收藏图标，收藏图标有两种状态——已收藏、未收藏。需要有个bool值去控制，要得到这个bool值就要对每个Tile的title判断，判断这个title是否被收藏。</p>
<p>这时需要有个数组专门存放已收藏的词组：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">Set</span>&lt;WordPair&gt;_likeNameArray = <span class="built_in">Set</span>&lt;WordPair&gt;();</span><br></pre></td></tr></table></figure>

<p>这是存放收藏词组的数组，存放的类型是 `WordPair，用Set而不用List的原因是：Set中不允许有重复元素。更适合收藏操作。</p>
<p><code>_likeNameArray</code> 中存放了收藏词组，在创建<code>ListTile</code>的方法中将每个<code>WordPair</code>值跟这个数组比对即可得到bool值。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">bool</span> isLike = _likeNameArray.contains(name);</span><br></pre></td></tr></table></figure>

<p>有了bool值便可修改收藏图标的状态：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">trailing: Icon(</span><br><span class="line">    isLike ? Icons.favorite : Icons.favorite_border, <span class="comment">//支持三目元算符，赋值不同收藏图标</span></span><br><span class="line">		color: isLike ? Colors.red : <span class="keyword">null</span>, <span class="comment">//为已收藏的心形设置红色，未收藏的不设置颜色</span></span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<h2 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h2><p>有了收藏图标，需要增加收藏的点击交互。也是在创建<code>ListTile</code>的方法中为其添加点击事件<code>onTap</code>，在点击事件中操作收藏数据：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onTap: () &#123;<span class="comment">//点击事件</span></span><br><span class="line">  setState(() &#123;<span class="comment">//setState()方法</span></span><br><span class="line">    <span class="keyword">if</span> (isLike) &#123;</span><br><span class="line">      _likeNameArray.remove(name);<span class="comment">//移除收藏</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _likeNameArray.add(name);<span class="comment">//收藏</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>flutter是响应式框架，<code>setState()</code>方法会为State对象触发<code>build()</code>方法，会让UI更新。点击的时候还有水波特效，是Material Design自带的。</p>
<p>至此，便能完成点击收藏和取消收藏的操作了。</p>
<h2 id="导航栏按钮"><a href="#导航栏按钮" class="headerlink" title="导航栏按钮"></a>导航栏按钮</h2><p>在导航栏添加一个收藏夹按钮，点击收藏夹按钮跳转收藏夹页面。</p>
<p>在 <code>appBar</code> 中添加收藏夹按钮：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Scaffold(</span><br><span class="line">    appBar: AppBar(</span><br><span class="line">      title: Text(<span class="string">'home'</span>),</span><br><span class="line">      actions: &lt;Widget&gt;[<span class="comment">//actions需要一个Widget组</span></span><br><span class="line">        <span class="keyword">new</span> IconButton(icon: Icon(Icons.list), onPressed: _pushVc),</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">    body: _listView(),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些widget需要单个widget属性，<code>actions</code>需要一个widget组，可以添加多个IconButton，会把title挤到一边。类似iOS中的<code>rightBarButtonItems</code>。</p>
<p>数组中是<code>IconButton</code>，设置了Icon，和点击事件<code>_pushVc</code>，这个方法中完成页面跳转操作。</p>
<h2 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h2><p>页面跳转在iOS中是控制器跳转，常用push，页面称为控制器。在flutter中页面称为路由<code>route</code>，从主路由切换到新路由，就是页面跳转。</p>
<p>flutter中也是push和pop控制路由跳转，将路由push到导航器的栈中就是跳转新页面，将路由pop出导航器，就会返回上一个路由。</p>
<p>在<code>_pushVc</code>方法中创建路由，并将其push到导航器的栈中。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _pushVc() &#123;</span><br><span class="line">    Navigator.push(context, route);<span class="comment">//路由入栈的push方法，route处创建一个新路由</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建路由"><a href="#创建路由" class="headerlink" title="创建路由"></a>创建路由</h2><p>在 <code>MaterialPageRoute</code> 中创建要显示的收藏夹列表：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.push(context, </span><br><span class="line">  <span class="keyword">new</span> MaterialPageRoute(</span><br><span class="line">    builder: (contex) &#123;<span class="comment">//1.在builder方法中构建路由，builder方法是匿名函数</span></span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Iterable</span>&lt;ListTile&gt; tiles = _likeNameArray.map(</span><br><span class="line">        (WordPair name) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> ListTile (<span class="comment">//2. 创建ListTile：tiles</span></span><br><span class="line">            title: Text(</span><br><span class="line">              name.asPascalCase</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;Widget&gt; divided = ListTile <span class="comment">//6. divided最后含有分割线的列表</span></span><br><span class="line">      .divideTiles(<span class="comment">//3. ListTile的divideTiles()方法在每个tile之间添加1像素分割线，不用像之前判断奇偶添加Divider()</span></span><br><span class="line">        context: context,</span><br><span class="line">        tiles: tiles,<span class="comment">//4. 这是上面根据收藏数组创建的ListTile</span></span><br><span class="line">      )</span><br><span class="line">      .toList();<span class="comment">//5. 转换成列表显示</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上述方法创建了收藏夹，还未结束，<code>builder</code>返回一个<code>Scaffold</code>，在这里将上面创建的列表添加到body，形成整个要push的路由</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _pushVc() &#123;</span><br><span class="line">  Navigator.push(context, </span><br><span class="line">    <span class="keyword">new</span> MaterialPageRoute(</span><br><span class="line">      builder: (contex) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">Iterable</span>&lt;ListTile&gt; tiles = _likeNameArray.map(</span><br><span class="line">          (WordPair name) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ListTile (</span><br><span class="line">              title: Text(</span><br><span class="line">                name.asPascalCase</span><br><span class="line">              ),</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">List</span>&lt;Widget&gt; divided = ListTile</span><br><span class="line">        .divideTiles(</span><br><span class="line">          context: context,</span><br><span class="line">          tiles: tiles,</span><br><span class="line">        )</span><br><span class="line">        .toList();<span class="comment">//创建收藏夹列表</span></span><br><span class="line">        <span class="keyword">return</span> Scaffold(</span><br><span class="line">          appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">'like'</span>),<span class="comment">//路由标题</span></span><br><span class="line">          ),</span><br><span class="line">          body: ListView(children: divided), <span class="comment">//路由内容</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，完成路由跳转的工作。跳转之后在新路由页面自动添加返回按钮，点击会返回，不用额外添加pop。这点和iOS很像，而且也支持手势右滑返回页面。</p>
<h2 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h2><p>在flutter中，使用theme控制APP主题，可更改颜色修改主题：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">  primaryColor: Colors.white,<span class="comment">//白色主题</span></span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<p>这里有个小坑，VSCode新建项目时，这个字段默认是<code>primarySwatch</code>，在设置白色时会报错。因为white和black是<code>Color</code>类型，不是<code>MaterialColor</code>。像yellow、blue等颜色属于<code>MaterialColor</code>。</p>
<p>或者直接使用<code>dark()</code>，设置暗黑主题：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">theme: <span class="keyword">new</span> ThemeData.dark(),</span><br></pre></td></tr></table></figure>

<p><strong>demo的完整代码见工程中的 <a href="https://github.com/mxdios/flutter-demo" target="_blank" rel="noopener">flutter_listview</a></strong></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter笔记2-第一个Flutter Demo</title>
    <url>/2020/03/12/flutter2/</url>
    <content><![CDATA[<p>第一个flutter demo—— 无限滚动的列表应用</p>
<p>Material Design （质感设计），Google开发的设计语言，拓展于Google即时的卡片设计。</p>
<p>flutter提供了丰富的质感设计风格的widgets，在flutter中，几乎所有都是widget，</p>
<a id="more"></a>

<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>; <span class="comment">//导入Material Design</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dart中的单行函数，main()是应用程序的主函数，执行结果是runApp(MyApp()), MyApp()就是下面自定义的函数。</span></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp()); </span><br><span class="line"></span><br><span class="line"><span class="comment">//MyApp继承自StatelessWidget</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Welcome to Flutter'</span>,</span><br><span class="line">      home: Scaffold(<span class="comment">//Scaffold是material提供的widget，具有默认导航栏，标题，主屏幕的body属性</span></span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Welcome to Flutter'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Text(<span class="string">'Hello World'</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可知，一个App是由widget组成的。widget可以一层层嵌套，它的最终显示样式，由它嵌套的子widget决定</p>
<p>示例中，body是一个widget，里面包含了Center widget，Center widget又包含了Text widget，Center widget决定了子widget以居中样式呈现，所以body的呈现样式是居中显示了文本 <code>Hello World</code></p>
<h2 id="引入开源包"><a href="#引入开源包" class="headerlink" title="引入开源包"></a>引入开源包</h2><p>使用 <a href="https://pub.flutter-io.cn/packages/english_words" target="_blank" rel="noopener">english_words</a> 资源包，英文单词数据资源</p>
<p>项目中 <code>pubspec.yaml</code> 是资源管理包，类似iOS开发中使用cocopads的 <code>Podfile</code>。</p>
<p>在 <code>dependencies</code> 栏下添加资源包名：<code>english_words: ^3.1.5</code> （3.1.5 或更高版本）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">    </span><br><span class="line">  <span class="attr">cupertino_icons:</span> <span class="string">^0.1.2</span></span><br><span class="line">  <span class="attr">english_words:</span> <span class="string">^3.1.5</span></span><br></pre></td></tr></table></figure>

<p>添加之后，在VSCode右上角，有一个方块加向下箭头的图标 <code>Get Packages</code>，点击便可安装资源包，控制台会打印安装结果：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">[first_demo] flutter packages get</span><br><span class="line">Running <span class="string">"flutter pub get"</span> <span class="keyword">in</span> first_demo...                          <span class="number">0.4</span>s</span><br><span class="line"><span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>同时会在 <code>pubspec.lock</code> 文件中增加了添加的包名和版本信息：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">english_words:</span></span><br><span class="line"><span class="symbol">    dependency:</span> <span class="string">"direct main"</span></span><br><span class="line"><span class="symbol">    description:</span></span><br><span class="line"><span class="symbol">      name:</span> english_words</span><br><span class="line"><span class="symbol">      url:</span> <span class="string">"https://pub.flutter-io.cn"</span></span><br><span class="line"><span class="symbol">    source:</span> hosted</span><br><span class="line"><span class="symbol">    version:</span> <span class="string">"3.1.5"</span></span><br></pre></td></tr></table></figure>

<h2 id="使用资源包English-words"><a href="#使用资源包English-words" class="headerlink" title="使用资源包English words"></a>使用资源包English words</h2><p>示例代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:english_words/english_words.dart'</span>; <span class="comment">//引入english_words，写类WordPair时，会自动引入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> name = WordPair.random(); <span class="comment">//english_words中的随机词对，final是定义不变更的变量的关键字</span></span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Welcome to Flutter'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Text(name.asPascalCase), <span class="comment">//asPascalCase是大驼峰命名法，每个单次首字母大写，相应的还有asCamelCase等，可以尝试。</span></span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击 <code>command + s</code> （也可点击VSCode上悬浮栏的闪电按钮）会热重载，APP中的文字会不断变化。</p>
<h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><p>上述demo中，是用的StatelessWidget，这是不可变的widget，属性不能改变，都是final的。</p>
<p>StatefulWidget是可变的widget，它本身不可变，但它有一个 <code>State</code> 状态类，这个在widget整个生命周期一直存在，是可变的。</p>
<p>创建一个StatefulWidget，和创建StatelessWidget一样，示例代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomWorld</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  WorldState createState() =&gt; WorldState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法中 <code>WorldState</code> 是StatefulWidget的 State 类，这个类通过createState()方法创建，后跟创建 State类的自定义方法 <code>WorldState()</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorldState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RandomWorld</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> name = WordPair.random();</span><br><span class="line">    <span class="keyword">return</span> Text(name.asPascalCase);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是创建State的实现方法，WorldState集成自State，<code>&lt;RandomWords&gt;</code> 代表着专门用于<code>RandomWorld</code> 的State泛型类。里面的build方法比较容易理解，就是创建widget的build方法，里面返回了一个动态的Text。这说明State也是一个widget。</p>
<p><em>万物皆widget啊！</em></p>
<p>剩下的就是使用StatefulWidget，在MyApp中使用StatefulWidget的自定义RandomWorld，动态name用不到了，直接使用<code>RandomWorld()</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// final name = WordPair.random();</span></span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Welcome to Flutter'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: RandomWorld()</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，跟之前别无二致，还是APP中的英文词组在变化。但变化从由<code>StatelessWidget</code>里的一个widget控制，变为由<code>StatefulWidget</code> 的 <code>State</code>控制。</p>
<h2 id="无限滚动列表"><a href="#无限滚动列表" class="headerlink" title="无限滚动列表"></a>无限滚动列表</h2><p>无限滚动是动态的，在上述demo中开发无限滚动列表，需要在State类 <code>WorldState</code> 中操作。</p>
<p>无限滚动列表，需要有个无限的数组数据源，所以首先在 <code>WorldState</code> 创建一个数组，用于存放数据源：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorldState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RandomWorld</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _worldArray = &lt;WordPair&gt;[]; <span class="comment">//创建数组，存放内容是WordPair。在Dart中，使用_前缀，会强制使其变为私有</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了数据源，开始创建一个ListView，这是列表widget：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget _listView() &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.builder( <span class="comment">//ListView类的builder方法</span></span><br><span class="line">      itemBuilder: (context, i) &#123; <span class="comment">//itemBuilder 是ListView的builder属性，是匿名回调函数，接收两个参数BuildContext和 i，i从0开始自增</span></span><br><span class="line">        <span class="keyword">if</span> (i.isOdd) &#123; <span class="comment">//在奇数行添加分割线</span></span><br><span class="line">          <span class="keyword">return</span> Divider();<span class="comment">//分割线</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> index = i ~/ <span class="number">2</span>; <span class="comment">// i/2向下取整，能得到偶数列按照0、1、2、3……的index</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _worldArray.length) &#123;</span><br><span class="line">          _worldArray.addAll(generateWordPairs().take(<span class="number">10</span>)); <span class="comment">//当index是数组长度时，数组最后一位了，再生成10个词组添加到数组中。generateWordPairs()是WordPairs的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _buildRow(_worldArray[index]); <span class="comment">//偶数行，向列表中添加文本</span></span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>向列表中添加文本也是个私有方法 <code>_buildRow</code> :</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget _buildRow(WordPair name) &#123; <span class="comment">//传参，数组中的元素WordPair</span></span><br><span class="line">    <span class="keyword">return</span> ListTile( <span class="comment">//返回列表的Tile，类似于iOS中的cell</span></span><br><span class="line">      title: Text(</span><br><span class="line">        name.asPascalCase,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>至此，无限列表已经创建完了。要将无限列表添加到 <code>WorldState</code> 中，替换原来赋值词组的方法 ：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold( <span class="comment">//将整个Scaffold 都放到这里处理</span></span><br><span class="line">      appBar: AppBar (</span><br><span class="line">        title: Text(<span class="string">'Home'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: _listView(), <span class="comment">//body存放自定义的无限列表。</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最后再更改MyApp的方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: RandomWorld() <span class="comment">//home直接赋值自定义的动态widget即可。</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行便呈现了无限滚动列表！</p>
<p><strong>demo的完整代码见工程中的 <a href="https://github.com/mxdios/flutter-demo" target="_blank" rel="noopener">first_demo</a></strong></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter笔记1-搭建开发环境</title>
    <url>/2020/03/12/flutter1/</url>
    <content><![CDATA[<h2 id="在macOS上搭建flutter开发环境"><a href="#在macOS上搭建flutter开发环境" class="headerlink" title="在macOS上搭建flutter开发环境"></a>在macOS上搭建flutter开发环境</h2><h3 id="获取flutter-sdk"><a href="#获取flutter-sdk" class="headerlink" title="获取flutter sdk"></a>获取flutter sdk</h3><p>官网地址：<a href="https://flutter.dev/docs/development/tools/sdk/releases?tab=macos#macos" target="_blank" rel="noopener">https://flutter.dev/docs/development/tools/sdk/releases?tab=macos#macos</a></p>
<p>github：<a href="https://github.com/flutter/flutter/releases" target="_blank" rel="noopener">https://github.com/flutter/flutter/releases</a></p>
<a id="more"></a>

<p>查看flutter SDK版本号：解压后 flutter/version</p>
<p>添加flutter到path中，’pwd’是解压后flutter的文件路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=`pwd`/flutter/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>export命令文件所在：</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>至此，只能在当前路径下使用flutter命令</p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>运行 <code>flutter doctor</code> 命令，查看是否需要安装其他依赖。根据提醒安装缺少的环境依赖。</p>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Doctor</span> <span class="selector-tag">summary</span> (<span class="selector-tag">to</span> <span class="selector-tag">see</span> <span class="selector-tag">all</span> <span class="selector-tag">details</span>, <span class="selector-tag">run</span> <span class="selector-tag">flutter</span> <span class="selector-tag">doctor</span> <span class="selector-tag">-v</span>):</span><br><span class="line"><span class="selector-attr">[✓]</span> <span class="selector-tag">Flutter</span> (<span class="selector-tag">Channel</span> <span class="selector-tag">stable</span>, <span class="selector-tag">v1</span><span class="selector-class">.12</span><span class="selector-class">.13</span>+<span class="selector-tag">hotfix</span><span class="selector-class">.8</span>, <span class="selector-tag">on</span> <span class="selector-tag">Mac</span> <span class="selector-tag">OS</span> <span class="selector-tag">X</span> 10<span class="selector-class">.15</span><span class="selector-class">.2</span> 19<span class="selector-tag">C57</span>, <span class="selector-tag">locale</span> <span class="selector-tag">zh-Hans-CN</span>)</span><br><span class="line"><span class="selector-attr">[✓]</span> <span class="selector-tag">Android</span> <span class="selector-tag">toolchain</span> <span class="selector-tag">-</span> <span class="selector-tag">develop</span> <span class="selector-tag">for</span> <span class="selector-tag">Android</span> <span class="selector-tag">devices</span> (<span class="selector-tag">Android</span> <span class="selector-tag">SDK</span> <span class="selector-tag">version</span> 28<span class="selector-class">.0</span><span class="selector-class">.3</span>)</span><br><span class="line"><span class="selector-attr">[✓]</span> <span class="selector-tag">Xcode</span> <span class="selector-tag">-</span> <span class="selector-tag">develop</span> <span class="selector-tag">for</span> <span class="selector-tag">iOS</span> <span class="selector-tag">and</span> <span class="selector-tag">macOS</span> (<span class="selector-tag">Xcode</span> 11<span class="selector-class">.3</span><span class="selector-class">.1</span>)</span><br><span class="line"><span class="selector-attr">[✓]</span> <span class="selector-tag">Android</span> <span class="selector-tag">Studio</span> (<span class="selector-tag">version</span> 3<span class="selector-class">.3</span>)</span><br><span class="line"><span class="selector-attr">[!]</span> <span class="selector-tag">IntelliJ</span> <span class="selector-tag">IDEA</span> <span class="selector-tag">Ultimate</span> <span class="selector-tag">Edition</span> (<span class="selector-tag">version</span> 2019<span class="selector-class">.2</span><span class="selector-class">.3</span>)</span><br><span class="line">    ✗ <span class="selector-tag">Flutter</span> <span class="selector-tag">plugin</span> <span class="selector-tag">not</span> <span class="selector-tag">installed</span>; <span class="selector-tag">this</span> <span class="selector-tag">adds</span> <span class="selector-tag">Flutter</span> <span class="selector-tag">specific</span> <span class="selector-tag">functionality</span>.</span><br><span class="line">    ✗ <span class="selector-tag">Dart</span> <span class="selector-tag">plugin</span> <span class="selector-tag">not</span> <span class="selector-tag">installed</span>; <span class="selector-tag">this</span> <span class="selector-tag">adds</span> <span class="selector-tag">Dart</span> <span class="selector-tag">specific</span> <span class="selector-tag">functionality</span>.</span><br><span class="line"><span class="selector-attr">[✓]</span> <span class="selector-tag">VS</span> <span class="selector-tag">Code</span> (<span class="selector-tag">version</span> 1<span class="selector-class">.42</span><span class="selector-class">.1</span>)</span><br><span class="line"><span class="selector-attr">[!]</span> <span class="selector-tag">Connected</span> <span class="selector-tag">device</span></span><br><span class="line">    ! <span class="selector-tag">No</span> <span class="selector-tag">devices</span> <span class="selector-tag">available</span></span><br></pre></td></tr></table></figure>

<p>问题：</p>
<p>执行 <code>flutter doctor</code> 命令时，提示“无法打开“idevice_id”，因为无法验证开发者”。</p>
<p>去Mac的“系统偏好设置–&gt;安全隐私–&gt;通用–&gt;允许idevice_id”，重新运行 <code>flutter doctor</code> 命令，弹窗会出现打开按钮。</p>
<h3 id="全局可用flutter命令"><a href="#全局可用flutter命令" class="headerlink" title="全局可用flutter命令"></a>全局可用flutter命令</h3><ol>
<li><p>获取flutter SDK路径，用在第2步中添加的路径。</p>
</li>
<li><p>不同系统文件目录可能会不相同，以 <code>.bashrc</code> 为例。在 <code>.bashrc</code> 文件中添加路径。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="string">"<span class="variable">$PATH</span>:/Users/inspiry/Desktop/work/flutter/bin"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 <code>source $HOME/.bash_profile</code> 刷新命令行</p>
</li>
<li><p>使用 <code>echo $PATH</code> 命令查看SDK路径是否已添加</p>
</li>
<li><p>使用 <code>which flutter</code> 查找flutter，验证是否可用全局命令</p>
</li>
</ol>
<p>至此，开发环境配置完成。</p>
<h3 id="flutter其他命令"><a href="#flutter其他命令" class="headerlink" title="flutter其他命令"></a>flutter其他命令</h3><ol>
<li>查看安装的flutter版本：<code>flutter --version</code></li>
<li>查看线上flutter分支：<code>flutter channel</code> ，”stable”是稳定版分支，”master”是开发版分支</li>
<li>升级flutter sdk和依赖包：<code>flutter upgrade</code></li>
<li>flutter项目中获取项目的依赖包：<code>flutter packages get</code></li>
<li>flutter项目中升级项目依赖包的最新版：<code>flutter packages upgrade</code></li>
</ol>
<h2 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h2><h3 id="VS-Code配置"><a href="#VS-Code配置" class="headerlink" title="VS Code配置"></a>VS Code配置</h3><ol>
<li>安装flutter插件，在Extension中搜索flutter插件，安装，重启VSCode</li>
<li>验证flutter，在命令面板 <code>command + shift + p</code> 中输入doctor，选择 <code>Flutter: Run Flutter Doctor</code> 运行。查看输出是否有问题。打印结果和命令行中doctor命令结果一致。</li>
</ol>
<h3 id="VS-Code新建项目"><a href="#VS-Code新建项目" class="headerlink" title="VS Code新建项目"></a>VS Code新建项目</h3><ol>
<li>命令面板运行 <code>Flutter:New Project</code></li>
<li>输入项目名称，回车，选择项目存放目录</li>
</ol>
<p>简单的两步便创建了一个flutter项目，项目所需代码在 <code>lib/main.dart</code> </p>
<h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>在vscode最下面的状态栏中选择模拟器，点击 <code>运行 - 启动调试</code>，demo会运行到模拟器中</p>
<p>flutter支持热重载，直接修改 <code>lib/main.dart</code> 中的代码，保存后即刻呈现在APP上。</p>
<p>问题：</p>
<ol>
<li>找不到状态栏：<code>查看 - 外观 - 勾选显示状态栏</code></li>
<li>提醒在flutter SDK中找不到Dart，要求在命令行中运行 <code>flutter doctor</code> 命令重试，运行命令则无反应。解决办法：在进程中找到 dart 关闭，重启vscode重试。</li>
</ol>
<p>至此，开发环境搭建完成。</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>mRemind 使用条款</title>
    <url>/2018/12/26/shiyongtiaokuan/</url>
    <content><![CDATA[<h2 id="使用条款"><a href="#使用条款" class="headerlink" title="使用条款"></a>使用条款</h2><p>在购买 mRemind 高级版之前，您应当阅读并遵守以下使用条款。</p>
<a id="more"></a>

<h2 id="订阅服务"><a href="#订阅服务" class="headerlink" title="订阅服务"></a>订阅服务</h2><p>我们使用订阅制来管理 mRemind 高级版的用户权益，采用月度订阅和年度订阅。</p>
<p>确认购买订阅服务后，将向您的Apple ID账户收款。购买连续包年项目，除非您在当前计费周期结束前至少24小时取消订单，否则项目会自动续订，您的账户将在当前计费周期结束前24小时内收取续订费用。</p>
<p>任何时候，您都可在App Store的账户设置中进行订阅管理。</p>
<h2 id="订阅服务内容"><a href="#订阅服务内容" class="headerlink" title="订阅服务内容"></a>订阅服务内容</h2><ul>
<li>添加多条mRemind提醒</li>
<li>日期选择功能</li>
<li>自定义时间功能</li>
</ul>
<p>这三项为 mRemind 高级版所具备的功能，未购买 mRemind 高级版，也可以使用 mRemind 提供的基础服务：</p>
<ul>
<li>添加不超过3条的mRemind提醒</li>
<li>5、10、20、30分钟的倒计时提醒</li>
<li>全部提醒的勾选/删除操作</li>
<li>以及其他 mRemind 提供的服务</li>
</ul>
<h2 id="功能可用性"><a href="#功能可用性" class="headerlink" title="功能可用性"></a>功能可用性</h2><p>mRemind 采用订阅制来管理高级功能服务，当订阅过期未续费时，mRemind 将不提供高级版的服务。具体细节如下：</p>
<ul>
<li>将无法新增超过3条的 mRemind 提醒</li>
<li>将无法添加自定义的倒计时时间</li>
<li>添加 mRemind 提醒时，将无法使用日期选择功能</li>
</ul>
<p>但您处在订阅期间所添加的 mRemind 提醒和自定义时间都会保留，继续供您使用。</p>
<h2 id="退款"><a href="#退款" class="headerlink" title="退款"></a>退款</h2><p>如果您对 mRemind 所提供的服务不满意，请优先考虑通过联系方式联系我们，将您的不满意告知我们，我们会认真考虑您的意见或建议，对 mRemind 作出调整更改，为您提供更好的服务。</p>
<p>如果您依旧有退款的需求，对此我们表示遗憾，但应用的内购退款流程并不受开发者掌握，您可以通过邮件反馈您的诉求，但还是建议您联系 Apple 的支持团队来进行退款操作处理，具体可查看：<a href="https://support.apple.com/zh-cn/HT204084" target="_blank" rel="noopener">针对从 Apple 购买的 App 或内容申请退款</a>。</p>
<h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>我们有权根据 mRemind 产品计划和运营情况，独立决定会员订阅服务的具体内容，并有权根据电子内容的版权情况新增或移除电子内容或暂停、终止提供会员订阅服务的部分服务。</p>
<p>我们也会不时更新本使用条款，我们建议您定期查看该协议，了解变更内容。</p>
<p>前述更改在此页面上发布立即生效，你同意我们对此免责。</p>
<h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a>联系我们</h2><p>mRemind 是独立开发项目，您的支持会让 mRemind 有更好的发展，感谢所有 mRemind 的用户。</p>
<p>如果您对 mRemind 或使用条款有任何疑问或建议，请随时通过 <a href="mailto:i@markmiao.com">i@markmiao.com</a> 与我们联系。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>隐私政策</title>
    <url>/2018/12/25/yinsizhengce/</url>
    <content><![CDATA[<p>本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，我们会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。您在使用本应用及服务前，请您务必仔细阅读本政策。你在同意本应用服务使用协议之时，即视为您同意本《隐私政策》（含更新版本）全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。</p>
<a id="more"></a>

<ol>
<li><p>适用范围<br>(a) 在您注册本应用帐号时，您根据本应用要求提供的个人注册信息；<br>(b) 在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；<br>(c) 本应用通过合法途径从商业伙伴处取得的用户个人数据。 您了解并同意，以下信息不适用本隐私权政策：<br>(a) 您在使用本应用平台提供的搜索服务时输入的关键字信息；<br>(b) 违反法律规定或违反本应用规则行为及本应用已对您采取的措施。</p>
</li>
<li><p>信息使用<br>(a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。<br>(b) 本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。<br>(c) 为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。</p>
</li>
<li><p>信息披露<br>在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息：<br>(a) 经您事先同意，向第三方披露；<br>(b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息；<br>(c) 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；<br>(d) 如您出现违反中国或其他国家有关法律、法规或者本应用服务协议或相关规则的情况，需要向第三方披露；<br>(e) 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷；<br>(f) 在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。<br>(g) 其它本应用根据法律、法规或者网站政策认为合适的披露。</p>
</li>
<li><p>信息存储和交换<br>本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。</p>
</li>
<li><p>Cookie的使用<br>(a) 在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。<br>(b) 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。<br>(c) 通过本应用所设cookies所取得的有关信息，将适用本政策。</p>
</li>
<li><p>信息安全<br>(a) 本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。<br>(b) 在使用本应用网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是本应用用户名及密码发生泄露，请您立即联络本应用客服，以便本应用采取相应措施。<br>7.本隐私政策的更改<br>(a)如果决定更改隐私政策，我们会在本政策中、本公司网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。<br>(b)本公司保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，本公司会通过网站通知的形式告知。</p>
</li>
<li><p>联系我们</p>
<p>如果您对我们的隐私政策有任何疑问或建议，请随时通过 <a href="mailto:i@markmiao.com">i@markmiao.com</a> 与我们联系。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime(1)：消息传递</title>
    <url>/2018/03/16/runtime1/</url>
    <content><![CDATA[<p>OC是动态语言，只有在运行时才会根据方法名去调用方法，称为给方法发送消息，是因为当调用<code>[demoObj setTest]</code>方法时，编译器会转化为<code>objc_msgSend(demoObj, @selector(setTest))</code>。如果携带参数，如<code>[demoObj setTest:str]</code>，会转化为<code>objc_msgSend(demoObj, @selector(setTest), str)</code>。</p>
<a id="more"></a>

<h2 id="unrecognized-selector-sent-to-instance"><a href="#unrecognized-selector-sent-to-instance" class="headerlink" title="unrecognized selector sent to instance"></a>unrecognized selector sent to instance</h2><p><code>unrecognized selector sent to instance</code>是开发中经常遇到的异常，诸如点击事件没有实现，调用了只声明未实现的方法，向NSArray调用了NSMutableArray的方法等等。</p>
<p>我们定义类<code>DemoObject</code>，在<code>.h</code>中声明方法<code>- (void)setTest;</code>，<code>.m</code>中不写方法实现。然后调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DemoObject *demoObj &#x3D; [[DemoObject alloc] init];</span><br><span class="line">[demoObj setTest];</span><br></pre></td></tr></table></figure>

<p>程序会很听话的崩掉，并抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-[DemoObject setTest]: unrecognized selector sent to instance 0x60000000bda0</span><br></pre></td></tr></table></figure>

<p>在程序崩溃之前，消息会经过下面几个方法转发：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    NSLog(@&quot;解析实例方法&quot;);</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    NSLog(@&quot;解析类方法&quot;);</span><br><span class="line">    return [super resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSLog(@&quot;转发目标选择器&quot;);</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSLog(@&quot;选择器方法签名&quot;);</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    NSLog(@&quot;转发调用&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSLog(@&quot;不识别选择器，崩溃&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息会经过上述方法传递，最终未果才会崩溃。在上述方法中我们有三次机会操作消息传递，防止崩溃。</p>
<ol>
<li>动态添加方法：<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>或<code>+ (BOOL)resolveClassMethod:(SEL)sel</code></li>
<li>方法重定向：<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code></li>
<li>消息转发：<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>和<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code></li>
</ol>
<h2 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h2><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>在类DemoObject中引入runtime：<code>#import &lt;objc/runtime.h&gt;</code>，使用<code>class_addMethod</code>动态添加方法实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void resolveTest(id self, SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;动态添加方法调用 &#x3D; %@&quot;, NSStringFromSelector(_cmd));</span><br><span class="line">&#125;</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(setTest)) &#123;</span><br><span class="line">        class_addMethod([self class], sel, (IMP)resolveTest, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法<code>class_addMethod</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OBJC_EXPORT BOOL</span><br><span class="line">class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, </span><br><span class="line">                const char * _Nullable types) </span><br><span class="line">    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</span><br></pre></td></tr></table></figure>

<p>参数意义如下：</p>
<ul>
<li>cls：消息接收者</li>
<li>name：SEL方法名</li>
<li>imp：要动态添加方法的IMP指针</li>
<li>types：参数和返回值的符号字符串，<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">查看格式文档</a></li>
</ul>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>解析类方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(setTestClass)) &#123;</span><br><span class="line">        class_addMethod(object_getClass(self), sel, (IMP)resolveTest, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的区别在于cls：消息接收者，解析实例方法使用的<code>[self class]</code>，解析类方法使用的<code>object_getClass(self)</code>。</p>
<p>当self为实例对象时，<code>[self class]</code>与<code>object_getClass(self)</code>等价，因为前者会调用后者。<code>object_getClass([self class])</code>得到元类。</p>
<p>当self为类对象时，<code>[self class]</code>返回值为自身，还是self，所以上面解析实例方法将<code>[self class]</code>换成<code>self</code>也可以。<code>object_getClass(self)</code>与<code>object_getClass([self class])</code>等价。</p>
<h2 id="方法重定向"><a href="#方法重定向" class="headerlink" title="方法重定向"></a>方法重定向</h2><h3 id="实例方法-1"><a href="#实例方法-1" class="headerlink" title="实例方法"></a>实例方法</h3><p>重写<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>方法，可以将消息的接收者替换成其他对象。</p>
<p>新创建一个类<code>DemoNewObject</code>，将类<code>DemoObject</code>未实现的方法<code>- (void)setTest</code>，在<code>.m</code>中实现，无需在<code>.h</code>中暴露方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setTest &#123;</span><br><span class="line">    NSLog(@&quot;实例方法重定向&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法重定向操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(setTest)) &#123;</span><br><span class="line">        DemoNewObject *obj &#x3D; [[DemoNewObject alloc] init];</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类方法-1"><a href="#类方法-1" class="headerlink" title="类方法"></a>类方法</h3><p>类方法重定向需要重写<code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>方法，注意是<code>+</code>开头的类方法。</p>
<p>同样在新类<code>DemoNewObject</code>中实现类方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (void)setTestClass &#123;</span><br><span class="line">    NSLog(@&quot;类方法重定向&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写重定向方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(setTestClass)) &#123;</span><br><span class="line">        return NSClassFromString(@&quot;DemoNewObject&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法重定向就是将当前类未实现的方法，重定向到一个实现该方法的新类中，调用新类中的方法实现。实例方法中返回实例对象，类方法中返回类对象。</p>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>消息转发是通过方法<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>实现的，它可以将不能处理的消息转发给其他对象处理，参数<code>anInvocation</code>是通过方法<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>产生的。</p>
<p>所以需要重写两个方法，<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>和<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature *signature &#x3D; [super methodSignatureForSelector:aSelector];</span><br><span class="line">    if (!signature) &#123;</span><br><span class="line">        if ([DemoNewObject instancesRespondToSelector:aSelector]) &#123;</span><br><span class="line">            signature &#x3D; [DemoNewObject instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    if ([DemoNewObject instancesRespondToSelector:anInvocation.selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:[[DemoNewObject alloc] init]];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考资料</strong></p>
<p><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a></p>
<p><a href="https://www.jianshu.com/p/60c251712df7" target="_blank" rel="noopener">iOS中的unrecognized selector sent to instance..</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发笔记三</title>
    <url>/2018/03/02/ios3/</url>
    <content><![CDATA[<h2 id="NSInterger-to-NSData"><a href="#NSInterger-to-NSData" class="headerlink" title="NSInterger to NSData"></a>NSInterger to NSData</h2><p>NSInterger to NSData，数字转化为Data，打印出来以十六进制形式展示</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSData *)getDataWithInt:(NSInteger)interger &#123;</span><br><span class="line">    Byte b1&#x3D;interger &amp; 0xff;</span><br><span class="line">    Byte b2&#x3D;(interger&gt;&gt;8) &amp; 0xff;</span><br><span class="line">    Byte b3&#x3D;(interger&gt;&gt;16) &amp; 0xff;</span><br><span class="line">    Byte b4&#x3D;(interger&gt;&gt;24) &amp; 0xff;</span><br><span class="line">    if (interger &lt;&#x3D; 255) &#123;</span><br><span class="line">        Byte byte[] &#x3D; &#123;b1&#125;;</span><br><span class="line">        return [NSData dataWithBytes:byte length:sizeof(byte)];</span><br><span class="line">    &#125; else if (interger &lt;&#x3D; 65535) &#123;</span><br><span class="line">        Byte byte[] &#x3D; &#123;b2,b1&#125;;</span><br><span class="line">        return [NSData dataWithBytes:byte length:sizeof(byte)];</span><br><span class="line">    &#125; else if (interger &lt;&#x3D; 16777215) &#123;</span><br><span class="line">        Byte byte[] &#x3D; &#123;b3,b2,b1&#125;;</span><br><span class="line">        return [NSData dataWithBytes:byte length:sizeof(byte)];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Byte byte[] &#x3D; &#123;b4,b3,b2,b1&#125;;</span><br><span class="line">        return [NSData dataWithBytes:byte length:sizeof(byte)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SHA1加密"><a href="#SHA1加密" class="headerlink" title="SHA1加密"></a>SHA1加密</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSString *)SHA1Encrypt:(NSString *)string&#123;</span><br><span class="line">    const char *cstr &#x3D; [string UTF8String];</span><br><span class="line">    NSData *data &#x3D; [NSData dataWithBytes:cstr length:string.length];</span><br><span class="line">    uint8_t digest[CC_SHA1_DIGEST_LENGTH];</span><br><span class="line">    CC_SHA1(data.bytes, (CC_LONG)data.length, digest);</span><br><span class="line">    NSMutableString *output &#x3D; [NSMutableString stringWithCapacity:CC_SHA1_DIGEST_LENGTH *2];</span><br><span class="line">    for (int i &#x3D; 0; i&lt;CC_SHA1_DIGEST_LENGTH; i++) &#123;</span><br><span class="line">        [output appendFormat:@&quot;%02x&quot;,digest[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    return output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="iPhone屏幕单位"><a href="#iPhone屏幕单位" class="headerlink" title="iPhone屏幕单位"></a>iPhone屏幕单位</h2><p>ios开发中设置的size为pt，pt是绝对长度，等于1/72英寸，等于1/72*25.4毫米。</p>
<p>px是像素，像素点的密度代表着屏幕清晰度。这就是开发中@1x、@2x、@3x的区别。</p>
<p>iPhone 3GS是@1x像素级，分辨率为480px * 320px，iPhone4是@2x像素级，分辨率为960px * 640px。这两者尺寸是一样的，所以pt是一样的，在同样大的范围内，iPhone 4的像素点比iPhone 3GS的多一倍。</p>
<h2 id="QR码的一些知识点"><a href="#QR码的一些知识点" class="headerlink" title="QR码的一些知识点"></a>QR码的一些知识点</h2><p>QR码有40个版本，版本1是21 x 21个小方块组成，版本2是25 x 25个小方块，每增加1版本，二维码长宽各增加4个方块。所以最高版本40，方块数为177 * 177。计算公式是：(V-1) * 4 + 21</p>
<p>使用CIFilter生成QR码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生码Objective-C</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)markCode:(<span class="built_in">NSString</span> *)code &#123;</span><br><span class="line">    <span class="built_in">CIFilter</span> *filter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIQRCodeGenerator"</span>];</span><br><span class="line">    [filter setDefaults];</span><br><span class="line">    <span class="built_in">NSData</span> *data = [code dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    [filter setValue:data forKey:<span class="string">@"inputMessage"</span>];</span><br><span class="line">    [filter setValue:<span class="string">@"L"</span> forKey:<span class="string">@"inputCorrectionLevel"</span>]; <span class="comment">//二维码的纠错级别 L &lt; H &lt; Q &lt; M</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CIColor</span> *color1 = [<span class="built_in">CIColor</span> colorWithCGColor:[<span class="built_in">UIColor</span> blackColor].CGColor];<span class="comment">//二维码颜色</span></span><br><span class="line">    <span class="built_in">CIColor</span> *color2 = [<span class="built_in">CIColor</span> colorWithCGColor:[<span class="built_in">UIColor</span> whiteColor].CGColor];<span class="comment">//背景色</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *parameters = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: filter.outputImage ,<span class="string">@"inputImage"</span>, color1,<span class="string">@"inputColor0"</span>, color2,<span class="string">@"inputColor1"</span>,<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">CIFilter</span> *newFilter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIFalseColor"</span> withInputParameters:parameters];</span><br><span class="line">    <span class="built_in">CIImage</span> *outPutImage = [newFilter outputImage];</span><br><span class="line">    <span class="keyword">int</span> version = (<span class="keyword">int</span>)((outPutImage.extent.size.width - <span class="number">21</span>) / <span class="number">4.0</span> + <span class="number">1</span>); <span class="comment">//获取该二维码的版本号</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> createNonInterpolatedUIImageFormCIImage:outPutImage withSize:<span class="number">600</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让二维码变的清楚</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)createNonInterpolatedUIImageFormCIImage:(<span class="built_in">CIImage</span> *)image withSize:(<span class="built_in">CGFloat</span>) size &#123;</span><br><span class="line">    <span class="built_in">CGRect</span> extent = <span class="built_in">CGRectIntegral</span>(image.extent);</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = MIN(size/<span class="built_in">CGRectGetWidth</span>(extent), size/<span class="built_in">CGRectGetHeight</span>(extent));</span><br><span class="line">    size_t width = <span class="built_in">CGRectGetWidth</span>(extent) * scale;</span><br><span class="line">    size_t height = <span class="built_in">CGRectGetHeight</span>(extent) * scale;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> cs = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGContextRef</span> bitmapRef = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, cs, (<span class="built_in">CGBitmapInfo</span>)kCGImageAlphaPremultipliedLast);</span><br><span class="line">    <span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">CGImageRef</span> bitmapImage = [context createCGImage:image fromRect:extent];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextSetInterpolationQuality</span>(bitmapRef, kCGInterpolationNone);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(bitmapRef, scale, scale);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(bitmapRef, extent, bitmapImage);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGImageRef</span> scaledImage = <span class="built_in">CGBitmapContextCreateImage</span>(bitmapRef);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(bitmapRef); <span class="built_in">CGImageRelease</span>(bitmapImage);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *outputImage = [<span class="built_in">UIImage</span> imageWithCGImage:scaledImage];</span><br><span class="line">    <span class="keyword">return</span> outputImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>2017我的年终总结</title>
    <url>/2017/12/29/sum2017/</url>
    <content><![CDATA[<p>2016年的年终总结里写的愿望是：希望2017年的年终总结里没有懊悔。</p>
<p>回望2017，好像在原地踏步，像在风浪中打转的孤舟。混混沌沌算是过去了，这一晃又是一年。</p>
<a id="more"></a>

<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>没有跳槽，还是很平淡的敲代码，公司的代码敲的比较少了，一是没有什么技术难题，二是确实没有什么可敲的。这一年立志做自己的应用，写技术博客，开源项目。这几项都完成寥寥，没什么可总结的。独立项目，可看我上一篇文章<a href="http://markmiao.com/2017/12/26/kaifazhezongjietucao/">个人开发者的吐槽</a>；技术博客，没什么可说的；开源项目，呃……不丢人了……</p>
<p>明年还是想让自己的工作有一个大的改变，好几年都没有变化，做井底之蛙太久了。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>生活上比较跌宕起伏，有时间我会就这个大事件专门写一篇长文，吐槽一下整个2017年，我们的惊险奇遇。可以说见证了北京房价的疯狂，也见识到人性的卑劣，更体会到福祸相依的人生，还见识到不能说的黑暗。之所以现在还没写，是他妈的这件事还没完！！！</p>
<p>生活从不缺惊喜和惊吓，我会积极面对，不以物喜，不以己悲，佛系人生，看淡一切。WQNMLGB！</p>
<p>2017再见，2018你好。对2018的我说一句：再立志，别放弃！</p>
]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>个人开发者的吐槽</title>
    <url>/2017/12/26/kaifazhezongjietucao/</url>
    <content><![CDATA[<p>按说到了该写年终总结的时候了，不仅没写，还浪浪荡荡的想再写一篇吐槽。我不是独立开发者，只是想尝试一下自己设计、自己开发一款APP是一种什么样的体验。本文偏吐槽，没有实质性的内容总结，以后有机会再写一篇详细的开发体验。</p>
<a id="more"></a>

<h2 id="年终总结"><a href="#年终总结" class="headerlink" title="年终总结"></a>年终总结</h2><p>今年年初注册了苹果个人开发者账号，4月10日发布了第一款个人应用：<a href="https://itunes.apple.com/cn/app/%E6%8E%92%E7%8F%AD-%E4%B8%8A%E7%8F%AD%E6%97%B6%E9%97%B4-%E4%B8%80%E7%9B%AE%E4%BA%86%E7%84%B6/id1221228242?mt=8" target="_blank" rel="noopener">排班 - 上班时间，一目了然</a>，然后就不负责任地再也没迭代过新版本，新版并不是没开发，而是改动比较多，步子迈大了，中途忙别的就给耽误了。（死不承认是三分钟热度过劲了）</p>
<p>8月份发布了第一款macOS应用：<a href="https://itunes.apple.com/cn/app/%E9%80%9F%E8%AE%B0-%E5%BF%AB%E9%80%9F%E8%AE%B0%E5%BD%95%E6%AF%8F%E4%B8%80%E6%AE%B5%E6%96%87%E5%AD%97/id1263819789?mt=12" target="_blank" rel="noopener">速记 - 快速记录每一段文字</a>，然后就臭不要脸地只迭代了一版。这是我学习macOS开发的试水项目，以后可能还会迭代新版本吧。其实年底又新开了一个macOS应用项目，开发了一半，明年发布。旧坑不填，新坑不断。</p>
<p>今年是我写个人项目的第一年，算起来做iOS开发也好几年了，现在才搞，也是后知后觉。年底了，集中吐槽一下做个人独立项目的经历和感触。</p>
<p>“利用业余时间，将自己的技术转化为产品，能帮助用户，并收获5星好评，感觉棒棒哒。”这冠冕堂皇的说辞是不是看的有点吐？不吹牛逼，扯点实际的。</p>
<p>其实是用一堆烂代码攒个烂app，祈求没bug，让用户购买，日夜盼望着销量多点，多赚点外快，攒点私房钱。再收获点好评和赞美邮件，跳槽时再能当个加分点，岂不是美滋滋？</p>
<p>一年时间快过去了，勉强把交给苹果的保护费赚回来了。最佳成绩是效率付费APP排行榜第19位。收获了二三十封邮件反馈，意见和建议都很好，我会慢慢加到APP里，明年就加，不吹牛逼。也有一两封邮件，开篇就骂，要求退款。App Store收获了21条评论，5星4星好评占大多数，也有说不好用给1星的，或者直接骂垃圾给1星。不论好坏，照单全收。</p>
<h2 id="付费机制"><a href="#付费机制" class="headerlink" title="付费机制"></a>付费机制</h2><p>我的两个APP都采用了最简单的付费模式——付费下载。一次性买断，享受永久的应用服务和后续所有新版本迭代。另一种付费模式是内购，可以免费安装使用部分功能，解锁全部功能需要内购付费，这类付费可以是买断（比如游戏解锁关卡），也可以是订阅式（比如会员服务）。</p>
<p>现在越来越多的应用开始采用内购订阅模式，对开发者来说，不仅仅依靠新增用户付费，老用户在享受应用服务和新版本迭代，也支付一些费用，这样有利于应用的长期发展。对用户来说，不用付费就能先体验一把，适不适合自己可以有个判断，再决定是否付费享受全部功能。这种缓冲策略，对于用户量增长也很有利。</p>
<p>当然，对于订阅模式的应用，如何界定免费功能和付费功能，还有很多需要探讨的地方。免费功能可以满足用户，便很少有用户会付费；免费功能太少，如同鸡肋，用户有可能会骂娘直接卸载。</p>
<p>其实最艰难的，当属付费应用转为免费+订阅式应用的转型。老用户当时狠心花钱买断了应用，你现在告诉人家要交年费，这不是坑人吗。著名的markdown编辑器Ulysses，日记应用Day One，密码存储应用1Password，这几款堪称神作的APP都经历了从付费应用到免费+订阅式应用的转变。然后在转型初期，无一例外的收获了大量的1星差评和骂娘评论。</p>
<p>也有公司干脆发布一款免费+订阅式的新应用，保留付费买断的旧应用。著名思维导图应用MindNode就是这么做的，新版MindNode5是免费+订阅，旧版MindNode4（macOS应用是MindNode2）是付费应用。但这样一来，就会出现用户导流的新问题，同时维护两个应用也增加了开发成本。</p>
<p>未来的付费应用，使用订阅式这类持续付费的会越来越多，毕竟软件公司需要维持发展，开发者也得活着吃饭，仅靠新增用户，收益只会越来越少，饿死是迟早的事。其实这也符合自然法则，你购买APP是享受它带来的持续服务，还包括新版本新功能，这又不是一次性的。不像买根黄瓜，吃完了事。</p>
<p>所以明年上架的macOS应用，我打算尝试一下付费订阅模式。</p>
<h2 id="收益分成"><a href="#收益分成" class="headerlink" title="收益分成"></a>收益分成</h2><p>App Store上所有的付费应用，苹果公司都要抽成30%，不论是付费下载还是内购（订阅式内购第一年抽成30%，第二年抽成15%）。想想让腾讯赚个盆满钵满的王者荣耀，苹果已经拿走了30%，App Store可不止一个王者荣耀。一个APP卖1块钱，苹果会拿走3毛，1分钱交税，开发者得6毛9分钱，还是人家做平台的牛逼啊。</p>
<p>曾经有一个用户给我发邮件，说APP不好用，要我退他1块钱。我满腔苦水无人诉说，我这省吃俭用攒了688块钱，向苹果爸爸买了个摊位，辛辛苦苦开发了个应用，求苹果爸爸高抬贵手通过审核，终于摆上摊位。你花1块钱买了，转头说不好用，让我退钱。我哪有钱呐，别说你这1块了，该分成给我的6毛9也没到我手里啊！</p>
<p>这里我想说的是，买错的或者用着不满意的APP可以退款，但你不应该找开发者，应该去找苹果公司。购买90天内，你可以在已购APP里申请退款，苹果会根据你的使用情况和理由酌情考虑会不会给你退钱。即使退款成功，APP也不会从你手机里卸载，你还能继续使用。如果退款不成功，那你要考虑下为什么了，一个游戏你都玩通关了，再去申请退款，肯定没戏。所以，要退款，请出门左转找苹果。</p>
<p>用户购买APP的钱并不会实时转账到开发者的账户，我只能看到下载量和预计收益，收益到账？不存在的。每月苹果会下发上月的财务报告，但并不代表着会给开发者打钱。只有收益累计超过150美元，苹果才会给开发者汇款。如果收益达不到150美元，会自动累计到下个月。也就是说，我靠着6毛9、6毛9、6毛9……这个赚法，一直赚到1000块钱，苹果才会给我转账。你张口就让我退你1块钱，我哪有啊！</p>
<h2 id="艰难入账"><a href="#艰难入账" class="headerlink" title="艰难入账"></a>艰难入账</h2><p>终于有一天，我的收益超过了150美元，苹果要给我打钱了。这些年净是给苹果送钱了，终于要见到回头钱了。然而中国银行还横插了一杠子。</p>
<p>上架付费应用需要绑定银行卡，不然苹果无法给开发者汇款收益，我绑定了一张中国银行的储蓄卡。苹果汇款那天我接到了中国银行给我打的电话：“您有一笔美元汇款，请问这笔钱是做什么用的？”</p>
<p>我有点懵，我说：“是苹果公司给我的付费应用分成收益，是合法的。”我特意强调合法，我心里还嘀咕，中国银行认为我走私了？</p>
<p>对方说：“收益？是劳务报酬吗？”</p>
<p>我想我又不是苹果员工，这算劳务报酬吗？其实这就是劳务报酬，在苹果的App Store上发布应用获取收益，也属于参与了苹果提供的工作岗位。</p>
<p>我问：“为什么要问这笔钱是做什么用的？”</p>
<p>对方说：“这是境外公司对个人的汇款，您必须提供对方为什么给你汇这笔钱的说明资料，然后我们才能给您入账。”</p>
<p>我明白了，钱是我的，我还得证明这钱为什么是我的。我说：“我怎么给你说明资料？”</p>
<p>对方说：“您什么时候方便，可以来柜台办理一下。”</p>
<p>我说：“我没时间过去，我这也只有电子版的，邮件发你吧。”</p>
<p>对方纠结了半天，还是同意了，说先发过去看看。然后给我发了一封只有标题，内容全是甩锅的邮件，让我在回复邮件中提供说明资料。</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/WX20171226-155140.png" alt="甩锅邮件"></p>
<p>我将苹果的付费应用协议《Paid Applications Agreement》PDF文件发过去了，这份协议有36页，全是英文。我在网上搜索，好多开发者都遇到过这个问题，被银行刁难必须提供汇款说明资料。有一个最悲催的开发者，被银行要求将这36页的付费应用协议翻译成中文打印出来。</p>
<p>我本以为这就可以了，过了两天，中国银行又给我打电话，说我必须得去签字，同意美元入账。我说那人民币入账吧，对方说人民币入账我得带着身份证去做汇率转换。说到底我还得跑一趟。</p>
<p>在柜台签字入账的时候，我发现那36页的付费应用协议被打印出来了，厚厚的一摞，中国银行真牛！</p>
<p>我咨询了一下，这家中国银行支行只收到我这一例苹果公司给开发者汇款的业务，以后汇款入账，还得去柜台办理，我准备换银行卡了，谁知道哪家银行可以直接入账？</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>短文</tag>
        <tag>AppStore</tag>
      </tags>
  </entry>
  <entry>
    <title>吐槽苹果APP审核</title>
    <url>/2017/12/22/tucaoappshenhe/</url>
    <content><![CDATA[<p>前两天看图神发了一篇文章<a href="https://imtx.me/archives/2399.html" target="_blank" rel="noopener">谈谈 Apple 的「审核玄学」</a>，看完之后深以为然，苹果的APP上架审核堪称不可捉摸的玄学秘术。我也曾就这个问题吐槽过：<a href="http://markmiao.com/2017/08/12/talkingtoapple/">被苹果爸爸完全碾压的通话记录</a>，也记录过因各种问题被拒的经历：<a href="http://markmiao.com/2016/11/10/%E6%8F%90%E4%BA%A4%E5%BA%94%E7%94%A8%E5%88%B0AppStore%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/#%E4%B9%8B%E5%89%8D%E4%B8%8D%E5%B9%B8%E8%B8%A9%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%EF%BC%8C%E8%A2%ABAppStore%E6%8B%92%E4%BA%86">之前不幸踩过的一些坑，被AppStore拒了</a>、<a href="http://markmiao.com/2017/07/27/macosapprejected/">macOS应用上架被拒</a>。</p>
<a id="more"></a>

<p>细数这些年我被苹果审核拒绝的经历，貌似还没有离谱到玄学境地的（这个flag先立起来，等遇到了回来还愿）。虽然我没遇到，但其审核作风就是：“上联：说你行你就行，不行也行。下联：说不行就不行，行也不行。横批：不服不行。“</p>
<p>曾经一个app上架，被苹果以不支持IPv6-only为理由，拒绝了七八次。最后苹果警告，再不修复该问题，等待审核时间会加倍延长。我各种测试在IPv6-only网络环境下，APP网络访问完全没问题，当时在想是不是服务器接口被墙了？苹果审核时访问不了。给苹果拍视频，写邮件解释，换来的还是拒绝。</p>
<p>真实情况是根本不存在不支持IPv6-only的问题，而是苹果审核时未允许地理位置获取，导致某个接口缺少位置参数，结果返回网络连接失败。我和服务端都忽略了这个问题。其实只有这一个接口访问不了，其他接口完全没问题。但是苹果只给我截了这一页的截图，说接口访问失败，不支持IPv6-only。当时只顾着死怼IPv6-only，完全搞错了方向。</p>
<p>曾经还因为APP太简单被拒绝，苹果给的理由是应用过于简单，建议用HTML网页实现。其实APP界面跳转挺多的，只是意见反馈和教程讲解占了大部分功能，苹果认为这两个功能应用性太低，所以将其归类于太简单。然而你却没有权利反驳。</p>
<p>App Store上应用繁多，有好多APP的内容或功能违反了苹果审核条例，比如：盛名列车时刻就存在软件更新功能。但是这些并不是你可以这么做的理由。我曾经因APP被拒，向苹果审核人员抱怨：“有的应用就是这么做的。”结果被直接怼回来了：“如果你认为有应用存在违规，可以举报，但你的应用违反审核条例，不能上架。”</p>
<p>其实苹果也有宽宏大量的时候，我曾上架过一款TCP通讯的APP，需要和Windows客户端配合使用。APP打开只有一个登录界面，需要Windows客户端配合生成登录校验码，才能登录。使用时也需要开启Windows客户端，并输入Windows的IP和端口进行TCP通讯。</p>
<p>上架前曾绞尽脑汁考虑，怎么让苹果使用并审核APP呢？最后我拍了一段500M的视频，详细记录了使用过程，在提交APP的备注里加上视频地址。结果是APP审核通过，顺利上架。那一刻简直想高呼苹果万岁。</p>
<p>好人多吐槽过苹果的审核时间，APP上架会经历这几种状态：准备提交，等待审核，审核中，审核通过或被拒。APP提交后，等待审核这个阶段是最漫长的，平均一周左右。苹果审核太慢也是导致JSPatch等热更新技术兴起的一大原因。今年苹果明令禁止上架APP采用热更新技术，同时审核速度有所提高，运气好的话通常一两天就可以审核完成，运气不好就没准了。</p>
<p>我经历的APP审核绝大多数是在晚上，通常半夜睡觉前会收到进入审核状态的通知，第二天会收到通过或被拒的通知。而且发现周五晚上进入审核状态的几率比较高。感觉macOS应用比iOS应用审核快，我经历过最快的一次macOS应用审核，从APP提交到审核通过只用了2小时16分。</p>
<p>苹果的应用审核机构神秘莫测，鲜为人知；审核手段大道无形，难以捉摸。惹不起，惹不起。</p>
<p>做iOS开发，你不仅惹不起，还躲不起。</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>短文</tag>
        <tag>AppStore</tag>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS开发笔记(1)</title>
    <url>/2017/12/07/macosdevelnote1/</url>
    <content><![CDATA[<p>旧坑不填，喜开新坑。这两天又计划开发一款macOS应用，之前开发的<a href="http://markmiao.com/2017/07/26/stenonote/">速记</a>完全是练手，反正现在是不想填坑了，索性再开一个。实际做一个项目，是学习的最佳途径。本文记录了我在开发中遇到的各种问题，以及找到的解决办法，权当以后查阅的笔记。如果能给某位朋友带来帮助，是我的荣幸。如果发现问题，敬请评论吐槽。</p>
<a id="more"></a>

<p>开发环境：<strong>Xcode 9.1 + Swift4</strong></p>
<h2 id="StatusBar"><a href="#StatusBar" class="headerlink" title="StatusBar"></a>StatusBar</h2><h3 id="设置按钮"><a href="#设置按钮" class="headerlink" title="设置按钮"></a>设置按钮</h3><p>在<code>applicationDidFinishLaunching</code>方法中调用下面代码，设置StatusBar按钮</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createButtonStatusBar</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">let</span> statusBar = <span class="type">NSStatusBar</span>.system</span><br><span class="line">   <span class="keyword">let</span> item = statusBar.statusItem(withLength: <span class="type">NSStatusItem</span>.squareLength)</span><br><span class="line">   item.button?.target = <span class="keyword">self</span></span><br><span class="line">   item.button?.action = #selector(itemActionShowView(<span class="number">_</span>:))</span><br><span class="line">   <span class="keyword">let</span> image:<span class="type">NSImage</span> = <span class="type">NSImage</span>(named: <span class="type">NSImage</span>.<span class="type">Name</span>(rawValue: <span class="string">"mremindbaricon"</span>))!</span><br><span class="line">   image.isTemplate = <span class="literal">true</span></span><br><span class="line">   item.button?.image = image</span><br><span class="line">   statusItem = item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">itemActionShowView</span><span class="params">(<span class="number">_</span> sender: NSStatusBarButton)</span></span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"点击"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>itemActionShowView</code>是实现的点击方法，Swift4.0之后，必须增加<code>@objc</code>修饰符，是因为Swift4.0之后去掉了Swift3.x对隐式类型推断的特性，必须手动管理<code>@objc</code>，保证oc和Swift代码能互相调用。</p>
<h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><p>在<code>Main.storyboard</code>的<code>Application Scene</code>中拖入<code>NSMenu</code>，将<code>NSMenu</code>拖线到<code>AppDelegate</code>中。如同上面设置statusBar按钮一样，不需要设置按钮的<code>target</code>和<code>action</code>，需要设置<code>menu</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> toolMenu: <span class="type">NSMenu!</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">item.menu = toolMenu</span><br></pre></td></tr></table></figure>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-12-04-15-48-40.png" alt="添加NSMenu"></p>
<p>添加<code>NSMenu</code>的点击事件，直接拖线<code>action</code>即可。</p>
<h2 id="Dock和Window"><a href="#Dock和Window" class="headerlink" title="Dock和Window"></a>Dock和Window</h2><h3 id="隐藏Dock上的应用图标"><a href="#隐藏Dock上的应用图标" class="headerlink" title="隐藏Dock上的应用图标"></a>隐藏Dock上的应用图标</h3><p>开发statusBar应用，不需要弹出Window界面，可以在<code>Main.storyboard</code>中的<code>Window Controller Scene</code>中取消<code>Is Initial Controller</code>的勾选。</p>
<p>不需要在Dock上出现应用图标，<code>Info.plist</code>中添加Key - Value：<code>Application is agent (UIElement)</code> - <code>YES</code></p>
<h3 id="Window居中"><a href="#Window居中" class="headerlink" title="Window居中"></a>Window居中</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">window.center()<span class="comment">//居中</span></span><br></pre></td></tr></table></figure>

<h3 id="Window的层级关系"><a href="#Window的层级关系" class="headerlink" title="Window的层级关系"></a>Window的层级关系</h3><p>Window有一个<code>level</code>属性，标识Window的层级关系。设置Window的<code>level</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.window?.level = .floating <span class="comment">//Window设置为浮动的</span></span><br></pre></td></tr></table></figure>

<p>还有好多其他层级关系，诸如<code>normal</code>、<code>submenu</code>、<code>tornOffMenu</code>……</p>
<h3 id="启动Window"><a href="#启动Window" class="headerlink" title="启动Window"></a>启动Window</h3><p>弹出一个Window页面，并将其设置为<code>keyWindow</code>（第一响应者的Window窗口）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将addWindowController.window启动，并设置为keyWindow</span></span><br><span class="line">addWindowController.window!.makeKeyAndOrderFront(<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>

<p>有时候该方法只能将Window显示出来，并不能设置为keyWindow，如果是<code>normal</code>层级的Window，Window都不能覆盖其他应用窗口，只会在其他应用窗口下面显示。特别是statusBar应用，在其他应用窗口为<code>keyWindow</code>时，点击工具条上的statusBar，启动Window，无法完成<code>keyWindow</code>设置。</p>
<p>需要调用下面代码，将其他应用都取消<code>keyWindow</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSApp</span>.activate(ignoringOtherApps: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h2 id="NSTextField"><a href="#NSTextField" class="headerlink" title="NSTextField"></a>NSTextField</h2><h3 id="输入时隐藏蓝色边框"><a href="#输入时隐藏蓝色边框" class="headerlink" title="输入时隐藏蓝色边框"></a>输入时隐藏蓝色边框</h3><p><code>xib</code>中在<code>Focus Ring</code>中选择<code>None</code></p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-12-05-10-45-36.png" alt="隐藏蓝色边框"></p>
<p>或者在代码中执行：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">textField.focusRingType = .<span class="keyword">none</span></span><br></pre></td></tr></table></figure>

<h3 id="文本框第一响应者"><a href="#文本框第一响应者" class="headerlink" title="文本框第一响应者"></a>文本框第一响应者</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.window?.makeFirstResponder(textField)<span class="comment">//设置为第一响应者</span></span><br><span class="line"><span class="keyword">self</span>.window?.makeFirstResponder(<span class="literal">nil</span>) <span class="comment">//取消第一响应者</span></span><br></pre></td></tr></table></figure>

<h2 id="获取版本号"><a href="#获取版本号" class="headerlink" title="获取版本号"></a>获取版本号</h2><h3 id="macOS版本号"><a href="#macOS版本号" class="headerlink" title="macOS版本号"></a>macOS版本号</h3><p>macOS10.10及以上，使用下面的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> version = <span class="type">ProcessInfo</span>.processInfo.operatingSystemVersion</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(version.majorVersion).\(version.minorVersion).\(version.patchVersion)"</span>)</span><br></pre></td></tr></table></figure>

<p>还有如下方式（已弃用）</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;CoreServices/CoreServices.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">SInt32</span> major, minor, bugfix;</span><br><span class="line"><span class="type">Gestalt</span>(gestaltSystemVersionMajor, &amp;major);</span><br><span class="line"><span class="type">Gestalt</span>(gestaltSystemVersionMinor, &amp;minor);</span><br><span class="line"><span class="type">Gestalt</span>(gestaltSystemVersionBugFix, &amp;bugfix);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(major).\(minor).\(bugfix)"</span>)</span><br></pre></td></tr></table></figure>

<p>其他方式请见：<a href="https://stackoverflow.com/questions/6492038/find-mac-os-x-version-number-in-objective-c" target="_blank" rel="noopener">查找Mac OS X版本号</a></p>
<h3 id="app版本号"><a href="#app版本号" class="headerlink" title="app版本号"></a>app版本号</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> version = <span class="type">Bundle</span>.main.object(forInfoDictionaryKey: <span class="string">"CFBundleShortVersionString"</span>)</span><br><span class="line"><span class="keyword">let</span> bundle = <span class="type">Bundle</span>.main.object(forInfoDictionaryKey: <span class="string">"CFBundleVersion"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="设置快捷键和关闭退出应用"><a href="#设置快捷键和关闭退出应用" class="headerlink" title="设置快捷键和关闭退出应用"></a>设置快捷键和关闭退出应用</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>xib或storyboard设置快捷键很方便，直接在<code>Key Equivalend</code>输入快捷键即可。</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-12-07-15-42-28.png" alt="设置快捷键"></p>
<h3 id="退出应用"><a href="#退出应用" class="headerlink" title="退出应用"></a>退出应用</h3><p>从<code>action</code>拖线到<code>Application</code>，选择<code>stop:</code>方法即可：</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/WX20171207-154727.png" alt="拖线到Application"></p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-12-07-15-48-21.png" alt="选择stop:方法"></p>
<p>或者拖线到<code>First Responder</code>，选择<code>terminate:</code>方法</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/WX20171207-155548.png" alt="拖线到First Responder"></p>
<p>或者调用代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSApplication</span>.shared().terminate(<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>

<h3 id="关闭应用"><a href="#关闭应用" class="headerlink" title="关闭应用"></a>关闭应用</h3><p>拖线到<code>First Responder</code>，选择<code>performClose:</code>方法</p>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><p>使用<code>NSSharingService</code>调用macOS邮件应用，发送邮件。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> emailService = <span class="type">NSSharingService</span>(named: <span class="type">NSSharingService</span>.<span class="type">Name</span>.composeEmail)!</span><br><span class="line">emailService.recipients = [<span class="string">"i@markmiao.com"</span>]</span><br><span class="line">emailService.subject = <span class="string">"邮件内容"</span></span><br><span class="line"><span class="keyword">if</span> emailService.canPerform(withItems: [<span class="string">"邮件内容"</span>]) &#123;</span><br><span class="line">  emailService.perform(withItems: [<span class="string">"邮件内容"</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"没配置邮件账户"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在浏览器中打开网页"><a href="#在浏览器中打开网页" class="headerlink" title="在浏览器中打开网页"></a>在浏览器中打开网页</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSWorkspace</span>.shared.<span class="keyword">open</span>(<span class="type">URL</span>(string: <span class="string">"http://markmiao.com"</span>)!)</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>macOS开发</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>APP国际化</title>
    <url>/2017/12/01/duoyuyan/</url>
    <content><![CDATA[<p>旧文新录，好多主流app都支持多语言(或者叫本地化/国际化)，有的是自动适应系统语言，有的是用户选择修改。比如微信支持如下语言，可以根据系统自适应，也可以用户更改。</p>
<a id="more"></a>

<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161117-0.png?raw=true" alt="微信支持的语言环境"></p>
<h2 id="创建多语言文件"><a href="#创建多语言文件" class="headerlink" title="创建多语言文件"></a>创建多语言文件</h2><p>在工程中<code>command + n</code>创建文件，选择<code>iOS</code> -&gt; <code>Resource</code> -&gt; <code>Strings File</code>文件，自定义文件名，创建完成。</p>
<h2 id="添加多语言"><a href="#添加多语言" class="headerlink" title="添加多语言"></a>添加多语言</h2><p>选中新创建的多语言文件，展开右侧的侧边栏，在侧边栏里，点击<code>Localization</code>下的<code>Localize...</code>按钮，选择<code>English</code>，点击<code>Localize</code>。</p>
<p>选中工程在<code>PROJECT</code>里面的<code>Localizations</code>，添加语言。</p>
<p>每添加一个，在新建的多语言文件下就会多一个以<code>.strings</code>为后缀名的文件，这就是每个语言对应的语言文件。里面存放的语言文字是以<code>key - value</code>形式保存，每个文件中<code>key</code>是一样的，<code>value</code>对应着该语言下的文字。比如：</p>
<p>中文简体文件<code>File.strings(Chinese(Simplified))</code>里面存放的是：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="string">"text"</span>=<span class="string">"世界，你好。"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>英文文件<code>File.strings(English)</code>里存放的是：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="string">"text"</span>=<span class="string">"hello,world."</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><code>key</code>值保持一致<code>text</code>，<code>value</code>对应该处文本的每种语言翻译。</p>
<h2 id="适应系统语言"><a href="#适应系统语言" class="headerlink" title="适应系统语言"></a>适应系统语言</h2><p>访问语言文件的宏定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define NSLocalizedString(key, comment) \</span><br><span class="line">	    [NSBundle.mainBundle localizedStringForKey:(key) value:@&quot;&quot; table:nil]</span><br><span class="line">#define NSLocalizedStringFromTable(key, tbl, comment) \</span><br><span class="line">	    [NSBundle.mainBundle localizedStringForKey:(key) value:@&quot;&quot; table:(tbl)]</span><br><span class="line">#define NSLocalizedStringFromTableInBundle(key, tbl, bundle, comment) \</span><br><span class="line">	    [bundle localizedStringForKey:(key) value:@&quot;&quot; table:(tbl)]</span><br><span class="line">#define NSLocalizedStringWithDefaultValue(key, tbl, bundle, val, comment) \</span><br><span class="line">	    [bundle localizedStringForKey:(key) value:(val) table:(tbl)]</span><br></pre></td></tr></table></figure>

<p>使用<code>NSLocalizedStringFromTable(key, tbl, comment)</code>宏定义赋值显示多语言的控件，<code>key</code>是多语言文件里的<code>key</code>值，<code>tbl</code>是多语言文件名，<code>comment</code>是注释，可空填nil。使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_label.text &#x3D; NSLocalizedStringFromTable(@&quot;text&quot;, @&quot;File&quot;, nil);</span><br></pre></td></tr></table></figure>

<p>还可以使用宏<code>NSLocalizedString(key, comment)</code>，没有<code>tbl</code>文件名参数，这时工程里的多语言文件名必须为<code>Localizable</code>。</p>
<h2 id="手动设定语言"><a href="#手动设定语言" class="headerlink" title="手动设定语言"></a>手动设定语言</h2><p>语言文件在工程内是以<code>.lproj</code>格式存储的，比如简体中文是<code>zh-Hans.lproj</code>，繁体中文是<code>zh-Hant.lproj</code>，英文是<code>en.lproj</code>。</p>
<p>手动设定语言就是让工程访问哪个文件。要保留app的语言设置，下次打开app还是上次设置好的语言环境。语言设置属于偏好设置，一般用<code>NSUserDefaults</code>存储。</p>
<p>保存环境设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSUserDefaults *userd &#x3D; [NSUserDefaults standardUserDefaults];</span><br><span class="line">[userd setObject:@&quot;zh-Hans&quot; forKey:@&quot;appLanguage&quot;];&#x2F;&#x2F;以简体中文为例</span><br><span class="line">[userd synchronize];</span><br></pre></td></tr></table></figure>

<p>设置语言环境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *lanType &#x3D;[NSString stringWithFormat:@&quot;%@&quot;, [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;appLanguage&quot;]];</span><br><span class="line">NSString *path &#x3D; [[NSBundle mainBundle] pathForResource:lanType ofType:@&quot;lproj&quot;];</span><br><span class="line">NSString *showValue &#x3D; [[NSBundle bundleWithPath:path] localizedStringForKey:@&quot;showTxt&quot; value:nil table:@&quot;File&quot;];</span><br><span class="line">_label.text &#x3D; showValue;</span><br></pre></td></tr></table></figure>

<h2 id="第一次打开app"><a href="#第一次打开app" class="headerlink" title="第一次打开app"></a>第一次打开app</h2><h3 id="手动设置默认语言"><a href="#手动设置默认语言" class="headerlink" title="手动设置默认语言"></a>手动设置默认语言</h3><p>第一次打开app，本地UserDefaults没有存储语言信息，这时可以代码存入一个，后续即可正常访问。</p>
<p>在<code>didFinishLaunchingWithOptions</code>里简单判断一下即可。如果没有，即存入简体中文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSUserDefaults *userd &#x3D; [NSUserDefaults standardUserDefaults];</span><br><span class="line">if (![userd objectForKey:@&quot;appLanguage&quot;]) &#123; </span><br><span class="line">     [userd setObject:@&quot;zh-Hans&quot; forKey:@&quot;appLanguage&quot;];</span><br><span class="line">     [userd synchronize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="显示系统语言设置"><a href="#显示系统语言设置" class="headerlink" title="显示系统语言设置"></a>显示系统语言设置</h3><p>首先要获取系统环境的语言，然后与app支持的语言做比较，如果app支持的语言里有目前系统语言，则显示该语言，如果没有则显示默认语言。</p>
<p>获取系统环境语言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *language &#x3D; [[NSLocale preferredLanguages] objectAtIndex:0];</span><br></pre></td></tr></table></figure>

<p>具体实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSUserDefaults *userd &#x3D; [NSUserDefaults standardUserDefaults];</span><br><span class="line">if (![userd objectForKey:@&quot;appLanguage&quot;]) &#123;&#x2F;&#x2F;如果本地没有设置语言</span><br><span class="line">    NSString *language &#x3D; [[NSLocale preferredLanguages] objectAtIndex:0];&#x2F;&#x2F;获取系统语言环境</span><br><span class="line">    if ([language hasPrefix:@&quot;zh-Hans&quot;]) &#123;&#x2F;&#x2F;简体中文</span><br><span class="line">        [userd setObject:@&quot;zh-Hans&quot; forKey:@&quot;appLanguage&quot;];&#x2F;&#x2F;设置为简体中文</span><br><span class="line">    &#125; else if ([language hasPrefix:@&quot;zh-TW&quot;] || [language hasPrefix:@&quot;zh-HK&quot;] || [language hasPrefix:@&quot;zh-Hant&quot;]) &#123;&#x2F;&#x2F;台湾繁体，香港繁体和繁体</span><br><span class="line">        [userd setObject:@&quot;zh-Hant&quot; forKey:@&quot;appLanguage&quot;];&#x2F;&#x2F;设置为繁体</span><br><span class="line">    &#125; else if ([language hasPrefix:@&quot;en&quot;]) &#123;&#x2F;&#x2F;英文</span><br><span class="line">        [userd setObject:@&quot;en&quot; forKey:@&quot;appLanguage&quot;];&#x2F;&#x2F;设置为英文</span><br><span class="line">    &#125;else&#123;&#x2F;&#x2F;没有支持的语言</span><br><span class="line">        [userd setObject:@&quot;zh-Hans&quot; forKey:@&quot;appLanguage&quot;];&#x2F;&#x2F;设置为简体中文</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="多语言开发的坑"><a href="#多语言开发的坑" class="headerlink" title="多语言开发的坑"></a>多语言开发的坑</h2><p><code>LaunchScreen</code>不支持多语言开发，苹果建议不要对启动页进行多语言开发。在<code>LaunchScreen.strings</code>文件中更改不同语言环境下的字符串，并没有效果。</p>
<p>解决办法：删除这些没用的<code>LaunchScreen.strings</code>文件</p>
<p>每种语言添加一个<code>LaunchScreen.storyboard</code>。比如英文对应：<code>LaunchScreen_en.storyboard</code>，繁体中文对应<code>LaunchScreen_zhHant.storyboard</code>。</p>
<p>在<code>InfoPlish.strings</code>下面对应的语言文件中，分别添加如下字段：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">UILaunchStoryboardName</span> = <span class="string">"LaunchScreen_en"</span><span class="comment">;//英文文件下添加的</span></span><br></pre></td></tr></table></figure>

<p>其实这样做也有局限性，在首次安装启动时能选择正确的语言显示，手动更改手机语言环境，重新打开app则无法显示更改后的语言。—— 在模拟器上测试</p>
<h2 id="storyboard和xib多语言"><a href="#storyboard和xib多语言" class="headerlink" title="storyboard和xib多语言"></a>storyboard和xib多语言</h2><p><code>storyboard</code>和<code>xib</code>多语言只支持跟随系统，不支持手动切换。</p>
<p>选中<code>storyboard</code>或<code>xib</code>文件，在右侧面板的<code>Localization</code>中添加语言文件，语言文件会自动检测该<code>storyboard</code>或<code>xib</code>文件中哪些地方进行多语言化。并在文件中给出类似下面的内容，只需要在相应语言文件中修改<code>&quot;title&quot;</code>文本即可</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/* <span class="keyword">Class</span> = <span class="string">"NSMenuItem"</span>; title = <span class="string">"Item 1"</span>; ObjectID = <span class="string">"sxW-84-y91"</span>; */</span><br><span class="line"><span class="string">"sxW-84-y91.title"</span> = <span class="string">"title"</span>;</span><br></pre></td></tr></table></figure>

<p><code>storyboard</code>和<code>xib</code>的多语言化是根据<code>ObjectID</code>来区分的。</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-12-05-11-49-56.png" alt="ObjectID"></p>
<h3 id="国际化自动脚本"><a href="#国际化自动脚本" class="headerlink" title="国际化自动脚本"></a>国际化自动脚本</h3><p>有一个很大的问题是多语言文本不能实时更新，当你新拖入一个控件，多语言文件中并不会更新该控件的<code>ObjectID</code>。添加脚本，实现编译工程多语言文件实时更新。</p>
<ol>
<li><p>Xcode中添加脚本，脚本地址和添加脚本的方法：<a href="https://github.com/onezens/AutoLocalization" target="_blank" rel="noopener">AutoLocalization</a></p>
</li>
<li><p>终端运行脚本，首先更改脚本文件中的<code>filePath</code></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果在终端运行，注意要修改自己需要国际化的项目文件夹的路径！</span></span><br><span class="line">filePath = <span class="string">'/Users/inspiry/Desktop/work/workCode/XDProject/mremind/mremind'</span></span><br></pre></td></tr></table></figure>

<p>然后在终端中执行Python文件</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">python <span class="module-access"><span class="module"><span class="identifier">AutoGenStrings</span>.</span></span>py</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift学习笔记(1)</title>
    <url>/2017/11/24/rxswiftlearn1/</url>
    <content><![CDATA[<p><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>，是Swift的函数响应式编程框架，以函数为工具，绑定数据联动，数据改变实时反映到结果呈现。这对我来说是一种全新的编程思想，我想去了解，学习。</p>
<p>本文记录了我学习RxSwift的历程，包含遇到的各种问题和我的一些理解。</p>
<a id="more"></a>

<h2 id="运行官方示例"><a href="#运行官方示例" class="headerlink" title="运行官方示例"></a>运行官方示例</h2><p>从github上克隆RxSwift项目</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>@github.com:ReactiveX/RxSwift.git</span><br></pre></td></tr></table></figure>

<p>双击打开<code>Rx.xcworkspace</code>，在工程中选择<code>RxExample-iOS</code>或<code>RxExample-macOS</code>，选择模拟器或真机，运行。</p>
<h2 id="项目集成RxSwift"><a href="#项目集成RxSwift" class="headerlink" title="项目集成RxSwift"></a>项目集成RxSwift</h2><p>将RxSwift集成到项目中，推荐使用CocoaPods的方式，pod版本<code>1.3.1</code>亲测有效：</p>
<ul>
<li><p>创建项目时勾选<code>Include Unit Tests</code>，包含单元测试。</p>
</li>
<li><p>创建<code>Podfile</code>文件，输入如下内容：</p>
</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Podfile</span></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target <span class="string">'工程名字'</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">'RxSwift'</span>,    <span class="string">'~&gt; 4.0'</span></span><br><span class="line">    pod <span class="string">'RxCocoa'</span>,    <span class="string">'~&gt; 4.0'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RxTests 和 RxBlocking 将在单元/集成测试中起到重要作用</span></span><br><span class="line">target <span class="string">'单元测试文件夹名字'</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">'RxBlocking'</span>, <span class="string">'~&gt; 4.0'</span></span><br><span class="line">    pod <span class="string">'RxTest'</span>,     <span class="string">'~&gt; 4.0'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将工程名和单元测试名换成自己的，执行命令：</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pod <span class="keyword">install</span></span><br></pre></td></tr></table></figure>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>问题1. 可能由于CocoaPods版本过低，pod失败，建议更新后重试，执行更新命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo gem <span class="keyword">install</span> cocoapods</span><br></pre></td></tr></table></figure>

<p>问题2. </p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="title">None of your spec sources contain a spec satisfying the dependency:</span> `RxSwift (~&gt; <span class="number">4.0</span>)`.</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">pod <span class="built_in">setup</span></span><br></pre></td></tr></table></figure>

<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>RxSwift的本质是观察者模式，时刻观察者一个序列，当序列达到预定条件，执行某种操作。比如钟表时间是一个序列，当到6点时就下班。时间是一个被观察的序列，6点是预定条件，下班是操作。</p>
<p>Rx中用<code>observable</code>表示变化序列，也就是被观察者。到达预定条件的操作用<code>subscribe</code>表示，被称为订阅。订阅完成之后，要对其进行清理，清理方式是丢掉处理袋<code>DisposeBag</code>中。</p>
<p>这是一个基本的Rx执行流程。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>用RxSwift写一个基本的按钮点击事件。在<code>ViewController</code>中引入头文件：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br></pre></td></tr></table></figure>

<p>在<code>Main.storyboard</code>中拖入按钮，并连线到<code>ViewController</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> button: <span class="type">UIButton!</span></span><br></pre></td></tr></table></figure>

<p>创建全局变量处理袋：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br></pre></td></tr></table></figure>

<p>给按钮添加点击事件：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">button.rx.tap</span><br><span class="line">	.subscribe(onNext: &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"点击"</span>)</span><br><span class="line">	&#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> button: <span class="type">UIButton!</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        button.rx.tap</span><br><span class="line">            .subscribe(onNext: &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"按钮点击"</span>)</span><br><span class="line">            &#125;).disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>demo地址：<a href="https://github.com/mxdios/XDRxSwiftLearn" target="_blank" rel="noopener">XDRxSwiftLearn</a></p>
<p>学习资料：</p>
<p><a href="http://t.swift.gg/d/2-rxswift" target="_blank" rel="noopener">靛青K神出品RxSwift 学习指导索引</a></p>
<p><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/" target="_blank" rel="noopener">RxSwift中文本文档</a></p>
<p><a href="https://darkhandz.com/categories/iOS/Swift/" target="_blank" rel="noopener">RxSwift入门</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>用apiDoc写接口文档</title>
    <url>/2017/11/13/apidoc/</url>
    <content><![CDATA[<p>作为移动端开发，接口文档看得多，写得少。最近对已开发完成的app进行接口文档整理，发现了<a href="http://apidocjs.com/" target="_blank" rel="noopener">apiDoc</a>这款神器。见识到接口文档也可以写的这么高大上，之前用markdown写弱爆了，用word的自杀吧。</p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在安装<code>npm</code>的基础上，执行命令安装apiDoc</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> apidoc -g</span><br></pre></td></tr></table></figure>

<p>安装完成，Mac上便具备apiDoc环境，可以开始写文档了。用apiDoc写接口文档就是写注释，支持各种语言的注释，比如：C#、Go、Java、JavaScript、PHP等等。</p>
<h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p>在任意位置创建存放文档的文件夹，在该文件夹内创建文件<code>apidoc.json</code>，这是apiDoc的配置文件。内容示例如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"文档名称"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"文档描述"</span>,</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"文档网页标题"</span>,</span><br><span class="line">  <span class="attr">"url"</span> : <span class="string">"https://api.github.com/v1"</span>,</span><br><span class="line">  <span class="attr">"sampleUrl"</span>: <span class="string">"https://api.github.com/v1"</span>,</span><br><span class="line">  <span class="attr">"header"</span>: &#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"页眉"</span>,</span><br><span class="line">    <span class="attr">"filename"</span>: <span class="string">"header.md"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"footer"</span>: &#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"页脚"</span>,</span><br><span class="line">    <span class="attr">"filename"</span>: <span class="string">"footer.md"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"template"</span>: &#123;</span><br><span class="line">  	 <span class="attr">"withCompare"</span>: <span class="literal">true</span>,</span><br><span class="line">  	 <span class="attr">"withGenerator"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段解释：</p>
<ul>
<li><code>version</code>：文档版本号。</li>
<li><code>url</code>：域名的主地址，接口中不变的那一块。</li>
<li><code>sampleUrl</code>：测试API方法接口，如果设置，在每个接口下都有一个测试接口的表单。如果不想显示测试表单，需要在接口文档中增加<code>@apiSampleRequest off</code>。</li>
<li><code>header</code>、<code>footer</code>：页眉、页脚，可以不写。里面分别跟着页眉页脚的标题和markdown文件路径，markdown文件和<code>apidoc.json</code>同级目录。</li>
<li><code>withCompare</code>：版本比较，默认开启，<code>withGenerator</code>：生成器，页面底部显示apiDoc，默认开启。</li>
</ul>
<h2 id="创建接口源文档"><a href="#创建接口源文档" class="headerlink" title="创建接口源文档"></a>创建接口源文档</h2><p>我是以<code>js</code>文件写的接口文档，在配置文件<code>apidoc.json</code>统计目录下创建接口文件<code>接口.js</code>，文件名称自定义。</p>
<p>apiDoc最大的亮点是可以版本比较，接口更改过，可以通过接口右侧的版本号选择进行变化比较。</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-11-14-09-36-28.png" alt="版本比较"></p>
<p>这需要在源文档中保留每个历史版本，所以每个接口都可能对应N个历史版本，所以建议一个接口用一个文件。</p>
<h3 id="内容示例"><a href="#内容示例" class="headerlink" title="内容示例"></a>内容示例</h3><p>创建一个<code>编辑资料.js</code>文件，并输入以下内容：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"><span class="meta">@api</span> &#123;POST&#125; users/userinfo.asp [编辑资料]</span><br><span class="line"><span class="meta">@apiVersion</span> <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line"><span class="meta">@apiName</span> userinfo</span><br><span class="line"><span class="meta">@apiGroup</span> users</span><br><span class="line"><span class="meta">@apiSampleRequest</span> off</span><br><span class="line"><span class="meta">@apiDescription</span> 编辑用户资料</span><br><span class="line"></span><br><span class="line"><span class="meta">@apiParam</span> &#123;<span class="built_in">String</span>&#125; userid 用户id</span><br><span class="line"><span class="meta">@apiParam</span> &#123;<span class="built_in">String</span>&#125; username 用户名</span><br><span class="line"><span class="meta">@apiParam</span> &#123;<span class="built_in">String</span>&#125; usersex 性别</span><br><span class="line"><span class="meta">@apiParam</span> &#123;<span class="built_in">String</span>&#125; token token</span><br><span class="line"></span><br><span class="line"><span class="meta">@apiSuccess</span> &#123;Object&#125;   data  对象数据</span><br><span class="line"><span class="meta">@apiSuccess</span> &#123;<span class="built_in">String</span>&#125;   data.userheadimg     头像</span><br><span class="line"><span class="meta">@apiSuccess</span> &#123;<span class="built_in">String</span>&#125;   data.username     用户名</span><br><span class="line"><span class="meta">@apiSuccess</span> &#123;<span class="built_in">String</span>&#125;   data.userphone     手机号</span><br><span class="line"><span class="meta">@apiSuccess</span> &#123;<span class="built_in">String</span>&#125;   data.usersex     性别</span><br><span class="line"><span class="meta">@apiSuccess</span> &#123;<span class="built_in">String</span>&#125;   errorcode  错误码</span><br><span class="line"><span class="meta">@apiSuccess</span> &#123;<span class="built_in">String</span>&#125;   errormessage  信息</span><br><span class="line"></span><br><span class="line"><span class="meta">@apiExample</span> 返回示例</span><br><span class="line">HTTP/<span class="number">1.0</span> <span class="number">0</span> ok</span><br><span class="line">&#123;</span><br><span class="line">    data =     &#123;</span><br><span class="line">        userheadimg = <span class="string">"http://xxxxxxx/api/user/2017/11/13/5EC93450A72741FA92AB4E08D4A96710.jpg"</span>;</span><br><span class="line">        username = markmiao;</span><br><span class="line">        userphone = <span class="number">13000000000</span>;</span><br><span class="line">        usersex = <span class="string">"男"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    errorcode = <span class="number">0</span>;</span><br><span class="line">    errormessage = <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-11-14-09-52-10.png" alt="部署完成后的显示样式"></p>
<h3 id="字段解释"><a href="#字段解释" class="headerlink" title="字段解释"></a>字段解释</h3><p>文档中所有内容是包含在<code>/**   */</code>注释中的，用apiDoc写接口文档就是写注释。</p>
<p><code>@api {POST} users/userinfo.asp [编辑资料]</code> </p>
<ul>
<li>必需，<code>{}</code>内是接口请求方式，GET、POST、PUT等，后面的是接口地址改变部分，会与<code>apidoc.json</code>中的<code>&quot;url&quot;</code>组成完整接口地址显示。<code>[]</code>内是接口标题。</li>
</ul>
<p><code>@apiVersion 0.1.0</code></p>
<ul>
<li>接口版本号，如果接口改变了，需要将上面内容复制一份，修改版本号，修改接口内容，就可以在文档中进行版本内容比对。</li>
</ul>
<p><code>@apiName userinfo</code></p>
<ul>
<li>接口名称，不会显示在文档中，是每个接口的唯一标识，以此来区别接口。</li>
</ul>
<p><code>@apiGroup users</code></p>
<ul>
<li>接口组名，接口可以分组存放，将一类接口放到一组总，组名相同的会被归到一组。</li>
</ul>
<p><code>@apiSampleRequest off</code></p>
<ul>
<li>隐藏测试表单</li>
</ul>
<p><code>@apiDescription 编辑用户资料</code></p>
<ul>
<li>接口描述</li>
</ul>
<p><code>@apiParam {String} userid 用户id</code></p>
<ul>
<li>接口请求参数，<code>{}</code>内是参数类型，后面跟着参数字段名和字段描述。</li>
</ul>
<p><code>@apiSuccess {Object}   data  对象数据</code></p>
<ul>
<li>接口返回值，<code>{}</code>内是返回值类型，后面跟着返回值字段名和字段描述。要想出现返回值表格中缩进的样式，以<code>data.userheadimg</code>这种形式写，<code>userheadimg</code>会在<code>data</code>下面缩进，表示属于<code>data</code>对象中的元素。</li>
</ul>
<p><code>@apiExample 返回示例</code></p>
<ul>
<li>接口返回的数据结构示例</li>
</ul>
<h2 id="生成接口文档"><a href="#生成接口文档" class="headerlink" title="生成接口文档"></a>生成接口文档</h2><p><code>cd</code>到接口文件夹，使用命令：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">apidoc -i . -o <span class="meta">doc</span>/</span><br></pre></td></tr></table></figure>

<p>意思是使用当前文件夹(<code>. 代表当前文件夹</code>)下的所有文件，生成apiDoc文档放到<code>doc/</code>文件夹下。</p>
<p>命令执行完毕，在<code>doc/</code>目录下点击<code>index.html</code>，便可本地浏览用apiDoc写成的接口文档。</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>被苹果爸爸完全碾压的通话记录</title>
    <url>/2017/08/12/talkingtoapple/</url>
    <content><![CDATA[<p>私情是介个样子滴~</p>
<p>最近公司开发了一款APP，是面向大众化的工具类应用。在上架App Store时遇到了阻挠，这对我来说都习以为常了，没有阻挠才奇怪呢。</p>
<a id="more"></a>

<p>这次被拒的原因之前没遇到过，但我大概预测到了：因为APP内容是属于大众化的工具类，核心功能与账户没有直接关系，所以不能在没使用APP之前强制用户登录，违反了App Store审核指南的第5.1.1条。</p>
<p>其实这条规则我也知道，并且知道如果给出了强制用户登录的原因，且原因具有说服力的话是可以这么做的。所以我在提交应用审核的备注里长篇大论的写了一百多字的说明，如此如此这般这般，所以我们采用了用户强制登录机制。</p>
<p>事实证明，这些都是废话，半毛钱说服力都没有。苹果爸爸直接拒绝，第5.1.1条规则打脸甩过来了。我还不死心，将原来备注里一多百字的说明扩充到两百字，详详细细的阐述了我们之所以这么搞，是有原因滴，然后给苹果发过去了。</p>
<p>苹果的回复是：你违反了第5.1.1条规则，后面分别用英文、简体中文、繁体中文说：“如果你不服，留下联系方式，来信砍。”当然苹果爸爸是用很文雅的语言描述了这个意思。我岂能示弱，留就留！</p>
<p>其实之前与苹果开发者客服电话联系过几次，都是些账号或应用的小问题，关于应用审核还是开天辟地头一遭。App Store应用上架审核一直是一个很神秘的机构，他们具体的工作流程和审核方法都鲜为人知。听说这个机构都在美国本土，还听说在中国台湾有个部门负责亚洲市场的应用审核。这些都是我听过的传言。之前与应用审核人员沟通都是用iTunesConnect里面的邮件，或者在Developer里面选择一项“我想干嘛”，给应用审核组发信息。从来没有电话或即时通讯这些快速的沟通途径，我曾经问过苹果开发者客服应用审核组的客服电话是多少，他直接告诉我没有。</p>
<p>没想到这次能电话联系到应用审核组！想想还有些小激动呢。</p>
<p>在我留下联系方式的三天后，也就是今天早上，我遛完狗回来接到了来自美国加利福尼亚圣何塞的电话。我清了清嗓子：“喂，您好。”</p>
<p>“喂，请问是xxx先生吗？”是一位普通话明显生硬的妹子，这样让我有些惊讶。</p>
<p>为了今天的通话，我是做了准备的。在经过友好的问候和审核问题确认之后，我率先发招：“我们的应用是有专门的用户群体，我们需要为每位使用者创建用户ID，便于后期工作展开。”我并没有在第一招就阐明这个后期工作，是希望在后面对方反驳后，再行祭出，已达到首尾呼应，加大谈判力度，我是多么的睿智。</p>
<p>“我们发现您的应用并不具备独立用户群的特性，因此在使用前不能强制用户登录，这违反了我们审核规则的第5.1.1条。”对方明显没get到我说的应用独特性，依旧强调规则。</p>
<p>“是这样的，我们会统计用户登录后使用的工具模板数量，后台大数据分析该用户经常使用哪几类，后期会对该用户着重推送这几类的工具模板。这是为用户提供更好的服务和更优质的体验，这些都是基于用户登录的。”以用户服务为向导，一切都是为了用户，有这么高大上的理由为依据，区区强制用户登录不会有问题啦，都是为了用户体验嘛。我都为我的机智和逻辑思维能力感到赞叹。</p>
<p>“不是不允许用户登录。对于针对普通用户群体的应用，在用户了解应用之前不可以强制用户注册登录，强制搜集用户信息。这违反了我们的应用审核规则。应用必须开放用户未登录时也可以使用部分功能，当使用涉及账号的功能时，再请求用户登录。否则无法上架。”对方如是说。</p>
<p>听不听爸爸的话？不听话你就别想上架。我有点委屈了，完全没考虑过人家的感受嘛。我做了一些妥协：“那这样吧，我们可以提供用户不登录的游客模式，但是只能浏览，不能使用工具模板。在使用时需要登录，这样便于我们后期有针对性的内容推送。”</p>
<p>“不可以，iOS是有本地存储机制的，用户不登录可以将工具模板保存到本地。如果用户想要将使用记录保存到服务器，同步到其他设备，这时可以让用户登录。”我的让步完全没有换来理解，反而换来了她的步步紧逼。太欺负人了！</p>
<p>“那这样一来很大一部分核心功能在用户未登录状态下都能使用，用户的登录欲望会大大降低，这不利于我们后期对用户进行有针对性的工具模板推送。”我还在做最后的挣扎，用户针对性内容是我自以为有力的筹码，我以此一再强调我们后期准备对用户的付出，想换来苹果爸爸的理解。</p>
<p>“当你们应用做得足够好，推广到位，我相信用户是会愿意主动注册登录的。”这分明是胜利后的嘲讽啊！听到她这句话时，我知道我说错话了，败得彻底，再也没有缓和的余地了。怎么让用户愿意登录不是苹果爸爸该考虑的，是我们该考虑的，想以强制用户登录来达到目的，苹果爸爸可不答应。别看她普通话略显生硬，欺负起我来，我竟毫无反驳的余地，稍微挣扎一点即被拍死。</p>
<p>“那好吧，我们对应用修改后再行上架。”我如一只斗败的公鸡，完全没有了开始时的底气和自信。这明显就不是一场势均力敌的谈判，而是爸爸教育儿子的完虐。一开始我就搞错了自己的身份地位，妄图说服苹果爸爸，这哪是胳膊拧大腿，简直是腿毛想扎大动脉，还妄图给苹果放血，太不自量力了。</p>
<p>君不见中国两大微——微信和微博，一个为了打赏，一个为了问答。微信关了iOS客户端的打赏功能，微博妥协了问答付费走内购。</p>
<p>我还是图样图森破。</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>短文</tag>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年用过的Mac</title>
    <url>/2017/08/03/mymacbooks/</url>
    <content><![CDATA[<p>旧文新录，这篇文是去年写的，一直放在简书上。今天把他放到blog里，日后翻出来看看也挺有意思。</p>
<a id="more"></a>

<p>记得是2014年年初接触iOS开发，作为一个资深穷逼，自然没有money去买Mac这种高端电子产品。说实话，在做iOS开发之前，我只在电视上见过MacBook，银白色金属质感，亮白的苹果logo灯，一切尽显高贵奢华。</p>
<p>多渴望拥有一台MacBook，哪怕摸摸也好啊。现在呢，每到秋冬季节，我碰都不愿碰它，静电把我快电出神经质了。但在那时候，MacBook就是我心中的白富美，让我摸摸，我可能会忍不住用舌头去舔它。</p>
<p>我一直认为MacBook是有钱人玩得起的，直到我晒出这张所谓的炫富图时，我发现自己并没有成为有钱人，依然是一个资深穷逼，真应了那句亘古不变的名言：穷玩车、富玩表、屌丝玩电脑。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG99.jpeg?raw=true" alt="炫富图"></p>
<h2 id="ThinkPad上装的黑苹果"><a href="#ThinkPad上装的黑苹果" class="headerlink" title="ThinkPad上装的黑苹果"></a>ThinkPad上装的黑苹果</h2><p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/20110913030805516.jpg?raw=true" alt="小黑本"></p>
<p>没有白富美的MacBook，但我有一台跟了我三年的小黑本ThinkPad E40。不能体验苹果本，体验一把苹果系统也不错，狠(fēi)下(cháng)心(yú)来(kuài)的给小黑本装黑苹果。</p>
<p>不知是我的小黑本菜，还是我菜，什么五国语言错误、驱动安装失败全让我遇到了，最后去中关村花了100大洋找人安装的(看起来还是我菜)。安装了OS X 10.9，这是Mac系统最后一代拟物化系统，10.10开始扁平化。此时的iOS7已经开始扁平化了。用黑苹果最大的问题就是卡，运行Xcode的时候简直卡的要死。</p>
<p>垂垂老矣的小黑本，本来运行win7都有些卡，现在硬塞进去一套Mac OS，还是Mac OS和Windows并存双系统，每次启动选择系统启动项。小黑本跟了我也算是遇人不淑，老了老了还被我这么糟蹋。</p>
<p>黑苹果玩了差不多半年，在我已经用iMac的时候。有一天晚上开着小黑本里的黑苹果系统，用迅雷下电影（强调是正经电影），勾选了迅雷上的下载完毕自动关机。以前也常这么搞，可见小黑本真是遇人不淑。第二天，无论如何都开不了机了，小黑本死了……</p>
<p>我眼前仿佛闪过小黑本跟我在一起的一幕幕，陪我上大学，陪我敲代码，陪我在宿舍看片，陪我在教室下电影……我的眼睛模糊了，终于忍不住了，我操！可以买MacBook了！</p>
<p>其实我还是想挽救小黑本的，想重装系统只安装一个win7，平时浏览网页，看看电影就行了，让它能安度晚年，寿终正寝。去ThinkPad售后服务点，当然保修期肯定过了，我想自费修一下也行。“主板坏了，修修1200，换一个1800”，其实让小黑本就此长眠，也不失为一种壮烈。</p>
<p>后来小黑本扔回了老家，老爸花了200块修了一下，能开机了。还没等我给它重装系统，在某次关机之后再也没打开过，就此长眠吃土。</p>
<h2 id="2012款iMac-21-5英寸"><a href="#2012款iMac-21-5英寸" class="headerlink" title="2012款iMac 21.5英寸"></a>2012款iMac 21.5英寸</h2><p>iMac是我上班后用的第一台Mac，就是第一张图中中间的那台iMac，其实当时的我是强烈期望公司给我配一台MacBook的。经过这几年频繁的换Mac电脑，我觉得就单纯开发体验来说，还是iMac用着舒服，想体验一把27英寸 Retina 5K屏的iMac开发，可惜目前为止还没有体验过。</p>
<p>之前对一体机没什么好感，我觉得要么用笔记本，要么用台式机，一体机算怎么回事？iMac改变了我的看法，银白色金属质感，深黑色屏幕边框，有笔记本只插一根电源线的简约，又有台式机大屏的酸爽。相比这些，我最爱的还是配备的原装Mac鼠标和Mac键盘。</p>
<p>Mac鼠标配备Mac系统的平面触摸、页面滑动、多点触碰，以及反Windows鼠标的页面滑动方向，甚至电池安装正负极同向都是这么的反正统。但是，用起来很爽。Mac键盘和MacBook上键盘一样，除了键盘灯。Mac键盘和普通键盘差别不大，除了独有的Command键。感觉Mac键盘用硬币拧开的电池盖设计很赞。</p>
<p>还有鼠标键盘与iMac的蓝牙连接，没有USB线的纠缠。我曾试验过用鼠标关了iMac的蓝牙，一瞬间鼠标键盘失效了，没办法控制iMac。那怎么打开蓝牙啊？有同事建议我找个普通USB鼠标连上打开蓝牙，其实用不着，过一会iMac会自动开启蓝牙，连接鼠标键盘。还发现当用普通USB鼠标连接Mac的时候，Mac里所有滚动条会一直显示，而用Mac鼠标时，滚动条会隐藏。Mac系统是有多讨厌普通鼠标？</p>
<p>Mac鼠标键盘唯一感觉不好的是电池用的太快，键盘鼠标各两节带聚能环的南孚电池，显然聚能环也抵挡不了压榨，电池用不了多久就用光了，键盘还好些，鼠标太费电。后来Apple发布了可充电鼠标键盘，键盘充电还好，鼠标充电的时候总感觉怪怪的，像是把充电线插入了不可描述的部位。</p>
<h2 id="MacBook-Pro-15英寸"><a href="#MacBook-Pro-15英寸" class="headerlink" title="MacBook Pro 15英寸"></a>MacBook Pro 15英寸</h2><p>2014年圣诞节前，购买了一台15英寸的MacBook Pro，就是第一张图中左侧的那台MacBook。也圆了我多年想拥有一台MacBook的愿望。买这台MacBook还得感谢下产品经理猫哥，以8折优惠价拿下了14288的MacBook Pro。</p>
<p>记得当时买了没多久就出了触摸板Touch ID功能和蝴蝶键盘的MacBook，对于电子产品，我从来都没有买了后出了新款会感觉亏了。就像2011年买的ThinkPad E40，当时也算中高配，现在成渣渣了。穷逼永远追不上电子产品的换代速度，索性坦然面对。要不然现在都出TouchBar的MacBook了，我能怎么样？</p>
<p>当时公司还是给我配备了iMac，但是刚入手MacBook的那种喜悦兴奋感，以至于让我每天背着4斤多的电脑从昌平到国贸上班，那台iMac当显示器用了。当时我还有个iPad Air，每天挤地铁拿着9.7英寸的iPad Air看&lt;行尸走肉&gt;，背上还有个4斤多的MacBook，现在想想真傻逼。以至于现在我十分抵触背电脑，给我电脑补助我也不背自己电脑上下班(其实还是给少了，一个月给我两千块，iMac我也背)。</p>
<p>MacBook用着虽然没有iMac大屏的酸爽(由于当时有台iMac当显示屏，完全没有MacBook小屏幕的憋屈感)，但是功能强大的触摸板，柔光闪亮的键盘灯，白光的苹果logo灯，和上就走、打开就用的便捷还是让我一用就倾心。2015年出的MacBook Air取消了logo灯，2016年出的MacBook Pro依旧没有了logo灯，白光的苹果logo灯也成了历史。MacBook越来越薄，删减的东西也越来越多，光驱没了，网线口没了，呼吸灯没了，logo灯没了，USB没了，功能键没了……以后会不会变为光影键盘和触摸板合一，无线充电取消全部接口，可以折叠放在皮鼓兜里呢？</p>
<p>入手MacBook后，是我用苹果产品最多的时候，MacBook Pro是主要编程工具，iMac作为显示器在旁边辅助，iPad Air上下班看视频和做测试，用了多年的Android机也丢掉换成iPhone6了，还有一台iPhone5s测试机。当时作为一个没有女朋友的屌丝，这些奢华的设备配置填补了我内心的小空虚。然而，一切并没有什么卵用。</p>
<p>后来我用一台2011年的Mac mini也没感觉有什么心理落差，我还是一个程序猿，还是敲代码。区别的是我有女朋友了，啊哈哈哈哈……</p>
<h2 id="MacBook-Pro-13英寸"><a href="#MacBook-Pro-13英寸" class="headerlink" title="MacBook Pro 13英寸"></a>MacBook Pro 13英寸</h2><p>后来离职去了另一家公司，当时我已经不愿背电脑上下班了。公司给我配了一台全新的13英寸MacBook Pro，之所以说全新，是因为包装都是我拆的。当时对电脑没有太大要求，给我台mini也可以(黑苹果就算了吧)，新旧就更不会太在乎了。好在我已经坦然了，上家公司那种Apple设备环绕的情景直至现在都没再现过，而且配备的设备越来越老旧，越来越次。</p>
<p>用习惯了15英寸，用13英寸感觉好小。Xcode全屏都感觉放不开，而且公司没有配备外接显示器，这就有点憋屈的尴尬了。好在Mac系统可以加多个桌面，切换起来也十分方便。其实编程有个外接显示器真挺重要，至少我看原型图不用切换桌面。</p>
<p>13英寸跟15英寸的一大设计区别就是音响位置，15英寸的在键盘两边，13英寸的在电脑底部。尴尬的是躺床上看电影，把电脑放腿上容易堵住音响口。</p>
<p>自我感觉，敲代码和商务办公来说MacBook比普通Windows好些。有人吐槽Mac的office软件兼容垃圾，可应用软件少，浏览器兼容差，Mac AppStore软件价格昂贵等等。其实都是事在人为，有钱的买正版，没钱的找破解版，Mac软件并不少，少的是你知道的搜索渠道。但对于那些只支持IE浏览器而你又不得不用的网站(比如某些官方考试报名网站)，我只能说：你个垃圾！说完之后默默地打开虚拟机用IE登录。不得不说Mac的系统性能体验，操作方式的独特化简约，超强的续航能力，这些都是选择Mac的原因，当然还有绝不可忽视的装逼体验。</p>
<p>买iPhone玩游戏是上策，iOS的游戏数量、质量、游戏体验都很不错。但是买Mac玩游戏那可算是失策了，Mac AppStore上的游戏不仅少而且贵，好多单机没有Mac版，一些网游都没有Mac版支持。我电脑游戏玩的少，这方面没什么体验。记得我同学当时换了MacBook玩DNF，没有国服只能玩美服，后来为了玩国服怒装虚拟机。</p>
<h2 id="2011款Mac-mini"><a href="#2011款Mac-mini" class="headerlink" title="2011款Mac mini"></a>2011款Mac mini</h2><p>那台13英寸的MacBook Pro我用了没多久就不用了，因为我离职了，公司不让带走，我就没再用。新公司如愿以偿的给我配了台mini(所以说flag不能随便立)，值得称赞的是显示器比较大，是28英寸的(我也是能习惯性的从不幸中找到幸运)。</p>
<p>第一次用mini不习惯，一时间差点没找到开机键在哪。还有隐藏在后面的各种插孔，每次连接手机数据线USB插口转三次才能摸索着插进去。插耳机总是不小心插进旁边的话筒插孔里，而且耳机孔太紧，位置又在后面，手滑的话根本拔不出来。我还比较庆幸，mini电源插头是国标的，我一个同事用的mini的电源线是英标插头，那硕大的插头，四四方方铜脚，都快把插排撑裂了才插上。</p>
<p>开始连接mini的键盘是普通键盘，没有command键只能用Ctrl，以前是拇指按command配合使用快捷键，现在小指按Ctrl配合使用快捷键，每次都是按完之后发现不对再改。后来实在受不了，在公司找了一个Mac键盘替换了。但是鼠标自始至终都是普通鼠标，不但所有的页面滚动条都一直显示，而且没办法用鼠标快速切换桌面或排列显示桌面所有打开应用，只能control + 方向键。还有一种方法设置桌面触发角，将鼠标移动到桌面某个角，会实现某种操作，这个太不方便了，鼠标总会不小心的移动到某个角落触发某个操作。</p>
<h2 id="2010款MacBook-Pro-17英寸"><a href="#2010款MacBook-Pro-17英寸" class="headerlink" title="2010款MacBook Pro 17英寸"></a>2010款MacBook Pro 17英寸</h2><p>后来因为工作需要，公司台式机统一换本。我换了台17英寸的MacBook Pro，这是我第一次见17英寸的MacBook Pro，有光驱，有呼吸灯，有网线接口，那么厚、那么大、那么重。这台17英寸的MacBook Pro是2010年年末出的，当时售价1.7万，有6斤重，现在已经停产了。给我的时候还没有硬盘，开了半天没开开，我以为坏了。安了个硬盘装了系统，用起来还是蛮不错的。</p>
<p>天真的我以为不用自己电脑就不用背电脑上下班了，现实给了我一个大耳光，醒醒吧，背着公司的本上下班，回家随叫随到敲代码！我就呵呵了，4斤的不想背，现在让我背6斤的，而且没有电脑补贴，因为你没用自己的本。好在上班离家近，不用挤地铁。但是每天背上贴着一个6斤的金属板蹬自行车，到公司内裤都湿了，时间一长说出大天来我也不想背了。再说了，我家里有本，公司都用git，哪个本不能敲代码，把本当爹了？天天背着上下班。</p>
<p>17英寸的MacBook分辨率比Retina屏的小，但是17英寸的MacBook上显示的内容比较小，这样一来屏幕中容纳的内容就比较多。虽然17英寸的屏幕不是很大(在笔记本里还是很大的)，但是用起来感觉不到憋屈，内容显示还是很宽松的。</p>
<p>虽然这个MacBook厚重些，但是相比用mini，感觉用本还是好点。毕竟键盘+触摸板比键盘+普通鼠标体验强太多了。MacBook的光驱是吸入式光驱，键盘右上角的键是推出光驱用的，开机键独立在右上角金属板上，后来去掉了光驱，开机键也取代了推出光驱键的位置。</p>
<p>虽然有光驱，但是我从来没用过，即便是我第一台电脑ThinkPad上的光驱也没用过几次。后来的MacBook去掉了光驱和网线口可谓明智之举，现在光盘几乎退出历史舞台，无线网遍布世界。为啥呼吸灯也去掉了？睡眠的时候一闪一闪挺有睡眠的样子的。</p>
<p>2016款MacBook去掉了USB3和Thunderbolt2接口，全换成了USB-C接口，不知道这次大刀阔斧的改进，在未来会有什么样的历史评价。但是现在最新款iPhone7不能直接连接到MacBook上，这到底几个意思？</p>
<h2 id="2011款MacBook-Pro-13英寸"><a href="#2011款MacBook-Pro-13英寸" class="headerlink" title="2011款MacBook Pro 13英寸"></a>2011款MacBook Pro 13英寸</h2><p>后来因为工作原因，17英寸MacBook Pro换成了13英寸的MacBook Pro。虽然尺寸变小了，但是厚度没变，因为这款MacBook还是2011款带光驱的。</p>
<p>iOS开发环境没有什么可配置的，安装一个Xcode基本就搞定一多半了。麻烦的是证书配置，要想真机测试，打包发布应用，必须经历一系列的证书配置。像我这种电脑里有3+以上个开发者账号，个人企业公司级全有，配置起来下一步下一步下一步，真是烦透了。可喜的是在换电脑的同时，硬盘也换了。我把17英寸MacBook上的硬盘拆下来，装在了13英寸的MacBook上了，亲测证明，系统还是原来的系统，证书还是原来的配方，一切都不用重新配置。只是在打包app的时候验证一下开发者账号密码即可。</p>
<p>细数这些年用过的Mac，几经变换，从未重复用过一款。落魄时用过黑苹果、Mac mini，辉煌时桌子上摆过苹果N件套，堂堂iMac当显示器用。一切皆浮云，我依旧是个玩电脑的穷逼程序猿。一直以来陪伴我的是15英寸那款MacBook Pro(因为是我掏腰包买的)，以前陪着我，现在陪着我，将来还会陪着我，我不会像糟蹋小黑本那样糟蹋你，其他的都是工具，而你是我朋友(自己掏钱买的就是不一样)。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>从去年写这篇文章到现在，我一直用着这款13英寸的MacBook Pro，区别的是外接了一台Dell显示器，外加媳妇送的HHKB键盘和Magic Mouse 2鼠标。这台老破小Mac连接这些外设也算梅开二度、老木逢春。</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS应用上架被拒</title>
    <url>/2017/07/27/macosapprejected/</url>
    <content><![CDATA[<p>这是我开发的第一个macOS客户端，名字为<a href="http://markmiao.com/2017/07/26/stenonote/">速记</a>。是用swift3.0，面向Google开发，磕磕绊绊的写完这一两个界面，相比预想功能大概实现了50%，也算完整，没有完成到预想效果，便按耐不住上传App Store，日后迭代呗。</p>
<a id="more"></a>

<p>结果昨天上传，今天早上就被苹果爸爸拒了。一看被拒理由，哐哐哐列了四五条之多，一下子有点懵。详细看过之后，发现这些问题还是蛮不错的，都是我没注意到的，特此记录下来：</p>
<h2 id="问题1：应用程序的完整性"><a href="#问题1：应用程序的完整性" class="headerlink" title="问题1：应用程序的完整性"></a>问题1：应用程序的完整性</h2><p>问题描述：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">Specifically, the app shows <span class="literal">no</span> response <span class="keyword">when</span> click <span class="literal">on</span> the menubar extra icon.</span><br></pre></td></tr></table></figure>

<p>这个问题拒的我完全没脾气，因为点击一个按钮没有任何反应，苹果据此认为该应用没做完，我竟毫无反驳之力。</p>
<p>情况是这样的：这个<code>extra icon</code>，在有选中内容时，点击会弹出NSPopover，未选中内容时，点击没有任何反应，所以程序不完整。记住即便是空内容也要做提示处理！</p>
<h2 id="问题2：应用程序名称不统一"><a href="#问题2：应用程序名称不统一" class="headerlink" title="问题2：应用程序名称不统一"></a>问题2：应用程序名称不统一</h2><p>问题描述：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">We noticed that your app <span class="type">name</span> <span class="keyword">to</span> be displayed <span class="keyword">on</span> the App Store does <span class="keyword">not</span> sufficiently match the <span class="type">name</span> <span class="keyword">of</span> the app displayed <span class="keyword">when</span> installed <span class="keyword">on</span> macOS.</span><br><span class="line"></span><br><span class="line">iTunes <span class="keyword">Connect</span> <span class="type">Name</span>: 速记</span><br><span class="line">App <span class="type">Name</span> <span class="keyword">when</span> Installed: StenoNote</span><br><span class="line">App <span class="type">Name</span> <span class="keyword">when</span> Launched: 速记</span><br><span class="line">App <span class="type">Name</span> <span class="keyword">in</span> About/Hide/Quit Menu: 速记</span><br></pre></td></tr></table></figure>

<p>在iOS开发中，工程名和应用名是完全不同的，应用名可以在<code>Info.plist</code>里的<code>Bundle display name</code>中自定义。但是macOS不同，即便是在<code>Bundle display name</code>自定义了名字，在Dock上鼠标悬浮到应用上时和Launchpad里应用图标下显示的名字仍然是工程名。还有在Mac左上角苹果图标旁边的应用名也是工程名，即便是你在xib或storyboard里改了这里的文字，这里依旧不会变。</p>
<p>我并不知道如何修改这些名字，后来在<code>Info.plist</code>里修改了<code>Bundle name</code>，Mac左上角苹果图标旁边的应用名改变了，但是Dock上和Launchpad里面的没有变化。提交应用之后，这也成了被拒理由之一。</p>
<p>解决办法当然是统一应用名称：</p>
<p>在<code>TARGETS -&gt; Build Settings -&gt; Product Name</code>这里面自定义应用名称。</p>
<h2 id="问题3：权限配置问题"><a href="#问题3：权限配置问题" class="headerlink" title="问题3：权限配置问题"></a>问题3：权限配置问题</h2><p>问题描述：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Your app uses one or more entitlements which <span class="keyword">do</span> <span class="keyword">not</span> have matching functionality <span class="keyword">within</span> the app. Apps should have <span class="keyword">only</span> the <span class="keyword">minimum</span> <span class="keyword">set</span> <span class="keyword">of</span> entitlements necessary <span class="keyword">for</span> the app <span class="keyword">to</span> <span class="keyword">function</span> properly. Please remove <span class="keyword">all</span> entitlements that <span class="keyword">are</span> <span class="keyword">not</span> needed <span class="keyword">by</span> your app <span class="keyword">and</span> submit an <span class="keyword">updated</span> <span class="built_in">binary</span> <span class="keyword">for</span> review, <span class="keyword">including</span> the <span class="keyword">following</span>:</span><br><span class="line"></span><br><span class="line">com.apple.security.files.user-selected.read-<span class="keyword">only</span></span><br></pre></td></tr></table></figure>

<p>macOS客户端要想上架App Store，必须开启<code>App Sandbox</code>功能。这里面牵扯到一些权限配置：网络访问、硬件资源、联系人、定位、日历，还有文件和目录的访问。应用中不需要的权限一定不要打开，不然就会以上述理由被拒。</p>
<p>我不知道什么时候开启了<code>User Selected File</code>为<code>Read Only</code>，被拒了，马上改为<code>None</code>。</p>
<h2 id="问题4：黑暗模式"><a href="#问题4：黑暗模式" class="headerlink" title="问题4：黑暗模式"></a>问题4：黑暗模式</h2><p>问题描述：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">The<span class="built_in"> user interface </span>of your app is <span class="keyword">not</span> consistent with the macOS Human<span class="built_in"> Interface </span>Guidelines. Specifically:</span><br><span class="line"></span><br><span class="line">We found that when Dark Mode is enabled, the menu bar extra icons aren<span class="string">'t visible.</span></span><br></pre></td></tr></table></figure>

<p>这个问题略惊，之前恍惚听过黑暗模式，从来没用过。启动黑暗模式是在：系统偏好设置 -&gt; 通用 -&gt; 勾选使用暗色菜单和Dock</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-07-27-17-20-20.png" alt="设置黑暗模式"></p>
<p>黑暗模式下Dock和上方工具条都变为黑色半透明，工具条上的图标齐刷刷变为白色，而我的应用图标不见了…不见了…见了…了…</p>
<p>在stackoverflow找到一个问题解答：<a href="https://stackoverflow.com/questions/25379525/how-to-detect-dark-mode-in-yosemite-to-change-the-status-bar-menu-icon" target="_blank" rel="noopener">How to detect dark mode in Yosemite to change the status bar menu icon</a>。</p>
<p>设置分布式观察者，获取Mac模式变化：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DistributedNotificationCenter</span>.<span class="keyword">default</span>().addObserver(<span class="keyword">self</span>, selector: #selector(changeStatusBarImage(not:)), name: <span class="type">NSNotification</span>.<span class="type">Name</span>(rawValue: <span class="string">"AppleInterfaceThemeChangedNotification"</span>), object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>每次更改模式都会调用通知方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeStatusBarImage</span><span class="params">(not: Notification)</span></span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"change"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以使用下面方法获取当前Mac的模式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dict = <span class="type">UserDefaults</span>.standard.persistentDomain(forName: <span class="type">UserDefaults</span>.globalDomain)</span><br><span class="line"><span class="keyword">let</span> style = dict?[<span class="string">"AppleInterfaceStyle"</span>]</span><br><span class="line"><span class="built_in">print</span>(style)<span class="comment">//是暗黑模式下style打印Optional(Dark)，普通模式下打印nil</span></span><br></pre></td></tr></table></figure>

<p>stackoverflow问题解答中有一个外链，说明了如果不是根据模式切换去更换复杂图片的话，仅是白变黑，黑变白，仅需要如下几行代码设置<code>NSStatusBar</code>的图片即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> image:<span class="type">NSImage</span> = <span class="type">NSImage</span>(named: <span class="string">"图片名称"</span>)!</span><br><span class="line">image.isTemplate = <span class="literal">true</span></span><br><span class="line">item.button?.image = image</span><br></pre></td></tr></table></figure>

<h2 id="问题5：无菜单重新打开主窗口"><a href="#问题5：无菜单重新打开主窗口" class="headerlink" title="问题5：无菜单重新打开主窗口"></a>问题5：无菜单重新打开主窗口</h2><p>问题描述：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">The<span class="built_in"> user interface </span>of your app is <span class="keyword">not</span> consistent with the macOS Human<span class="built_in"> Interface </span>Guidelines.</span><br><span class="line"></span><br><span class="line">Specifically, we found that when the<span class="built_in"> user </span>closes the main application window there is <span class="literal">no</span> menu item <span class="keyword">to</span> re-open it.</span><br></pre></td></tr></table></figure>

<p>对于这个问题我是存在异议的，在点击关闭按钮后主窗口退出，点击Dock上的应用图标是可以唤起应用主窗口的。但是文中强调<code>menu item</code>，难道必须右键菜单里需要加上打开客户端主窗口的操作？</p>
<p>暂且在右键菜单里添加了打开客户端主窗口的功能：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDockMenu</span><span class="params">(<span class="number">_</span> sender: NSApplication)</span></span> -&gt; <span class="type">NSMenu?</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> menu = <span class="type">NSMenu</span>()</span><br><span class="line">   <span class="keyword">let</span> menuItem = <span class="type">NSMenuItem</span>(title: <span class="string">"打开速记"</span>, action: #selector(openNoteViewController), keyEquivalent: <span class="string">"O"</span>)</span><br><span class="line">   menu.addItem(menuItem)</span><br><span class="line">   <span class="keyword">return</span> menu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写这篇文章的时候，应用经过上述修改再一次提交审核，等待审核中，期待审核结果……</p>
<hr>
<p>后面的审核历程颇有些戏剧性，当晚审核被拒，被拒原因是上面的<code>问题1</code>和<code>问题5</code>，说是在macOS10.12.6系统版本下出现的问题，这是当前macOS最新系统版本，我也是在此系统版本下开发并修改上述问题的。</p>
<p>本着苹果爸爸不欺我的崇拜之心，经过五分钟的测试+Google，最终还是没发现问题所在。十分钟后我反馈了我的疑问，第二天苹果给我的回复是：我们重新测试了你的应用，发现在macOS10.12.6上没有问题，问题是在macOS10.10.5上发现的，你的应用最低系统支持是10.10，所以要解决10.10.5上的问题。</p>
<p>有理有据，合情合理。</p>
<p>10.10.5上有问题，那就不支持10.10了，最低系统版本改为10.11，上架成功。</p>
]]></content>
      <categories>
        <category>macOS开发</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>速记 - 快速记录每一段文字</title>
    <url>/2017/07/26/stenonote/</url>
    <content><![CDATA[<p>[速记] 是一款可以在工具栏快速记录一段文字的应用。也支持在应用窗口添加、删除、编辑记录的文本。我们支持的是迅速、便捷、一触即达，比便签更迅速，比日记更简约。</p>
<a id="more"></a>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20170726-161903.png" alt="速记 - 快速记录每一段文字"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>点击下载<a href="https://itunes.apple.com/cn/app/id1263819789?mt=12" target="_blank" rel="noopener">速记 - 快速记录每一段文字</a>，在Mac App Store中安装速记</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>在工具栏上点击速记标识，可迅速弹出文本输入框，可快速记录文本内容。</li>
<li>在应用主窗口可快速编辑文本内容，无需保存操作，应用会自动存储更改后的内容。</li>
<li>在应用主窗口可点击加号按钮，快速创建一条记录，输入内容快速便捷。</li>
<li>强大的搜索功能，会实时检索搜索词组，快速将结果反馈到速记列表中。</li>
<li>速记信息，点击应用主窗口右上角按钮，可快速查看本条信息的字数及创建时间。</li>
</ul>
<h2 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h2><p>如果您对[速记]有什么意见或建议，请联系<a href="mailto:i@markmiao.com">i@markmiao.com</a> 我们会认真对待每一次反馈，将[速记]做的更好。</p>
<p>如果您喜欢该应用，请在App Store留下宝贵的评论。</p>
]]></content>
      <categories>
        <category>macOS开发</category>
      </categories>
      <tags>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title>ipa重签名</title>
    <url>/2017/07/26/ipachongqianming/</url>
    <content><![CDATA[<p>在工作中分发内测应用是经常遇见的，常见的方式有：TestFlight，用企业级开发者账号，搜集UDID打包等方式，每种方式都各有利弊。</p>
<p>由于公司有企业级开发者账号，所以平常应用内测比较简单：直接拿企业级账号打包.ipa，将.ipa发布到内测平台（比如<a href="https://www.pgyer.com" target="_blank" rel="noopener">蒲公英</a>，<a href="https://fir.im/" target="_blank" rel="noopener">fir.im</a>），测试人员直接下载安装就可，只是第一次需要信任一下企业级证书。</p>
<a id="more"></a>

<p>在工作中，有时候我们需要分发某个app的.ipa包，并没有改app的源码，无法用自己的账号打包。这时就用到了重签名。</p>
<p>其实ipa重签名的应用场景很多，比如App Store上的付费应用，可以使用自己的开发者账号，其.ipa包重新签名，就可以安装了。各大app助手平台就是这么做的。注意直接从App Store下载的应用是加壳的，无法直接重新签名，必须砸壳。<a href="http://iosre.com/" target="_blank" rel="noopener">iOSRE逆向</a></p>
<h2 id="iReSign"><a href="#iReSign" class="headerlink" title="iReSign"></a>iReSign</h2><p><a href="https://github.com/maciekish/iReSign" target="_blank" rel="noopener">iReSign</a>是一个重签名工具</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-07-25-19-21-04.png" alt="iReSign"></p>
<p>操作步骤：</p>
<ol>
<li>选择.ipa包的路径</li>
<li>选择<code>embedded.mobileprovision</code>文件路径。<code>embedded.mobileprovision</code>是用于打包的配置文件<code>Provisioning Profiles</code>。可以直接在<code>Certificates, Identifiers &amp; Profiles</code>中下载，注意下载之后需要将名字设置为<code>embedded.mobileprovision</code>。也可以在之前用该文件打包过的.ipa中找：解压.ipa -&gt; Payload -&gt; xx.app显示包内容 -&gt; <code>embedded.mobileprovision</code></li>
<li>网上有资料说entitlements.plist不需要填写。我试过不填写或填写，我按照本文<a href="http://www.olinone.com/?p=198" target="_blank" rel="noopener">iOS证书及ipa包重签名探究</a>的方式写的.plist文件。</li>
<li>选中修改ID，填写修改的appid</li>
<li>选择证书，下拉列表会显示mac上有的证书。</li>
<li>点击重新签名！</li>
</ol>
<p>结果是失败了。</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/6111501034232_.pic.jpg" alt="iResign运行结果"></p>
<p>错误信息如下，可以查看该错误的<a href="https://github.com/maciekish/iReSign/issues/99" target="_blank" rel="noopener">IResign上的issues</a></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[General] <span class="builtin-name">Error</span> <span class="attribute">Domain</span>=NSCocoaErrorDomain <span class="attribute">Code</span>=3840 <span class="string">"Unexpected character s at line 1"</span> UserInfo=&#123;<span class="attribute">NSDebugDescription</span>=Unexpected character s at line 1, <span class="attribute">kCFPropertyListOldStyleParsingError</span>=Error <span class="attribute">Domain</span>=NSCocoaErrorDomain <span class="attribute">Code</span>=3840 <span class="string">"Unexpected ';' or '=' after key at line 1"</span> UserInfo=&#123;<span class="attribute">NSDebugDescription</span>=Unexpected <span class="string">';'</span> <span class="keyword">or</span> <span class="string">'='</span> after key at line 1&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>另外还有一个重签名工具：<a href="https://github.com/DanTheMan827/ios-app-signer" target="_blank" rel="noopener">ios-app-signer</a></p>
<p><a href="http://www.iosugar.com/2017/04/10/Practice-articles-iOS-application-re-signature/" target="_blank" rel="noopener">实践篇：iOS 应用重签名(上)</a>这篇文章介绍了entitlement文件如何写，ios-app-signer的使用。我没有测试该方法是否可行。</p>
<h2 id="使用sigh脚本"><a href="#使用sigh脚本" class="headerlink" title="使用sigh脚本"></a>使用sigh脚本</h2><p>在iReSign失败后，我在网上找到使用sigh脚本的方式来重签名。</p>
<ol>
<li>安装神器brew，没有安装的看这里：<a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a></li>
<li>安装ruby，命令：<code>brew install ruby</code></li>
<li>安装sigh，命令：<code>sudo gem install sigh</code>，过程比较漫长。</li>
</ol>
<p>安装sigh脚本后，开始进行重签名，步骤如下</p>
<ol>
<li>在终端输入<code>sigh resign</code>，回车</li>
<li>把要签名的ipa文件拖到窗口上，回车</li>
<li>填写用来签名的证书名，回车</li>
<li>把项目的配置文件embedded.mobileprovision文件拖到窗口上，回车</li>
<li>好了，resign脚本会自动更改bundel id，签名并重新打包。</li>
</ol>
<p>注意ipa包名不要有中文。如果应用有多个targetes无法用上述方式重签名。参考文章：<a href="http://www.jianshu.com/p/3f57d51f770a" target="_blank" rel="noopener">iOS的ipa重签名</a></p>
<p>我按照如上步骤操作，成功使用企业级证书打包，上传到蒲公英内测平台上，也显示的是企业级应用，但是无法安装，提醒无法下载app，我手机上没有从App Store上下载安装该应用，排除了无法覆盖问题。</p>
<p>iOS9以后，企业级应用不会出现信任按钮，如果ipa包和网页的<code>bundle ID</code>不匹配，就无法安装。在iOS9之前是没有检测的。详情见大神iOS程序犭袁的文章<a href="https://github.com/ChenYilong/iOS9AdaptationTips#3%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%88%86%E5%8F%91" target="_blank" rel="noopener">ios9适配系列教程</a></p>
<h2 id="我操作成功的办法"><a href="#我操作成功的办法" class="headerlink" title="我操作成功的办法"></a>我操作成功的办法</h2><p>经过了无数次测试sigh脚本签名方式，最后即将放弃的时刻成功了。</p>
<ol>
<li>将需要重签的.ipa文件和<code>embedded.mobileprovision</code>配置文件放到同一个文件夹下。注意路径和文件名中不要出现中文，配置文件名一定要是<code>embedded</code>。</li>
<li>在终端中cd到该路径下</li>
<li>使用sigh脚本：<code>sigh resign</code>回车，运行结果跟上面是不一样的，会直接出现<code>Signing Identity:</code>让我填证书名。上述方式应该是第二步拖ipa文件到窗口，<code>Path to ipa file:</code></li>
<li>在<code>Signing Identity:</code>上面会出现一串可用的<code>identity</code>，这里要输入这些<code>identity</code>的十六进制串。回车</li>
<li>成功了：<code>Successfully signed 路径/xxx.ipa!</code>原来文件夹中的.ipa已经被重签名了。上传到蒲公英内测平台，完全可以下载使用。</li>
</ol>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20170726-104243.png" alt="操作步骤"></p>
<p>本文涉及到的知识点都是从网上Google的，感谢网友们分享的资料，还涉及的一些参考资料：</p>
<p><a href="https://objccn.io/issue-17-2/" target="_blank" rel="noopener">代码签名探析</a></p>
<p><a href="http://www.hudongdong.com/skill/363.html" target="_blank" rel="noopener">mac用终端对ipa包重新签名</a></p>
<p><a href="http://www.jianshu.com/p/0d460b52ce96" target="_blank" rel="noopener">iPhone 如何不越狱安装越狱软件</a></p>
<p><a href="http://www.jianshu.com/p/1ef0dbdac653" target="_blank" rel="noopener">企业证书重新签名ipa</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>ipa</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发笔记二</title>
    <url>/2017/07/06/iOStwo/</url>
    <content><![CDATA[<h2 id="iOS编译优化策略Optimization-Level"><a href="#iOS编译优化策略Optimization-Level" class="headerlink" title="iOS编译优化策略Optimization Level"></a>iOS编译优化策略Optimization Level</h2><p>开发汉信码扫描功能时，扫描个别汉信码，<code>Release</code>环境下会闪退，<code>Debug</code>环境下正常。没有找到崩溃原因，暂时更改<code>Optimization Level</code>下的<code>Release</code>为<code>None[-O0]</code>，这样<code>Release</code>下也会和<code>Debug</code>一样，对代码没有优化操作。</p>
<a id="more"></a>

<p>更改位置：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">TARGETS -&gt; Build<span class="built_in"> Settings </span>-&gt; Optimization Level -&gt; Release  选择`None[-O0]`</span><br></pre></td></tr></table></figure>

<p><a href="https://gcc.gnu.org/onlinedocs/gnat_ugn/Optimization-Levels.html" target="_blank" rel="noopener">Optimization Level官方解释</a></p>
<h2 id="跳转京东客户端某商品详情页"><a href="#跳转京东客户端某商品详情页" class="headerlink" title="跳转京东客户端某商品详情页"></a>跳转京东客户端某商品详情页</h2><p>iOS9以后，app内打开其他app需要在<code>Info.plist</code>里添加<code>LSApplicationQueriesSchemes</code>白名单。</p>
<p>跳转京东客户端需要增加京东的URL Scheme：<code>openapp.jdmobile</code></p>
<p><a href="http://www.jianshu.com/p/195b17052925" target="_blank" rel="noopener">iOS URL Scheme 大全(快速启动)</a></p>
<p>首先要判断手机里是否安装京东客户端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;openApp.jdMobile:&#x2F;&#x2F;&quot;]]) &#123;</span><br><span class="line">		&#x2F;&#x2F;安装了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳转京东客户端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;openApp.jdMobile:&#x2F;&#x2F;&quot;]];</span><br></pre></td></tr></table></figure>

<p>跳转京东客户端某商品详情页：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *openUrl &#x3D; @&quot;openapp.jdmobile:&#x2F;&#x2F;virtual?params&#x3D;%7B%22sourceValue%22:%220_productDetail_97%22,%22des%22:%22productDetail%22,%22skuId%22:%2299999999%22,%22category%22:%22jump%22,%22sourceType%22:%22PCUBE_CHANNEL%22%7D&quot;;</span><br><span class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:openUrl]];</span><br></pre></td></tr></table></figure>

<p>注意：openUrl字符串要原封不动的拷贝到应用中使用，里面的%22、%7等保持原样，不要转义。中间部分的<code>99999999</code>是京东的商品编号：<code>defSkuID</code>，跳转到该商品的详情中。</p>
<h2 id="OC与JavaScript交互"><a href="#OC与JavaScript交互" class="headerlink" title="OC与JavaScript交互"></a>OC与JavaScript交互</h2><p>在APP内使用UIWebView展示网页，有时候需要和网页进行功能交互和数据传递。</p>
<p>最简单的一种交互是使用<code>UIWebView</code>的Delegate方法拦截webView的加载地址，和给定的地址匹配，如果匹配则不允许加载，并跳转到指定控制器，如果不匹配则允许加载。</p>
<p>拦截加载地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)webView:(UIWebView*)webView shouldStartLoadWithRequest:(NSURLRequest*)request navigationType:(UIWebViewNavigationType)navigationType &#123;</span><br><span class="line">    NSURL *url &#x3D; [request URL];</span><br><span class="line">    NSLog(@&quot;加载地址 &#x3D; %@&quot;, url);</span><br><span class="line">    return YES;&#x2F;&#x2F;return YES允许加载，return NO不允许加载</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>iOS7以后，苹果推出了<code>JavaScriptCore</code>，用它可以直接完成oc和js之间的交互通信。下面介绍利用代理实现js调用oc中的方法，并完成数据传递。</p>
<p>第一步：在加载UIWebView的控制器中创建<code>JSExport</code>的协议，并写入和js约定好的方法，方法名要一致。该控制器遵守协议，并实现协议方法，完成webView和该控制器的交互。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line">#import &lt;JavaScriptCore&#x2F;JavaScriptCore.h&gt;&#x2F;&#x2F;导入JavaScriptCore</span><br><span class="line"></span><br><span class="line">@protocol JSObjcDelegate &lt;JSExport&gt; &#x2F;&#x2F;创建协议，写入协议方法。方法名必须和js内中一致，这些方法在js中属于对象SafetyObj下的</span><br><span class="line">&#x2F;&#x2F;方法1：js调用oc中的方法</span><br><span class="line">- (void)fnJumpScan;</span><br><span class="line">&#x2F;&#x2F;方法2：js调用oc中的方法，并要求得到某个返回值</span><br><span class="line">- (NSString *)fnGetCustomData;</span><br><span class="line">&#x2F;&#x2F;方法3：js调用oc中的方法，并传递过来一个参数</span><br><span class="line">- (void)fnSaveCustomData:(NSString *)callString;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewController&lt;UIWebViewDelegate,JSObjcDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property(nonatomic,weak)UIWebView *webView;</span><br><span class="line">@property (nonatomic, strong) JSContext *context;&#x2F;&#x2F;js运行环境</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>第二步：在网页加载完毕时，获取js运行环境，并且设置方法对象的代理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView &#123;</span><br><span class="line">    self.context &#x3D; [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><span class="line">    self.context[@&quot;SafetyObj&quot;] &#x3D; self;&#x2F;&#x2F;将自身设置为js对象的代理</span><br><span class="line">    self.context.exceptionHandler &#x3D; ^(JSContext *context, JSValue *exception) &#123;</span><br><span class="line">        context.exception &#x3D; exception;</span><br><span class="line">        NSLog(@&quot;异常信息 &#x3D; %@&quot;, exception);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：实现代理方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)fnJumpScan &#123;</span><br><span class="line">    NSLog(@&quot;点击了jumpScan&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)fnGetPostion &#123;</span><br><span class="line">    return @&quot;1234&quot;;</span><br><span class="line">&#125;</span><br><span class="line">- (void)fnSaveCustomData:(NSString *)callString &#123;</span><br><span class="line">    NSLog(@&quot;callString &#x3D; %@&quot;, callString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>排班 - 上班时间，一目了然</title>
    <url>/2017/04/05/%E6%8E%92%E7%8F%AD/</url>
    <content><![CDATA[<p>排班 - 是一款以日历为基础，记录上班时间的应用。主要针对实行倒班制，上班时间不固定的用户。简单的两步设置，便能准确地在日历上排列出上班时间，查看方便，一目了然。不用在台历上拿笔标记，也不用时时去看主管给你的上班安排。让你告别上班时间不确定的痛苦。</p>
<a id="more"></a>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/seticonapp.png" alt=""></p>
<h2 id="获取排班"><a href="#获取排班" class="headerlink" title="获取排班"></a>获取排班</h2><p>iOS: <a href="https://itunes.apple.com/cn/app/id1221228242?mt=8" target="_blank" rel="noopener">App Store下载</a></p>
<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ul>
<li><p>丰富而简洁的日历信息，包含<code>公历</code>、<code>农历</code>以及各种<code>节日</code>、<code>节气</code>、<code>节假日</code>、<code>纪念日</code>，适合每一位用户查看。</p>
</li>
<li><p><strong>添加排班：</strong>设置<code>坐标时间</code> -&gt; 添加<code>循环班次</code> -&gt; 保存<code>班表</code>，添加的班次会立刻出现在日历上。可选择<code>无限循环</code>、<code>指定时间内循环</code>、<code>按月循环</code>排班。可编辑<code>班表名称</code>。</p>
</li>
<li><p><strong>无线循环排班：</strong><code>坐标时间</code>是开始循环的时间，默认从今天开始。会以这个时间为坐标，向前、向后无限循环设置的<code>循环班次</code>。</p>
</li>
<li><p><strong>指定日期内循环排班：</strong>给<code>循环班次</code>设置一个<code>日期范围</code>，会从<code>开始日期</code>开始执行<code>循环班次</code>，一直循环到<code>结束日期</code>。这个日期范围之外无班次设置。</p>
</li>
<li><p><strong>按月循环排班：</strong>不需要时间设置，从每月的<code>1号</code>开始执行<code>循环班次</code>，循环到每月的最后一日。每个月都是独立循环的。</p>
</li>
<li><p><strong>循环班次：</strong>循环班次可长按拖动排序，指定删除某个班次，一键清空所有添加的班次。</p>
</li>
<li><p><strong>待选班次：</strong>待选班次预设了6个，可添加删除。可以在设置中还原待选班次。</p>
</li>
<li><p><strong>选择班表：</strong>可以添加多个班表，这里显示了添加的所有班表名称，选中确认显示在日历中。可以左滑删除。</p>
</li>
<li><p><strong>班表统计：</strong>统计每个月，各种班次各上了几天班。一键查看方便快捷。</p>
</li>
<li><p><strong>备忘列表：</strong>长按日历中的某天，或点击今日信息中的备忘，可添加备忘信息。所有的备忘信息会显示在这里，可以左滑删除。</p>
</li>
<li><p><strong>其他设置：</strong>可以设置日历的各种显示方式，可以还原待选班次，清空添加的备忘记录和班表。</p>
</li>
<li><p><strong>自定义班次：</strong>当待选班次没有合适的，可以自己添加待选班次，指定喜欢的班次颜色。</p>
</li>
<li><p><strong>修改某一天的班次：</strong>长按日历中的某天，或者点击今日信息中的排班，可修改这一天的班次。</p>
</li>
</ul>
<h2 id="反馈与支持"><a href="#反馈与支持" class="headerlink" title="反馈与支持"></a>反馈与支持</h2><p>如果您有自己的排班需求和对应用的意见或建议，请联系：<a href="mailto:i@markmiao.com">i@markmiao.com</a> 我们会认真对待每一次反馈，将[排班]做的更好。</p>
<p>如果您喜欢该应用，请在App Store留下宝贵的评价。</p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><strong>感谢下列开源项目</strong></p>
<p><a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">fmdb</a></p>
<p><a href="https://github.com/yuantiku/YTKKeyValueStore" target="_blank" rel="noopener">YTKKeyValueStore</a></p>
<p><a href="https://github.com/cyanzhong/LunarCore" target="_blank" rel="noopener">LunarCore</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>应用</tag>
      </tags>
  </entry>
  <entry>
    <title>Widget开发</title>
    <url>/2017/04/02/Widget%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>widget是iOS8时推出的窗口小部件功能，窗口小部件在Android上早已大行其道。记得当年用过的第一部Android是深圳出产的国产机，当时滑过三四个屏幕的应用，还能继续再滑三四个屏幕的窗口小部件。用的最多的窗口小部件就是日历了，屏幕上一目了然。</p>
<a id="more"></a>

<p>Apple直到iOS8才加入窗口小部件，而且可自定义程度远远没有Android开放。</p>
<p>本文记录了开发widget的步骤，以及遇到的一些问题。</p>
<p>开发环境：Xcode8.2.1，swift3.0</p>
<h2 id="创建widget"><a href="#创建widget" class="headerlink" title="创建widget"></a>创建widget</h2><p>widget可以理解为一个独立的项目，虽然形式上看来像是附属于app的一部分功能，其实并不是，widget想获取app的数据，还需要做数据共享。</p>
<p><code>File</code> -&gt; <code>New</code> -&gt; <code>Target</code></p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/2016-10-094.36.08.png?raw=true" alt="创建Today Extension"></p>
<p>选择iOS里的<code>Today Extension</code></p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/2016-10-094.40.27.png?raw=true" alt="创建Today Extension"></p>
<p>习惯使用纯代码布局，喜欢用storyboard的不需要下面的info.plist修改。在新创建的widget项目文件夹中删除<code>MainInterface.storyboard</code>，修改info.plist里的<code>NSExtension</code>字段：</p>
<ol>
<li>删除<code>NSExtensionMainStoryboard</code>字段</li>
<li>添加<code>NSExtensionPrincipalClass</code>字段，Value 为<code>TodayViewController</code>（<code>TodayViewController</code>是自定义控制器，）</li>
</ol>
<p>修改info.plist的结果如下</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161009-0.png?raw=true" alt="img"></p>
<h3 id="问题1-widget崩溃"><a href="#问题1-widget崩溃" class="headerlink" title="问题1.widget崩溃"></a>问题1.widget崩溃</h3><p>经过上述修改，用纯代码布局widget，用OC开发是没有问题的，swift3.0中widget会崩溃，并打印下面的错误。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">*** Terminating app due <span class="keyword">to</span> uncaught exception <span class="string">'NSInvalidArgumentException'</span>, reason: <span class="string">'*** setObjectForKey: object cannot be nil (key: 56A34ADC-7A43-43B0-A924-171F803DD305)'</span></span><br><span class="line">libc++abi.dylib: terminating with uncaught exception of<span class="built_in"> type </span>NSException</span><br></pre></td></tr></table></figure>

<p>StackOverflow有人遇到同样的问题：<a href="http://stackoverflow.com/questions/28153273/today-extension-crashes-before-launching-on-ios-8-1-2" target="_blank" rel="noopener">Today Extension Crashes before launching on iOS 8.1.2</a>，但解答好像并没有效果。</p>
<p>在一篇博客中我找到了解决办法，<a href="http://blog.xebia.com/ios-today-widget-written-in-swift/" target="_blank" rel="noopener">博客地址</a></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Since (<span class="keyword">at</span> <span class="keyword">the</span> <span class="built_in">time</span> <span class="keyword">of</span> this writing) Xcode cannot find Swift classes <span class="keyword">as</span> <span class="built_in">extension</span> principal classes, we also would have <span class="built_in">to</span> <span class="built_in">add</span> <span class="keyword">the</span> following <span class="built_in">line</span> <span class="built_in">to</span> our TodayViewController:</span><br><span class="line"></span><br><span class="line">@objc (TodayViewController)</span><br><span class="line"></span><br><span class="line">Update: Make sure <span class="built_in">to</span> <span class="built_in">set</span> <span class="keyword">the</span> <span class="string">"Embedded Content Contains Swift Code"</span> build setting <span class="keyword">of</span> <span class="keyword">the</span> main app target <span class="built_in">to</span> YES. Otherwise your widget written <span class="keyword">in</span> Swift will crash.</span><br></pre></td></tr></table></figure>

<p>文中说目前为止Xcode找不到swift类作为拓展主题类（其实到我写这篇文章的时候，还是找不到），这可能是一个bug。解决办法是需要在widget控制器<code>TodayViewController</code>中添加：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> (<span class="type">TodayViewController</span>)</span><br></pre></td></tr></table></figure>

<p>博文更新中说，可以更改<code>Embedded Content Contains Swift Code</code>这个设置为yes，但是在Xcode8.2.1中，这个设置已经没有了，取而代之的是<code>Always Embed Swift Standard Libraries</code>，亲测主项目的<code>targets</code>和widget的<code>targets</code>中修改这个设置的Bool值，都还是会崩溃。</p>
<h2 id="widget折叠"><a href="#widget折叠" class="headerlink" title="widget折叠"></a>widget折叠</h2><p>iOS10之后才有的widget折叠。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(iOSApplicationExtension <span class="number">10.0</span>, *) &#123;</span><br><span class="line">    <span class="keyword">self</span>.extensionContext?.widgetLargestAvailableDisplayMode = .expanded</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Fallback on earlier versions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现下面方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@available</span>(iOSApplicationExtension <span class="number">10.0</span>, *)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">widgetActiveDisplayModeDidChange</span><span class="params">(<span class="number">_</span> activeDisplayMode: NCWidgetDisplayMode, withMaximumSize maxSize: CGSize)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> activeDisplayMode == .expanded &#123;</span><br><span class="line">        <span class="keyword">self</span>.preferredContentSize = <span class="type">CGSize</span>(width: <span class="number">0</span>, height: <span class="number">200</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">self</span>.preferredContentSize = maxSize</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码共享"><a href="#代码共享" class="headerlink" title="代码共享"></a>代码共享</h2><p>虽然widget附属于主应用，但其实是独立的。在widget中无法调用主应用中的代码，这样一来就蛋疼了。有些公共方法或者控件，在主应用中写完了，在widget却无法使用。当然把主应用中的代码拷贝一份到widget中也是可以的，这种做法太low。</p>
<p>可以使用framework做代码共享。创建一个framework</p>
<p><code>File</code> -&gt; <code>New</code> -&gt; <code>Target</code></p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20170330-150955.png" alt="创建framework"></p>
<p>在<code>framework</code>的<code>Build Phases</code> -&gt; <code>Compile Sources</code>里面添加要共享的代码文件。</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20170330-152310.png" alt="添加共享的代码文件"></p>
<p>在<code>TARGETS</code>里面，分别在主项目和widget下面的<code>Linked Frameworks and Libraries</code>里面添加新建的<code>framework</code></p>
<p>并在widget中用到共享代码的地方引入<code>framework</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ShareToday</span><br></pre></td></tr></table></figure>

<h3 id="问题1-引入framework报错和报警告"><a href="#问题1-引入framework报错和报警告" class="headerlink" title="问题1.引入framework报错和报警告"></a>问题1.引入framework报错和报警告</h3><p>引入的时候会如下错误：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">TodayViewController.swift:<span class="number">11</span>:<span class="number">8</span>: Module <span class="keyword">file</span><span class="symbol">'s</span> minimum deployment target <span class="keyword">is</span> ios10.<span class="number">0</span> v10.<span class="number">0</span>:</span><br></pre></td></tr></table></figure>

<p>是因为framework的<code>Deployment Target</code>的版本号和widget的版本号不相符，改为一样的即可。</p>
<p>报如下警告：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">ld: warning: linking <span class="keyword">against</span> a dylib which <span class="keyword">is</span> <span class="keyword">not</span> safe <span class="keyword">for</span> use <span class="keyword">in</span> <span class="built_in">application</span> extensions:</span><br></pre></td></tr></table></figure>

<p>是因为application extensions限制了一些API的使用，而在新建的framework里面，可能包含了这些API，所以才会出现这个警告。</p>
<p>解决办法：勾选framework里面的<code>Allow app extension API only</code></p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20170330-152418.png" alt="注意"></p>
<h3 id="问题2-方法调用不到"><a href="#问题2-方法调用不到" class="headerlink" title="问题2.方法调用不到"></a>问题2.方法调用不到</h3><p>swift中，加入到framework的一些方法，在引入头文件后的widget调用不到。</p>
<p>解决办法：需要把方法设置为公用的，用<code>public</code>修饰方法，例如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">getString</span><span class="params">(a: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="string">"\(a)"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有共用的oc代码，需要将.m文件引入到<code>Compile Sources</code>，将.h文件拖入<code>Headers</code>的<code>Public</code>里面，然后在framework的.h头文件中<code>#import</code>共用oc代码的.h头文件</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-04-02-14-17-36.png" alt="引入oc共享代码"></p>
<h2 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h2><h3 id="配置证书："><a href="#配置证书：" class="headerlink" title="配置证书："></a>配置证书：</h3><ol>
<li>在<code>Certificates, Identifiers &amp; Profiles</code>里的<code>Identifiers</code>下面添加<code>App IDs</code>时，要勾选<code>App Groups</code>。</li>
<li>在<code>App Group</code>添加一个<code>App Group</code>，在写<code>Identifier</code>，会在前面自动添加<code>group.</code></li>
<li>添加<code>App Group</code>之后，在<code>App IDs</code>点开第1步创建的id，点击edit，把<code>App Group</code>添加上，<code>App Group</code>的黄点会变成绿点。</li>
</ol>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/WX20170402-113444@2x.png" alt="创建的App Group"></p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/WX20170402-113344@2x.png" alt="配置完成的Identifier"></p>
<h3 id="添加证书"><a href="#添加证书" class="headerlink" title="添加证书"></a>添加证书</h3><p>在Xcode的<code>TARGEST</code>下面，主程序和widget的<code>Capabilities</code>里面，都要打开<code>App Groups</code>。下面的Steps不能有红色叹号的错误。</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/WX20170402-113739@2x.png" alt="正确显示"></p>
<p>在证书配置正确的前提下，还出现了红色叹号的错误警告，有可能是因为主项目或者widget的<code>General</code>里面没有选择好正确的签名Team。</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/WX20170402-112029@2x.png" alt="配置正确的签名"></p>
<h3 id="用NSUserDefaults共享数据，"><a href="#用NSUserDefaults共享数据，" class="headerlink" title="用NSUserDefaults共享数据，"></a>用NSUserDefaults共享数据，</h3><p>存储数据</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shareDefaults = <span class="type">UserDefaults</span>(suiteName: <span class="string">"group.xxx.xxx.xx"</span>)<span class="comment">//App Groups ID</span></span><br><span class="line">shareDefaults?.<span class="keyword">set</span>(worksArray, forKey: <span class="string">"worksArray"</span>)</span><br><span class="line">shareDefaults?.synchronize()</span><br></pre></td></tr></table></figure>

<p>读取数据</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shareDefaults = <span class="type">UserDefaults</span>(suiteName: <span class="string">"group.xxx.xxx.xx"</span>)<span class="comment">//App Groups ID</span></span><br><span class="line"><span class="keyword">let</span> worksArray = shareDefaults?.array(forKey: <span class="string">"worksArray"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="点击widget开启app"><a href="#点击widget开启app" class="headerlink" title="点击widget开启app"></a>点击widget开启app</h3><p>在widget中，点击图标可以开启主应用，不用添加任何方法。如果想点击其他地方开启app，需要在app的<code>TARGEST</code>里的<code>info</code>下<code>URL Types</code>添加<code>URL Schemes</code></p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161009-1.png?raw=true" alt="img"></p>
<p>添加点击事件，调用方法，开启app</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">self</span>.extensionContext?.<span class="keyword">open</span>(<span class="type">URL</span>(string: <span class="string">"paibanapp://"</span>)!, completionHandler: &#123; (<span class="type">Bool</span>) <span class="keyword">in</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"success"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>swift中contains的使用</title>
    <url>/2017/03/16/swift%E4%B8%ADcontains%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><code>contains</code>是swift中的一个实例方法，返回一个Bool值，用于做“是否包含”的判断。简单的说就是：告诉你一堆玩意儿中是否有你要的玩意儿。</p>
<a id="more"></a>

<h2 id="方法contains"><a href="#方法contains" class="headerlink" title="方法contains()"></a>方法contains()</h2><p>用法1：判断字符串中是否包含某个字符或某段字符串</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"abcdef"</span></span><br><span class="line"><span class="built_in">print</span>(str.<span class="built_in">contains</span>(<span class="string">"a"</span>))<span class="comment">//true</span></span><br><span class="line"><span class="built_in">print</span>(str.<span class="built_in">contains</span>(<span class="string">"bcd"</span>))<span class="comment">//true</span></span><br><span class="line"><span class="built_in">print</span>(str.<span class="built_in">contains</span>(<span class="string">"g"</span>))<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>用法2：判断数组中是否包含某个元素</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = [<span class="string">"Mark"</span>, <span class="string">"Kim"</span>, <span class="string">"Goudan"</span>]</span><br><span class="line"><span class="built_in">print</span>(str.<span class="built_in">contains</span>(<span class="string">"Mark"</span>))<span class="comment">//true</span></span><br><span class="line"><span class="built_in">print</span>(str.<span class="built_in">contains</span>(<span class="string">"MJ"</span>))<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="方法contains-where"><a href="#方法contains-where" class="headerlink" title="方法contains(where: )"></a>方法contains(where: )</h2><p>该方法接收一个闭包，以序列元素作为闭包的参数，返回一个Bool值，判断该序列中是否有元素符合闭包条件。</p>
<p>用法1：判断Int数组中元素有没有大于100的</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">44</span>,<span class="number">66</span>,<span class="number">88</span>,<span class="number">100</span>]</span><br><span class="line"><span class="keyword">let</span> zz = list.<span class="built_in">contains</span>(<span class="keyword">where</span>: &#123; (value) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">100</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(zz)<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>闭包的写法可以简化，闭包中只有一行表达式时，可以省略return，直接写表达式，隐式返回：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> zz = list.<span class="built_in">contains</span>(<span class="keyword">where</span>: &#123; (value) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">	 value &gt; <span class="number">100</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>闭包的参数名可以简化为$0，表示第i个参数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> zz = list.<span class="built_in">contains</span>(<span class="keyword">where</span>: &#123;$<span class="number">0</span> &gt; <span class="number">100</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>用法2：判断对象数组中对象元素的某个key所对应的value是存在某值</p>
<p>例如：判断下面<code>dictList</code>数组中的字典元素里面是否有<code>&quot;name&quot;</code> == <code>&quot;Mark&quot;</code>的元素存在</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dictList = [[<span class="string">"name"</span>: <span class="string">"Goudan"</span>, <span class="string">"age"</span>: <span class="string">"22"</span>], [<span class="string">"name"</span>: <span class="string">"Mark"</span>, <span class="string">"age"</span>: <span class="string">"18"</span>], [<span class="string">"name"</span>: <span class="string">"Maoya"</span>, <span class="string">"age"</span>: <span class="string">"19"</span>], [<span class="string">"name"</span>: <span class="string">"Tuzi"</span>, <span class="string">"age"</span>: <span class="string">"25"</span>], ]</span><br></pre></td></tr></table></figure>

<p>当然可以通过<code>for</code>循环遍历<code>dictList</code>数组，挨个字典元素检测。这样做太麻烦，可以使用<code>contains(where: )</code>方法，传入一个闭包，完成检测</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isMark = dictList.<span class="built_in">contains</span>(<span class="keyword">where</span>: &#123; (dict:[<span class="type">String</span> : <span class="type">String</span>]) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    dict[<span class="string">"name"</span>] == <span class="string">"Mark"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可简写为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isMark = a.<span class="built_in">contains</span>(<span class="keyword">where</span>: &#123;$<span class="number">0</span>[<span class="string">"name"</span>] == <span class="string">"Mark"</span>&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>swift中delegate的使用注意</title>
    <url>/2017/03/10/swift%E4%B8%ADdelegate%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/</url>
    <content><![CDATA[<p>delegate是iOS开发中一种非常常用的设计模式，经常用作界面的反向传值。block可以做到同样的事情，曾有人言delegate是个臃肿的胖子，远不如block轻便，早该淘汰了。在ARC中，block中使用swift要用weak修饰，注意循环引用。delegate也需要使用weak指针，避免内存泄露。</p>
<a id="more"></a>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, <span class="keyword">weak</span>)id&lt;<span class="type">XDViewControllerDelegate</span>&gt; delegate;</span><br></pre></td></tr></table></figure>
<p>ARC环境下在oc中定义delegate使用weak修饰，在delegate对象释放掉后，delegate没有强指针引用也会被释放掉，避免了访问不存在delegate对象的delegate方法而崩溃。可以在<code>dealloc</code>方法中做防御性操作：置空delegate。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    <span class="keyword">self</span>.delegate = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在最近的swift项目中用到delegate，由于没有使用weak修饰，控件循环引用无法释放，导致内存泄露。</p>
<p>场景是这样的: 在控制器中添加了A控件，A控件中有个子控件B，B有个代理方法，A作为他的代理，并实现了代理方法。在完成功能后，使用<code>removeFromSuperview()</code>移除A控件时，发现A和B的反初始化方法<code>deinit</code>都没调用，说明这两个控件没被释放掉，内存泄露了。</p>
<p>(这里有个小坑，<code>deinit { }</code>方法里面如果没有执行代码是不会调用的，使用<code>deinit</code>检测该控件是否被移除，记得在<code>deinit { }</code>里面写一行执行代码，比如<code>print(&quot;deinit&quot;)</code>)</p>
<p>因为我在定义delegate的时候，是这样定义的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">workSelectViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addWorkBtnViewClick</span><span class="params">(workTitle: String, workColor: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkSelectView</span>: <span class="title">UIView</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> delegate:workSelectViewDelegate?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于delegate没有weak修饰，在移除A控件的时候，A中有B，B的代理又是A，A和B相互引用，导致谁也没能释放掉。</p>
<p>将delegate使用weak修饰即可，直接在<code>var delegate</code>前面加<code>weak</code>，编译会报错。这是因为在swift中遵守protocol的类型有很多，其中有些类型不支持weak修饰，比如struct。这里需要限制protocol的类型遵守。比如下面指定这个protocol只能由class遵守：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">workSelectViewDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addWorkBtnViewClick</span><span class="params">(workTitle: String, workColor: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkSelectView</span>: <span class="title">UIView</span></span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate:workSelectViewDelegate?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种方式是定义oc类型的protocol，因为oc类型的protocol只有class实现。使用关键词<code>@objc</code>修饰protocol：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">workSelectViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addWorkBtnViewClick</span><span class="params">(workTitle: String, workColor: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkSelectView</span>: <span class="title">UIView</span></span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate:workSelectViewDelegate?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比第二种方法，第一种方法明显才是swift该有的样子，第二种太依赖oc了。</p>
<p>说起依赖oc，想起来在delegate定义中的<code>optional</code>，在swift中定义delegate方法，如果没有可选修饰，遵守了代理而不实现代理方法，不是警告，而是直接报错。</p>
<p>要想使用可选实现的修饰<code>optional</code>，必须使用<code>@objc</code>修饰</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">workSelectViewDelegate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addWorkBtnViewClick</span><span class="params">(workTitle: String, workColor: String)</span></span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">addTimeTextString</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样还有一个问题，如果代理有结构体作为返回值的话，会不支持而报错。</p>
<p>需要另一种方法定义可选代理方法，协议拓展：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">workSelectViewDelegate</span>: <span class="title">class</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addWorkBtnViewClick</span><span class="params">(workTitle: String, workColor: String)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addTimeTextString</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">workSelectViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addTimeTextString</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>我对小程序的一些看法</title>
    <url>/2017/01/10/%E6%88%91%E5%AF%B9%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/</url>
    <content><![CDATA[<p>2016年9月22日，微信捣鼓了一年的应用号对部分开发者账号推送内测邀请，并暂时定名为“小程序”。2017年1月9日，“小程序”由暂定名落地为正式名，正式上线。这篇文章本来是在去年9月22日小程序推内测时写的，写了一半。今天补全，补成一篇对于小程序我的一些看法吧。也是我2017年第一篇博文，以非技术类文章开篇，可见我的懒惰。</p>
<a id="more"></a>

<p>9月22日，小程序推送内测，作为一种新兴的开发方向，在互联网圈子激起了不小的波澜。对程序猿来说，又有一个新的开发方向要涉猎了，好(F)开(U)心(C)吆(K)！好比这些火起来的语言技术：swift、React Native、Weex、php、Python、h5、js、Go……程序猿真是学无止境，怪不得都想要有几年开发经验的程序员，这些技术没有几年哪涉猎的过来啊！</p>
<p>吐槽归吐槽，作为一个好奇心极重的程序猿，对于新出的技术，还是想大致了解一下“小程序”到底是个什么玩意，万一以后做这方面的开发，这篇文字也算是探路石了。</p>
<p>2017年1月9日，小程序正式上线。“微信之父”张小龙挑的这个日子也颇有深意，十年前的1月9日乔布斯发布了第一款iPhone，彻底颠覆了移动互联网和手机市场。不知道微信是不是打算革命移动应用市场，将中国现在第一大应用推向AppStore的行列。“我是一个应用，但我不甘心只做一个应用。”估计这就是微信的心里话。</p>
<p>小程序定位是O2O，主攻线上与线下的连接。扫描二维码是小程序的主要入口。以二维码为O2O的连接媒介，以不用安装下载用完即走的轻便迅速，来弥补普通APP庞杂冗余的短板。在Apple和Google垄断移动应用市场的环境下，微信以小程序走线下启动这条路，想在移动应用市场分一杯羹。</p>
<p>小程序的线上入口比较深，需要搜索小程序全名（腾讯系的小程序支持模糊搜索），访问过小程序，才会在“发现”模块出现“小程序”一栏，里面是访问过的小程序记录，并非小程序市场。有人吐槽这是为了防止AppStore审核人员发现，对微信来说，以这种方式规避审核太弱智了吧。我想这并非为了规避审核，而是防止“微信推出小程序应用市场”的概念出现。微信在推出小程序之前估计已经和Apple和Google达成协议：我们不会抢占两位大哥应用市场的利润，我们只做个线下推广的小程序，就如同电线杆贴小广告，不会做应用市场，市场老大依旧是您二位，两位大哥高抬贵手给口吃的。</p>
<p>微信内不支持模糊搜索小程序，这也是对“小程序应用市场”概念的抑制。应用市场最重要的是能展示应用和快速搜索到应用。“小程序”模块既不能展示未使用过的应用，也不支持模糊搜索快速搜到应用，这便完全遏制了“小程序”模块是应用市场的概念。而且有模糊搜索就容易出现竞价排名，就有了应用市场的概念，微信明显意不在应用市场（或者说目前不敢有意此处），而是只想踏足线下入口这片领域。这估计也是微信对Apple和Google两位大哥的宣誓明志。</p>
<p>微信明言不推出小程序市场，如果推出小程序市场无疑是跟AppStore、谷歌应用市场宣战了，因为那完全是赤裸裸的利益争夺，两位大哥斩杀小弟估计也决不会手软。其实微信也知道，即使我不推出小程序市场，也会有一大群的跟屁虫替我推出。果不其然，1月9日当天就出现了一大批小程序市场，对此微信做了第二次宣誓明志，无法识别图片二维码打开小程序，只能扫码进入。如此一来，小程序应用市场的存在意义就如同小程序名称列表一样了。</p>
<p>除了不能模糊搜索，微信小程序还不能分享到朋友圈，只能转发给好友，这便遏制了爆炸式传播的路径。一键朋友圈分享所产生的推广力度，岂是一个好友一个好友的转发所能比拟的？微信重申主打扫码启动小程序，无需安装，用完即走，我们不提供市场和推广，我们只是小程序的审核者和搬运工。既想抢大哥的蛋糕吃，又要防止被大哥揍，微信不得不煞费苦心，剑走偏锋式的开辟一条新径。</p>
<p>对于小程序的未来，有人看好，有人不看好，有人看热闹，有人在观望。毫无疑问的是，小程序是2017年互联网界的第一个大新闻。</p>
<p>小程序开发成本低，又基于庞大的微信用户量。能火起来是肯定的，但能火到什么程度是大家最关心的。有人说能火到把原生应用都挤死，iOS和Android工程师都回家养猪吧。也有人说Apple和Google不会允许小程序太火，火到这种程度之前就会把微信干掉，依托微信的公司都等死吧。</p>
<p>这两种都太极端了，悬在自己头上的达摩克利斯之剑什么时候斩下，Apple、Google、微信他们自己比谁都清楚。他们不清楚的是看不见的那股异军突起，《腾讯传》里KK对马化腾说：“即将灭掉你的那个人，从来不会出现在一份既定的名单中。”就好比当年强盛的诺基亚和symbian，不是被竞争对手摩托罗拉打败，而是死在iPhone的Android的崛起。统一三国的不是魏蜀吴，而是司马氏。</p>
<p>到底要不要开发小程序？众说纷纭。有人说互联网世界波谲云诡、变幻莫测，好不容易出现了一列必火的快车，再不赶紧上车，等老司机开车了，就赶不上第一批红利了。就是那句话：等你想吃的时候，屎都凉了。也有人说小程序能承载的东西太少了，又依托于微信，自己对产品的掌控力弱化，何必降低自己原生应用的活跃量给微信加流量呢？这是另一句话：为什么要拿自己的热脸去捂暖别人的冷屁股呢？</p>
<p>各有各的说法，各有各的道理。那我他妈的到底要不要推出小程序呢？</p>
<p>其实根据小程序的O2O定位，可以大致研究研究自己公司到底适不适合推出小程序。我认为，小程序适用于固定地点、用户非日常刚需、偶尔使用的低频应用。比如：进店线上点餐、某个景点介绍和路线、某个商店的线上商城、某个学校的官宣。通俗解释就是：我不经常用，但用起来又比较着急，别让我下载APP注册账号，让我一扫立刻用到。就好比擦腚纸，要用的时候从旁边厕纸盒一抽即可，要是先让我解厕纸盒的密码锁，我不得疯了啊！用完之后随水冲走。用时一抽，用完一冲，也用带着占用口袋空间，太方便了。（这个比喻没有贬低小程序的意思，我实在是想不到比这个更恰当的比喻了）</p>
<p>如果是高频率使用的应用，还是原生应用适合。比如：日历。我要看个日历，直接右划看widget即可，连解锁都不用。让我解锁，打开微信，点到小程序，看日历，那也得疯了。还有如果只是偶尔定一次餐，点小程序订餐即可，不用专门下个APP。但如果我是天天加班订餐，我还是习惯用原生APP。</p>
<p>作为用户角度，哪个方便我用哪个，用户体验是能留住我的唯一手段，谁能让我爽，我就喜欢谁。有人在微博上说：我已经卸载了美团外卖和猫眼APP了。小程序里的美团外面和猫眼APP完全可以满足用户订餐和买电影票的需求，用户毫不留恋原生APP，删除卸载。对于美团和猫眼来说这种消息不知是好是坏，自己原生应用的用户活跃量硬生生被微信小程序剥夺了一部分，用自己的用户贡献了微信的流量。比较来说滴滴就比较聪明，滴滴出行只能打快车，用户要是想打顺风车、小巴还是得去APP。</p>
<p>作为程序员，公司要我做哪个就得做哪个，管你小程序是一波红利还是一撮泡沫。“小猿呀，明天小程序要上线，今天加加班，搞定它，相信你吆。” “哦……” 同事们都下班了，我翻开微信公众平台的小程序，开始看第一篇“简易教程”，开始踩坑之旅。作为程序员，小程序还是需要看看的，毕竟是今年的第一波技术浪潮，虽然后面一浪接着一浪，别第一浪就拍死了，死在第二浪会好看点。</p>
<p>本文纯属是我对微信小程序的一些看法，如有偏差，欢迎拍砖吐槽。</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>2016我的年终总结</title>
    <url>/2016/12/31/2016%E6%88%91%E7%9A%84%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>不知不觉2016年结束了，离梦想又远了一步。在微博上看到一句话：“十年前并不是九几年而是零六年！”那一瞬间感觉自己真的老了。90后已不再是年轻的标签，奔三也奔的那么马不停蹄。三十而立，到现在依旧晃晃悠悠，到三十那天我真能立住吗？怎么立？金鸡独立？又或者是静静地坐着敲代码，平凡的度过本以为不平凡的那一天。</p>
<a id="more"></a>

<p>来北京四年了，每年都有不一样的事，每年都遇到不一样的人。谈不到精彩，相对于平淡总有一些波澜，可以厚颜无耻的说一句：我还年轻没到平淡的年纪。回头看看这一年，总觉得这是我最忙碌、变化最大的一年。具体想想有哪些变化，貌似也没什么。是虚度了时光，还是矫情了岁月？</p>
<h2 id="工作和技术"><a href="#工作和技术" class="headerlink" title="工作和技术"></a>工作和技术</h2><p>工作方面没有多大改变，依旧敲代码。2015年国庆假期结束入职现在这家公司，app开发了一堆，拿的出手的却没有。工作相对于在以前公司的时候清闲多了，几乎没加过班。一方面是工作经验多了的原因，对于工作中遇到的问题，也不像初入行时那么手忙脚乱了。另一方面是项目周期长，时间充裕。记得我刚入行时的第一家公司，项目周期短，需求变化大，迭代迅速，差不多一两周出一版。就是赶着AppStore的审核时间，等待审核期间新需求就出来了，审核通过上架了，新版本也开发的差不多了，继续提交。快速增长期的创业公司就是这个节奏，那段时间经常通宵加班，睡在公司。我的上一辆自行车停在地铁口，通宵加班两天，第三天回来的时候不见了。那段时间真是加班加的快吐了，简直是张口就要骂娘的状态，那时最大的愿望就是下班时能看到夕阳。但那段时间也是我技术提升最快的时候，现在闲下来了，反而有些怀念当时受虐的日子，人真是有些贱骨头。</p>
<p>技术方面没有大的提升，作为本职工作的iOS开发，钻研的还不够，好多深层次的东西都不懂。有时候看到和我差不多时间入行，甚至比我入行还晚的人写的技术博客，令我惭愧不已。我不但写不出来，甚至都看不懂，我都不好意思说比别人早入行。前段时间在微博上看到一段话，是面试官对面试者说的话：你不是有N年经验，你是一年经验用了N年。当时感觉被狠狠抽了一个大嘴巴子，这他妈不就是说的我吗？安逸的工作环境使人颓废，多少次励志，多少次放弃，间歇性踌躇满志，持续性混吃等死。感觉膝盖狠狠地中了一箭，长跪不起。客观来说，技术还是有些提升，虽然提升幅度不值一哂。swift、Mac、git、Python、h5、JavaScript……这些多少有些涉猎，嗯……好吧，目前还停留在涉猎层面。一直十分佩服那些能按部就班沉下心了学习一门技术的人，能让自己不断学习的人，就是所谓成功的一类人吧，即使目前不成功，成功的那天总不会很远。</p>
<h2 id="生活和爱情"><a href="#生活和爱情" class="headerlink" title="生活和爱情"></a>生活和爱情</h2><p>生活方面算是变化最大的了，2016年春节过后，和女朋友搬到现在居住的地方，脱离了以前合租的窘境。6月份头脑一热养了一只金毛，现在他已经有九个月了。硕大的体型、对人忘我般的热情，每当遛他的时候，总担心他扑向陌生人。虽然他性情温顺，但毕竟体型太大，对人又热情，喜欢闹腾。除了了解金毛、喜欢狗狗的人能和他玩玩，其他人即便喜欢也不敢靠近。养过狗狗才知道，养狗真的挺麻烦的，特别是养一只大狗。烦透了的时候忍不住揍一顿，揍完又感觉他好可怜。我对晓说：他就像是个意外怀孕的孩子，讨人厌又惹人怜。晓说：也是一个家庭成员，好好养着吧。有时上班不在家，透过摄像头看到他静静地坐在窗前，看窗外车来车往，感觉他好想出去玩，像个孩子……</p>
<p>晓是和我在2016年元旦之前去我家的，那也是她第一次去我家，第一次见我父母。我见她父母是在3月份，和她一家人去了一趟西安。晓美其名曰旅行见父母，其实就想出去浪一下。最终圆满，我父母对晓非常喜欢，晓的父母对我也十分满意。7月份，我父母来北京，双方父母进行了亲切友好的会谈，对我们的终身大事交换意见，并达成一致协议。10月份，在晓的父母的陪同下，晓和我在我家举行了订婚仪式，亲朋好友献上真诚祝福。在北京，我从一个通宵加班两天、自行车丢了都没人问的单身狗，变成了一个有小窝、有爱人、有孩子(目前是宠物)的程序猿。这一波虐狗得负刑事责任了……</p>
<h2 id="读书和旅行"><a href="#读书和旅行" class="headerlink" title="读书和旅行"></a>读书和旅行</h2><p>都说读万卷书，行万里路。这两者缺一不可。一直以来，我都是喜欢看旧书，不愿去翻开一本新书。有的书我都读过十几二十几遍了，想读书的时候还会去读那些，当然都不是什么技术型书籍。读书确实是提升自己最有效的方式，读书破万卷，下笔如有神，古人诚不欺我。当然我离这个境界还差十万八千里，但我希望我能向着这个目标不断前进。年底看了一本新书，吴晓波写的《腾讯传》，讲述了腾讯的发展史，记录了一个互联网巨型企业一路走来的跌宕坎坷，我看到了任何成功都容不得半点侥幸，腾讯的崛起也绝非偶然。</p>
<p>旅行是费钱的，但长久看来收益大于付出。2015年有过一次旅行，和晓去四川成都，去了宽窄巷子、大熊猫培育基地、九寨沟，最终由于我发高烧仓促返京。2016年有过两次远途旅行，第一次是和晓的家人去西安，第二次是和晓去香港。每次旅行或多或少都会有遗憾，或许根本不可能存在完美的旅行，有不完美才会有下一次的追求完美。明年还会去旅行，目的地还没想好，我会为了完美的旅行做更多的准备，虽然肯定还会有不完美。</p>
<p>前几天看到一段话：如果不读书，行万里路也不过是个邮差。仔细想想蛮有道理的，庐山瀑布有亿万人望过，也只有李白写出了“飞流直下三千尺，疑是银河落九天”的绝句。有多少文化底蕴才能读出美景的多少韵味，看到草原，牛想到的是饱餐一顿，诗人想的是天苍苍，野茫茫，风吹草低见牛羊。打住！这段话纯属吹牛逼，我也不相信一个程序猿到一个地方首先想到的是美景而不是美食。我是一个爱吃的俗人，不是爱景诗人，但我知道多读书能多挣钱，多挣钱能多旅行，多旅行才能吃到更好的美食。</p>
<h2 id="大环境和小愿望"><a href="#大环境和小愿望" class="headerlink" title="大环境和小愿望"></a>大环境和小愿望</h2><p>2016年，互联网行业历经寒冬，从波澜翻滚变成了暗潮涌动。记得前几年，互联网创业随处可见，创业门槛低到有台电脑就行，到处都能听到风投融资的故事。雷军说：站在风口上，猪都会飞。今年风小了，好多猪摔死了。光我认识的同学朋友圈子里，就有五六家公司关门大吉，我这个小圈子都如此，可见这个大行业的动荡。互联网行业从疯狂渐渐趋向沉稳，从互联网行业招聘就可以看出来，程序员找工作难，iOS更是难于上青天。有AppStore上架作品已不再是加分项，而是基本技能。网上有人说：招Android和iOS两个职位，Android一天收到十几份简历，iOS能收到几百份简历！多少iOS开发者抱着简历海投，只求一份工作。有人抱怨iOS不行了，转投H5。相信过不了多久你又会抱怨H5不行了，那时候你转投什么呢？在一篇博文里看到这么一段话：不是这个行业不行，而是你不行。事实如此，无数iOS开发者找不到工作的同时，也有无数企业招不到合适的iOS开发。需求和供应有时就是这么尴尬的不对等，作为程序员，职责就是实现各种需求，不是等着适合自己的需求再去实现。好了，牛逼吹完了，我该去给老板的iPhone7 Plus贴膜了。</p>
<p>2016年，技术爆发的一年。层出不穷的新技术令人眼花缭乱，swift出到3.0，每一版都像是一门新的语言；JavaScript和h5也日益繁荣，就像几年前的iOS；Python、PHP老牌语言和新秀Go语言也火的不要不要的了；iOS开发的热更新也花样繁多，JSPatch，今年年底滴滴的DynamicCocoa；跨平台的方式也越来越多，Facebook的React Native，阿里的Weex；还有年底微信横空出世的小程序……</p>
<p>我是一头赶上风口飓风的猪，压迫着骨子里的惰性努力瘦身，希望在风停的时候不至于摔死。2016年年底做的最正确的事就是购买域名搭建了自己的博客，这件本应早几年就做的事，一直拖到了现在。有了自己的博客和订阅号，还有github的小绿格子，在这些面子工程的倒逼下或许不会那么容易就轻言放弃。</p>
<p>2016再见，2017你好。新年愿望是：希望2017年的年终总结里没有懊悔。</p>
]]></content>
      <categories>
        <category>记事</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>私有API的使用</title>
    <url>/2016/12/28/%E7%A7%81%E6%9C%89API%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>私有API是指苹果未公开的一些方法，通常情况下这些方法不允许开发者使用，通常情况是指上架AppStore。私有API可以实现一些开放API不能实现的效果，功能强大，效果非凡。苹果不允许使用，是因为有些私有API会侵犯用户隐私，但使用私有API也并非一定会侵犯用户隐私，这要看开发者怎么用了。</p>
<a id="more"></a>

<p>企业级账号发布供内部人使用的APP，可以使用私有API。发布到其他APP平台供越狱手机下载的APP，也有可能使用了私有API。这两者没有苹果审核把关，私有API可以随便使用。<strong>苹果明令禁止使用私有API的APP上架AppStore！</strong>但凡事无绝对，AppStore上也不乏使用私有API的应用，使用办法有很多，比如热更新。不被苹果发现就行，发现了轻者下架，重者封号。</p>
<p>我想看看私有API到底能干些啥，写了一个测试私有API的小项目，涉及到的知识点大多数来源于网络，在此感谢大神们的知识共享。项目很小，知识很浅，欢迎拍砖吐槽。</p>
<p>项目代码: <a href="https://github.com/mxdios/privateApiApps" target="_blank" rel="noopener">privateApiApps</a></p>
<p>开发环境: Xcode 8.2.1，iPhone 6，iOS 10.2</p>
<p>项目截图:</p>
<table>
<thead>
<tr>
<th align="center"><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/WechatIMG241.jpeg" alt="获取iPhone上的所有APP"></th>
<th align="center"><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/WechatIMG242.jpeg" alt="APP相关信息"></th>
</tr>
</thead>
</table>
<p>参考资料:</p>
<ol>
<li><a href="https://github.com/nst/iOS-Runtime-Headers" target="_blank" rel="noopener">iOS-Runtime-Headers</a></li>
<li><a href="http://octree.me/2016/08/01/get-installed-apps/" target="_blank" rel="noopener">获取iOS设备上安装的应用列表</a></li>
</ol>
<h2 id="获取iPhone中安装的APP列表"><a href="#获取iPhone中安装的APP列表" class="headerlink" title="获取iPhone中安装的APP列表"></a>获取iPhone中安装的APP列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class LSAppClass &#x3D; objc_getClass(&quot;LSApplicationWorkspace&quot;);</span><br><span class="line">NSObject *workspace &#x3D; [LSAppClass performSelector:@selector(defaultWorkspace)];</span><br><span class="line">NSArray *appsArray &#x3D; [workspace performSelector:@selector(allApplications)];</span><br></pre></td></tr></table></figure>

<p>这里面使用了runtime的方法<code>- (id)performSelector:(SEL)aSelector;</code>，需要引入<code>&lt;objc/runtime.h&gt;</code>。该方法的作用是给接收者传递进去一个方法，返回值就是这个方法执行后的返回值。</p>
<p>由于调用的是私有API，传入的方法相当于一个字符串，编译器不会检测该方法是否正确，相反会一直报警告。例如上面传递的方法<code>defaultWorkspace</code>，这是个私有API的方法。通常还有另一种调用<code>performSelector</code>方法的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSObject *workspace &#x3D; [LSAppClass performSelector:NSSelectorFromString(@&quot;defaultWorkspace&quot;)];</span><br></pre></td></tr></table></figure>

<p>如果传递进去的私有API方法名写错了，程序就会找不到该方法而崩溃。所以通常会通过下面方法检测接收者或接收者的父类是否实现了传递进去的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ([LSAppClass respondsToSelector:@selector(defaultWorkspace)]) &#123;</span><br><span class="line">   	NSObject *workspace &#x3D; [LSAppClass performSelector:@selector(defaultWorkspace)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真实情况中，该方法并非必要。传入的私有API方法名都是固定的，程序崩溃了说明方法名写错了，改成正确的即可。使用该方法不会崩溃，反而不易发现错误。</p>
<h2 id="获取每个APP的相关信息"><a href="#获取每个APP的相关信息" class="headerlink" title="获取每个APP的相关信息"></a>获取每个APP的相关信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[appsArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;   </span><br><span class="line">	AppsObject *appsObj &#x3D; [[AppsObject alloc] init];</span><br><span class="line">	appsObj.appName &#x3D; [obj performSelector:@selector(localizedName)];</span><br><span class="line">	appsObj.version &#x3D; [obj performSelector:@selector(shortVersionString)];</span><br><span class="line">	appsObj.bundleId &#x3D; [obj performSelector:@selector(applicationIdentifier)];</span><br><span class="line">	appsObj.appFullName &#x3D; [obj performSelector:@selector(itemName)];</span><br><span class="line">	appsObj.appType &#x3D; [obj performSelector:@selector(applicationType)];</span><br><span class="line">	appsObj.appVendorName &#x3D; [obj performSelector:@selector(vendorName)];</span><br><span class="line">	appsObj.appRating &#x3D; [obj performSelector:@selector(ratingLabel)];</span><br><span class="line">	[_appsObjArray addObject:appsObj];</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>遍历获取的APP列表，通过私有API获取每个app的各种信息：</p>
<table>
<thead>
<tr>
<th align="left">私有API方法名</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">localizedName</td>
<td align="left">app名字</td>
</tr>
<tr>
<td align="left">shortVersionString</td>
<td align="left">版本号</td>
</tr>
<tr>
<td align="left">applicationIdentifier</td>
<td align="left">Bundle Identifier</td>
</tr>
<tr>
<td align="left">itemName</td>
<td align="left">app在AppStore显示的名字</td>
</tr>
<tr>
<td align="left">applicationType</td>
<td align="left">app类型,分为:System和User</td>
</tr>
<tr>
<td align="left">vendorName</td>
<td align="left">app供应商</td>
</tr>
<tr>
<td align="left">ratingLabel</td>
<td align="left">app评级</td>
</tr>
</tbody></table>
<h2 id="获取APP图标"><a href="#获取APP图标" class="headerlink" title="获取APP图标"></a>获取APP图标</h2><p>上述中并没有获取APP图标的方法，获取app图标比较麻烦。</p>
<h3 id="获取APP图标路径"><a href="#获取APP图标路径" class="headerlink" title="获取APP图标路径"></a>获取APP图标路径</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDictionary *dict &#x3D; [object performSelector:@selector(boundIconsDictionary)];</span><br><span class="line">NSString *appIconPath &#x3D; [NSString stringWithFormat:@&quot;%@&#x2F;%@.png&quot;,[[object performSelector:@selector(resourcesDirectoryURL)] path],[[[dict objectForKey:@&quot;CFBundlePrimaryIcon&quot;] objectForKey:@&quot;CFBundleIconFiles&quot;] lastObject]];</span><br></pre></td></tr></table></figure>

<p>iOS10.2亲测，该方法只能获取模拟器上的APP图标，真机无效。</p>
<h3 id="获取图标data数据"><a href="#获取图标data数据" class="headerlink" title="获取图标data数据"></a>获取图标data数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appsObj.iconData &#x3D; [obj performSelector:@selector(iconDataForVariant:) withObject:@(2)];</span><br></pre></td></tr></table></figure>

<p>该data数据并不能直接转为UIImage，需要对data数据进行截取转换，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (UIImage *)getAppIcon:(NSData *)iconData &#123;</span><br><span class="line">    NSInteger lenth &#x3D; iconData.length;</span><br><span class="line">    NSInteger width &#x3D; 87;</span><br><span class="line">    NSInteger height &#x3D; 87;</span><br><span class="line">    uint32_t *pixels &#x3D; (uint32_t *)malloc(width * height * sizeof(uint32_t));</span><br><span class="line">    [iconData getBytes:pixels range:NSMakeRange(32, lenth - 32)];</span><br><span class="line">    CGColorSpaceRef colorSpace &#x3D; CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    CGContextRef ctx &#x3D; CGBitmapContextCreate(pixels, width, height, 8, (width + 1) * sizeof(uint32_t), colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);</span><br><span class="line">    CGImageRef cgImage &#x3D; CGBitmapContextCreateImage(ctx);</span><br><span class="line">    CGContextRelease(ctx);</span><br><span class="line">    CGColorSpaceRelease(colorSpace);</span><br><span class="line">    UIImage *icon &#x3D; [UIImage imageWithCGImage: cgImage];</span><br><span class="line">    CGImageRelease(cgImage);</span><br><span class="line">    return icon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打开APP"><a href="#打开APP" class="headerlink" title="打开APP"></a>打开APP</h2><p>在iOS 9以后要想打开其他app需要添加URL Scheme，设置白名单，否则将无法打开，白名单的上限为50个。上文中我们可以获取APP的<code>Bundle Id</code>，依靠<code>Bundle Id</code>使用私有API可以打开其他APP，并没有数量限制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class LSAppClass &#x3D; NSClassFromString(@&quot;LSApplicationWorkspace&quot;);</span><br><span class="line">id workSpace &#x3D; [(id)LSAppClass performSelector:@selector(defaultWorkspace)];</span><br><span class="line">[workSpace performSelector:@selector(openApplicationWithBundleID:) withObject:self.appsObj.bundleId];</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>私有API</tag>
      </tags>
  </entry>
  <entry>
    <title>Quartz 2D（三）样式、阴影、渐变</title>
    <url>/2016/12/21/Quartz2D3/</url>
    <content><![CDATA[<h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><p>Pattern可翻译为样式、模型。类似于iOS中自定义的view，可以重复多次把自定义的view添加到控制器的view上。样式(Pattern)是绘制操作的一个序列，可以重复的绘制到一个图形上下文上。</p>
<a id="more"></a>

<h3 id="样式单元格"><a href="#样式单元格" class="headerlink" title="样式单元格"></a>样式单元格</h3><p>样式单元格是样式的基本组件，在创建的时候就要定义单元格的边界，并在这个范围内进行绘制。在图形上下文上绘制单元格时，可以随意指定两个单元格之间上下左右间距，也可以指定负数，单元格重合而已。像极了添加view控件。</p>
<h3 id="着色样式和模板样式"><a href="#着色样式和模板样式" class="headerlink" title="着色样式和模板样式"></a>着色样式和模板样式</h3><p>着色样式是有固定颜色的，在创建样式单元格的时候就指定其颜色了，跟绘制流程没有关系。</p>
<p>模板样式即为非着色样式，在创建样式单元格的时候只指定了形状，并没有指定颜色，在绘制过程中指定颜色。</p>
<p>在Quartz 2D中可以使用这两种样式实现样式绘图，将创建好的样式绘制到page上的过程称为平铺，有三种平铺选项：1、没有失真，2、最小的失真的恒定间距，3、恒定间距。</p>
<h3 id="绘制着色样式"><a href="#绘制着色样式" class="headerlink" title="绘制着色样式"></a>绘制着色样式</h3><p>绘制着色样式一般需要下面几步：1、设置样式单元格的回调函数，2、设置着色模式单元格，3、绘制操作。下面是绘制着色样式的示例代码和运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">    [super drawRect:rect];</span><br><span class="line">    CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">    clorePatternPaingting(context, CGRectMake(0, 0, 300, 500));</span><br><span class="line">&#125;</span><br><span class="line">void clorePatternPaingting(CGContextRef context, CGRect rect) &#123;</span><br><span class="line">    CGColorSpaceRef patternSpace &#x3D; CGColorSpaceCreatePattern(NULL);</span><br><span class="line">    CGContextSetFillColorSpace(context, patternSpace);</span><br><span class="line">    CGColorSpaceRelease(patternSpace);</span><br><span class="line">    static const CGPatternCallbacks call &#x3D; &#123;0, &amp;drawPattern, NULL&#125;;</span><br><span class="line">    CGPatternRef pattern &#x3D; CGPatternCreate(NULL, CGRectMake(0, 0, 30, 30), CGAffineTransformIdentity, 30, 30, kCGPatternTilingConstantSpacing, true, &amp;call);</span><br><span class="line">    CGFloat alpha &#x3D; 1.0;</span><br><span class="line">    CGContextSetFillPattern(context, pattern, &amp;alpha);</span><br><span class="line">    CGPatternRelease(pattern);</span><br><span class="line">    CGContextFillRect(context, rect);</span><br><span class="line">&#125;</span><br><span class="line">void drawPattern(void *info, CGContextRef context) &#123;</span><br><span class="line">    CGContextSetRGBFillColor(context, 1, 0, 0, 1);</span><br><span class="line">    CGContextFillRect(context, CGRectMake(0, 0, 10, 10));</span><br><span class="line">    CGContextSetRGBFillColor(context, 0, 1, 0, 1);</span><br><span class="line">    CGContextFillRect(context, CGRectMake(10, 0, 10, 10));</span><br><span class="line">    CGContextSetRGBFillColor(context, 0, 0, 1, 1);</span><br><span class="line">    CGContextFillRect(context, CGRectMake(0, 10, 10, 10));</span><br><span class="line">    CGContextSetRGBFillColor(context, 0.5, 0, 0.5, 1);</span><br><span class="line">    CGContextFillRect(context, CGRectMake(10, 10, 10, 10));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161220-0.png" alt="绘制着色模式的运行结果"></p>
<p><strong>代码解释：</strong></p>
<p>上述代码块中第三个函数<code>drawPattern</code>的作用就是第1步：设置样式单元格的回调函数。参数<code>info</code>:是指向模式相关数据的指针，可以传<code>NULL</code>。<code>context</code>:是图形上下文。在该函数中指定了每个颜色块的大小和填充色。因为是着色样式，所以指定填充色。</p>
<p>第二个函数，也是在<code>drawRect</code>方法中调用的函数<code>clorePatternPaingting</code>，执行了第2步:设置着色模式单元格和第3步:绘制操作。下面对每块代码进行解释：</p>
<p><strong>清空基本颜色空间：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGColorSpaceRef patternSpace &#x3D; CGColorSpaceCreatePattern(NULL);</span><br><span class="line">CGContextSetFillColorSpace(context, patternSpace);</span><br><span class="line">CGColorSpaceRelease(patternSpace);</span><br></pre></td></tr></table></figure>

<p>因为我们要使用着色样式里面的颜色，所以清空基本颜色空间，以确保着色样式上的颜色能显示。可以试一下把这段代码注释的结果，绘制着色样式的空间为黑色，因为基本颜色空间没清空也没着色，所以呈黑色。</p>
<p><strong>设置着色模式单元格：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const CGPatternCallbacks call &#x3D; &#123;0, &amp;drawPattern, NULL&#125;;</span><br><span class="line">CGPatternRef pattern &#x3D; CGPatternCreate(NULL, CGRectMake(0, 0, 30, 30), CGAffineTransformIdentity, 30, 30, kCGPatternTilingConstantSpacing, true, &amp;call);</span><br></pre></td></tr></table></figure>

<p>模式单元格的信息保存在<code>CGPatternRef</code>类型的<code>CGPattern</code>对象中，使用<code>CGPatternCreate</code>创建该对象。需要传入的参数依次解释为：</p>
<ol>
<li>info：是一个指针，指向我们要传递给绘制回调函数的数据。这里传的是<code>NULL</code></li>
<li>bound：指定模式单元格的大小</li>
<li>matrix：指定模式矩阵，它将模式坐标系统映射到图形上下文的默认坐标系统。如果希望两个坐标系统是一样的，则可以使用单位矩阵。</li>
<li>xStep, yStep：指定单元格之间的水平和竖直间距。</li>
<li>tiling：平铺模式，可以是kCGPatternTilingNoDistortion、kCGPatternTilingConstantSpacingMinimalDistortion、kCGPatternTilingConstantSpacing</li>
<li>isColored：指定模式单元格是着色模式(true)还是模板模式(false)</li>
<li>callbacks：是一个指向CGPatternCallbacks结构体的指针。格式如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct CGPatternCallbacks &#123;</span><br><span class="line">    unsigned int version;</span><br><span class="line">    CGPatternDrawPatternCallback __nullable drawPattern;</span><br><span class="line">    CGPatternReleaseInfoCallback __nullable releaseInfo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>version</code>一般设置为<code>0</code>，<code>drawPattern</code>是指向设置样式单元格的回调函数，<code>releaseInfo</code>是指向回调函数，释放CGPattern对象时调用，以释放存储在我们传递给绘制回调的info参数中的数据。如果在这个参数中没有传递任何数据传<code>NULL</code>。</p>
<p>所以<code>CGPatternCallbacks</code>结构体定义为<code>static const CGPatternCallbacks call = {0, &amp;drawPattern, NULL};</code></p>
<p><strong>绘制着色样式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGFloat alpha &#x3D; 1.0;</span><br><span class="line">CGContextSetFillPattern(context, pattern, &amp;alpha);</span><br><span class="line">CGPatternRelease(pattern);</span><br><span class="line">CGContextFillRect(context, rect);</span><br></pre></td></tr></table></figure>

<p>调用函数<code>CGContextSetFillPattern</code>使用着色样式进行填充操作，或者调用函数<code>CGContextSetStrokePattern</code>进行描边操作。需要指定着色样式在填充或描边过程的透明度。</p>
<p>样式使用完毕后需要释放，调用函数：<code>CGPatternRelease</code></p>
<p>将定义的着色样式使用函数<code>CGContextFillRect</code>填充到指定<code>rect</code>的矩形中。</p>
<p>这一系列操作都放到函数<code>clorePatternPaingting</code>内，在<code>drawRect</code>方法中直接调用该函数即可完成着色样式的定义和绘制。</p>
<h3 id="绘制模板样式"><a href="#绘制模板样式" class="headerlink" title="绘制模板样式"></a>绘制模板样式</h3><p>绘制模板样式的步骤和绘制着色样式的一样：1、设置样式单元格的回调函数，2、设置模板模式单元格，3、绘制操作。下面是绘制模板样式的示例代码和运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">    [super drawRect:rect];</span><br><span class="line">    CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">    stencilPatternPaingting(context, CGRectMake(0, 0, 300, 500));</span><br><span class="line">&#125;</span><br><span class="line">void stencilPatternPaingting(CGContextRef context, CGRect rect) &#123;</span><br><span class="line">    CGColorSpaceRef baseSpace &#x3D; CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    CGColorSpaceRef patternSpace &#x3D; CGColorSpaceCreatePattern(baseSpace);</span><br><span class="line">    CGContextSetFillColorSpace(context, patternSpace);</span><br><span class="line">    CGColorSpaceRelease(patternSpace);</span><br><span class="line">    CGColorSpaceRelease(baseSpace);</span><br><span class="line">    static const CGPatternCallbacks cell &#x3D; &#123;0, &amp;drawStencilPattern, NULL&#125;;</span><br><span class="line">    CGPatternRef pattern &#x3D; CGPatternCreate(NULL, CGRectMake(0, 0, 30, 30), CGAffineTransformIdentity, 40, 40, kCGPatternTilingConstantSpacing, false, &amp;cell);</span><br><span class="line">    static const CGFloat color[] &#x3D; &#123;1, 0, 0, 1&#125;;</span><br><span class="line">    CGContextSetFillPattern(context, pattern, color);</span><br><span class="line">    CGPatternRelease(pattern);</span><br><span class="line">    CGContextFillRect(context, rect);</span><br><span class="line">&#125;</span><br><span class="line">void drawStencilPattern(void *info, CGContextRef context) &#123;</span><br><span class="line">    CGContextAddEllipseInRect(context, CGRectMake(0, 0, 30, 30));</span><br><span class="line">    CGContextFillPath(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161220-1.png" alt="绘制模板样式的运行结果"></p>
<p>代码解释参考上文中着色样式的代码解释。区别1是用下述代码设置样式单元格的颜色：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static const CGFloat color[] &#x3D; &#123;1, 0, 0, 1&#125;;</span><br><span class="line">CGContextSetFillPattern(context, pattern, color);</span><br></pre></td></tr></table></figure>

<p>区别2是<code>CGPatternCreate</code>函数中传的参数是<code>false</code>。</p>
<h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>阴影有三个属性：x偏移量，y偏移量，模糊度</p>
<p>阴影通过函数<code>CGContextSetShadow</code>设置，指定图形上下文、x偏移量、y偏移量、模糊度。设置阴影后，绘制的对象都会有阴影，阴影的色值为0.3透明度的黑色，颜色RGBA值为{0, 0, 0, 0.3}。</p>
<p>也可以是使用函数<code>CGContextSetShadowWithColor</code>设置彩色阴影。</p>
<p>在调用<code>CGContextSetShadow</code>或<code>CGContextSetShadowWithColor</code>之前保存图形状态，可以通过恢复图形状态来关闭阴影。或者设置阴影颜色为<code>NULL</code>关闭阴影。</p>
<p>分别设置彩色阴影和普通阴影：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextSaveGState(context);</span><br><span class="line">CGContextSetShadowWithColor(context, CGSizeMake(10, 10), 2, [UIColor redColor].CGColor);</span><br><span class="line">CGContextSetRGBFillColor (context, 0, 1, 0, 1);</span><br><span class="line">CGContextAddEllipseInRect(context, CGRectMake(40, 40, 100, 100));</span><br><span class="line">CGContextFillPath(context);</span><br><span class="line">CGContextSetShadow(context, CGSizeMake(10, 10), 2);</span><br><span class="line">CGContextFillRect(context, CGRectMake(200, 40, 100, 100));</span><br><span class="line">CGContextRestoreGState(context);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161220-2.png" alt="圆形的红色阴影和矩形的灰色阴影"></p>
<p>x偏移量正值在图形右边，负值在图形左边。y偏移量和坐标有关，在iOS中，UIKit坐标系y轴和Quartz 2D坐标系y轴相反，所以如果是由UIKit创建的图形上下文则正值在图形下面，负值在图形上面。macOS的坐标系和Quartz 2D坐标系一样，所以正值在图形上面，负值在图形下面。阴影绘制不受CTM影响。</p>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>可以使用函数<code>CGShadingRef</code>和<code>CGGradientRef</code>创建渐变。渐变分为轴向渐变和径向渐变。渐变的颜色变化有很多，可以是一种颜色到另一种颜色过度，也可以是多种颜色依次过度变化，还有是一种颜色的透明度<code>alpha</code>变化，但是这种无法绘制到PDF上，无法打印。</p>
<p><code>CGShading</code>和<code>CGGradient</code>的区别：</p>
<table>
<thead>
<tr>
<th align="left">CGGradient</th>
<th align="left">CGShading</th>
</tr>
</thead>
<tbody><tr>
<td align="left">可以使用同一对象绘制轴向和径向梯度</td>
<td align="left">需要创建单独的对象的轴向和径向梯度</td>
</tr>
<tr>
<td align="left">在绘图时设置渐变的几何体</td>
<td align="left">在对象创建时间设置渐变的几何体</td>
</tr>
<tr>
<td align="left">Quartz计算梯度中每个点的颜色</td>
<td align="left">需要提供一个回调函数，用来计算渐变中每个点的颜色</td>
</tr>
<tr>
<td align="left">可以定义两个以上的位置和颜色</td>
<td align="left">需要设计回调，使用两个以上的位置和颜色</td>
</tr>
</tbody></table>
<h3 id="CGGradient"><a href="#CGGradient" class="headerlink" title="CGGradient"></a>CGGradient</h3><p>使用CGGradient创建渐变。</p>
<ol>
<li>首先调用函数<code>CGGradientCreateWithColorComponents</code>创建<code>CGGradient</code>对象，参数含义分别是：颜色空间、颜色数组（采用RGBA颜色）、位置数组（0.0-1.0之间的数值，0.0为轴线起点，1.0为轴线终点。传递NULL默认0为起始位置，1为终点位置，相当于{0.0, 1.0}）、数组中元素个数。</li>
<li>调用<code>CGContextDrawLinearGradient</code>函数绘制轴向渐变或<code>CGContextDrawRadialGradient</code>函数绘制径向渐变，参数含义分别是：图形上下文、<code>CGGradient</code>对象、起始位置、终止位置、绘图选项。</li>
<li>绘制完毕后，释放颜色空间和<code>CGGradient</code>对象。</li>
</ol>
<p>绘制轴向渐变:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">CGFloat compoents[] &#x3D; &#123;1,0,1,1, 0.3,0.5,1,1.0&#125;;</span><br><span class="line">CGFloat locations[] &#x3D; &#123;0.0, 1.0&#125;;</span><br><span class="line">CGColorSpaceRef colorSpace &#x3D; CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);</span><br><span class="line">CGGradientRef gradient &#x3D; CGGradientCreateWithColorComponents(colorSpace, compoents, locations, 2);</span><br><span class="line">CGContextDrawLinearGradient(context, gradient, CGPointMake(0, 0), CGPointMake(0, 100), kCGGradientDrawsBeforeStartLocation);</span><br><span class="line">CGColorSpaceRelease(colorSpace);</span><br><span class="line">CGGradientRelease(gradient);</span><br></pre></td></tr></table></figure>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161221-0.png" alt="使用CGGradient绘制轴向渐变"></p>
<p>绘制径向渐变:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">CGFloat compoents[] &#x3D; &#123;1,0,1,1, 0.3,0.5,1,1.0&#125;;</span><br><span class="line">CGFloat locations[] &#x3D; &#123;0.0, 1.0&#125;;</span><br><span class="line">CGColorSpaceRef colorSpace &#x3D; CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);</span><br><span class="line">CGGradientRef gradient &#x3D; CGGradientCreateWithColorComponents(colorSpace, compoents, locations, 2);</span><br><span class="line">CGContextDrawRadialGradient(context, gradient, CGPointMake(200, 50), 20, CGPointMake(200, 400), 70, kCGGradientDrawsAfterEndLocation);</span><br><span class="line">CGColorSpaceRelease(colorSpace);</span><br><span class="line">CGGradientRelease(gradient);</span><br></pre></td></tr></table></figure>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161221-1.png" alt="使用CGGradient绘制径向渐变"></p>
<h3 id="CGShading"><a href="#CGShading" class="headerlink" title="CGShading"></a>CGShading</h3><p>绘制轴向渐变需要以下步骤：</p>
<ol>
<li>设置 CGFunction 对象来计算颜色值</li>
<li>创建轴向渐变的 CGShading 对象</li>
<li>裁减上下文</li>
<li>使用 CGShading 对象来绘制轴向渐变</li>
<li>释放对象</li>
</ol>
<p>绘制轴向渐变完整代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">    [super drawRect:rect];</span><br><span class="line">    CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">    CGColorSpaceRef colorspace &#x3D; CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    CGFunctionRef functionObj &#x3D; getFunction(colorspace);</span><br><span class="line">    CGShadingRef shading &#x3D; CGShadingCreateAxial(colorspace, CGPointMake(0, 0.5), CGPointMake(1, 0.5), functionObj, false, false);</span><br><span class="line">    CGAffineTransform myTransform &#x3D; CGAffineTransformMakeScale(100, 100);</span><br><span class="line">    CGContextConcatCTM (context, myTransform);</span><br><span class="line">    CGContextSaveGState (context);</span><br><span class="line">    CGContextBeginPath(context);</span><br><span class="line">    CGContextAddArc(context,  .5, .5, .3, 0, M_PI, 0);</span><br><span class="line">    CGContextClosePath(context);</span><br><span class="line">    CGContextClip(context);</span><br><span class="line">    CGContextDrawShading(context, shading);</span><br><span class="line">    CGShadingRelease(shading);</span><br><span class="line">    CGColorSpaceRelease(colorspace);</span><br><span class="line">    CGFunctionRelease(functionObj);</span><br><span class="line">    CGContextRestoreGState (context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static CGFunctionRef getFunction(CGColorSpaceRef colorspace) &#123;</span><br><span class="line">    size_t numComponents &#x3D; 1 + CGColorSpaceGetNumberOfComponents(colorspace);</span><br><span class="line">    CGFloat input_value_range[] &#x3D; &#123;0, 1&#125;;</span><br><span class="line">    CGFloat output_value_range[] &#x3D; &#123;0, 1, 0, 0, 0,0,1,1&#125;;</span><br><span class="line">    CGFunctionCallbacks callbacks &#x3D; &#123;0, &amp;calculateShadingValues, NULL&#125;;</span><br><span class="line">    return CGFunctionCreate((void *) numComponents, 1, input_value_range, numComponents, output_value_range, &amp;callbacks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void calculateShadingValues(void *info, const CGFloat *in, CGFloat *out) &#123;</span><br><span class="line">    CGFloat v;</span><br><span class="line">    size_t k, compoents;</span><br><span class="line">    static const CGFloat c[] &#x3D; &#123;1,0,0.5,1&#125;;</span><br><span class="line">    compoents &#x3D; (size_t)info;</span><br><span class="line">    v &#x3D; *in;</span><br><span class="line">    for (k &#x3D; 0; k &lt; compoents - 1; k ++)</span><br><span class="line">        *out ++ &#x3D; c[k] * v;</span><br><span class="line">    *out++ &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161221-2.png" alt="使用CGShading绘制轴向渐变"></p>
<p>绘制径向渐变，需要以下步骤：</p>
<ol>
<li>设置 CGFunction 对象来计算颜色值</li>
<li>创建径向渐变的 CGShading 对象</li>
<li>使用 CGShading 对象来绘制径向渐变</li>
<li>释放对象</li>
</ol>
<p>绘制径向渐变完整代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">    [super drawRect:rect];</span><br><span class="line"></span><br><span class="line">    CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">    </span><br><span class="line">    CGColorSpaceRef colorspace &#x3D; CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    CGFunctionRef functionObj &#x3D; getFunction(colorspace);</span><br><span class="line">    CGShadingRef shading &#x3D; CGShadingCreateRadial(colorspace, CGPointMake(0.25, 0.3), 0.1, CGPointMake(0.7, 0.7), 0.25, functionObj, false, false);</span><br><span class="line"></span><br><span class="line">    CGAffineTransform myTransform &#x3D; CGAffineTransformMakeScale(100, 100);</span><br><span class="line">    CGContextConcatCTM (context, myTransform);</span><br><span class="line">    CGContextSaveGState (context);</span><br><span class="line">    </span><br><span class="line">    CGContextClipToRect (context, CGRectMake(0, 0, 1, 1));</span><br><span class="line">    CGContextSetRGBFillColor (context, 1, 1, 1, 1);</span><br><span class="line">    CGContextFillRect (context, CGRectMake(0, 0, 1, 1));</span><br><span class="line">    </span><br><span class="line">    CGContextDrawShading(context, shading);</span><br><span class="line">    </span><br><span class="line">    CGShadingRelease(shading);</span><br><span class="line">    CGColorSpaceRelease(colorspace);</span><br><span class="line">    CGFunctionRelease(functionObj);</span><br><span class="line">    CGContextRestoreGState (context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static CGFunctionRef getFunction(CGColorSpaceRef colorspace) &#123;</span><br><span class="line">    size_t numComponents &#x3D; 1 + CGColorSpaceGetNumberOfComponents(colorspace);</span><br><span class="line">    </span><br><span class="line">    CGFloat input_value_range[] &#x3D; &#123;0, 1&#125;;</span><br><span class="line">    CGFloat output_value_range[] &#x3D; &#123;0, 1, 0, 0, 0,0,1,1&#125;;</span><br><span class="line">    </span><br><span class="line">    CGFunctionCallbacks callbacks &#x3D; &#123;0, &amp;calculateShadingValues, NULL&#125;;</span><br><span class="line">    return CGFunctionCreate((void *) numComponents, 1, input_value_range, numComponents, output_value_range, &amp;callbacks);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void calculateShadingValues(void *info, const CGFloat *in, CGFloat *out) &#123;</span><br><span class="line">    </span><br><span class="line">    size_t k, compoents;</span><br><span class="line">    double frequency[] &#x3D; &#123;55, 220, 110, 0&#125;;</span><br><span class="line">    compoents &#x3D; (size_t)info;</span><br><span class="line">    for (k &#x3D; 0; k &lt; compoents - 1; k ++)</span><br><span class="line">        *out++ &#x3D; (1 + sin(*in * frequency[k])) &#x2F; 2;</span><br><span class="line">    *out++ &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161221-3.png" alt="使用CGShading绘制径向渐变"></p>
<hr>
<p>参考文章：<a href="http://southpeak.github.io/categories/translate/" target="_blank" rel="noopener">南峰子翻译的Quartz2D编程指南</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Quartz2D</tag>
      </tags>
  </entry>
  <entry>
    <title>Quartz 2D（二）颜色和颜色空间、变换</title>
    <url>/2016/12/19/Quartz2D2/</url>
    <content><![CDATA[<h2 id="颜色和颜色空间"><a href="#颜色和颜色空间" class="headerlink" title="颜色和颜色空间"></a>颜色和颜色空间</h2><p>不同设备的颜色处理方式各不相同，每种设备都有各自的颜色值范围。就是使用指定函数解析一组数值组成的颜色信息，比如RGB颜色、CMYK颜色。</p>
<a id="more"></a>

<p>在不同颜色空间下，蓝色的色值</p>
<table>
<thead>
<tr>
<th align="left">颜色空间</th>
<th align="left">蓝色的色值</th>
<th align="left">色值对应的参数含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HSB</td>
<td align="left">240度，100%，100%</td>
<td align="left">色相，饱和度，亮度</td>
</tr>
<tr>
<td align="left">RGB</td>
<td align="left">0，0，1</td>
<td align="left">红，绿，蓝</td>
</tr>
<tr>
<td align="left">CMYK</td>
<td align="left">1，1，0，0</td>
<td align="left">蓝绿、品红、黄、黑</td>
</tr>
<tr>
<td align="left">BGR</td>
<td align="left">1，0，0</td>
<td align="left">蓝，绿，红</td>
</tr>
</tbody></table>
<h2 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h2><p>使用函数<code>CGContextSetAlpha</code>设置全局透明度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextSetAlpha(context, 0.5);</span><br></pre></td></tr></table></figure>

<p>使用函数<code>CGContextClearRect</code>清除图形上下文的alpha通道。在创建透明遮罩或者窗口完全透明的时候使用。</p>
<h2 id="创建颜色空间"><a href="#创建颜色空间" class="headerlink" title="创建颜色空间"></a>创建颜色空间</h2><h3 id="设备依赖颜色空间"><a href="#设备依赖颜色空间" class="headerlink" title="设备依赖颜色空间"></a>设备依赖颜色空间</h3><p><strong>iOS不支持设备依赖颜色空间。</strong></p>
<ol>
<li>lba非线性转换，使用<code>CGColorSpaceCreateLab</code>创建</li>
<li>ICC颜色空间，国际色彩联盟定义的，使用<code>CGColorSpaceCreateICCBased</code>创建</li>
<li>标准化RGB颜色空间，使用<code>CGColorSpaceCreateCalibratedRGB</code>创建</li>
<li>标准化灰度颜色空间，使用<code>CGColorSpaceCreateCalibratedGray</code>创建</li>
</ol>
<h3 id="通用颜色空间"><a href="#通用颜色空间" class="headerlink" title="通用颜色空间"></a>通用颜色空间</h3><p><strong>iOS不支持通用颜色空间。</strong></p>
<p>但是macOS应用程序通常情况下使用通用颜色空间，而不使用设备颜色空间。</p>
<p>使用函数<code>CGColorSpaceCreateWithName</code>创建通用颜色空间，传入固定常量：</p>
<ol>
<li><code>kCGColorSpaceGenericGray</code>，指定通用灰色</li>
<li><code>kCGColorSpaceGenericRGB</code>，指定通用RGB</li>
<li><code>kCGColorSpaceGenericCMYK</code>，指定通用CMYK</li>
</ol>
<h3 id="设备颜色空间"><a href="#设备颜色空间" class="headerlink" title="设备颜色空间"></a>设备颜色空间</h3><p>设备颜色空间主要用于IOS应用程序。通过以下函数创建设备颜色空间：</p>
<p><code>CGColorSpaceCreateDeviceGray</code> 创建设备依赖灰度颜色空间。</p>
<p>快速设置依赖灰度颜色空间的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextSetGrayStrokeColor(context, 0.5, 1);</span><br><span class="line">CGContextSetGrayFillColor(context, 0.5, 1);</span><br></pre></td></tr></table></figure>

<p>还可以使用该函数获取灰度图片，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UIImage *)getGrayImage:(UIImage*)sourceImage &#123;</span><br><span class="line">    CGFloat width &#x3D; sourceImage.size.width;</span><br><span class="line">    CGFloat height &#x3D; sourceImage.size.height;</span><br><span class="line">    CGColorSpaceRef colorSpace &#x3D; CGColorSpaceCreateDeviceGray();</span><br><span class="line">    CGContextRef context &#x3D; CGBitmapContextCreate(nil,width,height,8,0,colorSpace,kCGImageAlphaNone);</span><br><span class="line">    CGColorSpaceRelease(colorSpace);</span><br><span class="line">    if (context &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    CGContextDrawImage(context,CGRectMake(0, 0, width, height), sourceImage.CGImage);</span><br><span class="line">    UIImage *grayImage &#x3D; [UIImage imageWithCGImage:CGBitmapContextCreateImage(context)];</span><br><span class="line">    CGContextRelease(context);</span><br><span class="line">    return grayImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161215-0.png" alt="正常图片和灰度处理的图片"></p>
<p><code>CGColorSpaceCreateDeviceRGB</code> 创建设备依赖RGB颜色空间，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">CGFloat colors[4] &#x3D; &#123;0.3, 1.0, 0.9, 1.0&#125;;</span><br><span class="line">CGColorSpaceRef colorSpace &#x3D; CGColorSpaceCreateDeviceRGB();</span><br><span class="line">CGColorRef color &#x3D; CGColorCreate(colorSpace, colors);</span><br><span class="line">CGContextSetFillColorWithColor(context, color);</span><br><span class="line">CGContextFillRect(context, CGRectMake(100, 50, 100, 50));</span><br><span class="line">CGColorSpaceRelease(colorSpace);</span><br><span class="line">CGColorRelease(color);</span><br></pre></td></tr></table></figure>

<p>以及快速设置设备依赖RGB颜色空间的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextSetRGBStrokeColor(context, 0.3, 1.0, 0.9, 1.0);</span><br><span class="line">CGContextSetRGBFillColor(context, 0.3, 1.0, 0.9, 1.0);</span><br></pre></td></tr></table></figure>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161215-1.png" alt="设备依赖RGB颜色空间"></p>
<p><code>CGColorSpaceCreateDeviceCMYK</code> 创建设备依赖CMYK颜色空间，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">CGFloat colors[] &#x3D; &#123;80, 100, 0, 0, 1.0&#125;;</span><br><span class="line">CGColorSpaceRef colorSpace &#x3D; CGColorSpaceCreateDeviceCMYK();</span><br><span class="line">CGColorRef color &#x3D; CGColorCreate(colorSpace, colors);</span><br><span class="line">CGContextSetFillColorWithColor(context, color);</span><br><span class="line">CGContextFillRect(context, CGRectMake(100, 50, 100, 50));</span><br><span class="line">CGColorSpaceRelease(colorSpace);</span><br><span class="line">CGColorRelease(color);</span><br></pre></td></tr></table></figure>

<p>以及快速设置设备依赖CMYK颜色空间的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextSetCMYKStrokeColor(context, 80, 100, 0, 0, 1.0);</span><br><span class="line">CGContextSetCMYKFillColor(context, 80, 100, 0, 0, 1.0);</span><br></pre></td></tr></table></figure>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161215-2.png" alt="设备依赖CMYK颜色空间"></p>
<h2 id="设置和创建颜色"><a href="#设置和创建颜色" class="headerlink" title="设置和创建颜色"></a>设置和创建颜色</h2><p>通过函数<code>CGContextSetStrokeColorWithColor</code>和<code>CGContextSetFillColorWithColor</code>分别填充路径颜色和设置线框颜色。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextSetLineWidth(context, 20);</span><br><span class="line">CGContextAddRect(context, CGRectMake(100, 50, 100, 50));</span><br><span class="line">CGContextSetStrokeColorWithColor(context, [UIColor blueColor].CGColor);</span><br><span class="line">CGContextStrokePath(context);</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor);    </span><br><span class="line">CGContextFillRect(context, CGRectMake(100, 50, 100, 50));</span><br></pre></td></tr></table></figure>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161215-3.png" alt="填充路径设置线框"></p>
<h2 id="设置再现意图"><a href="#设置再现意图" class="headerlink" title="设置再现意图"></a>设置再现意图</h2><p>“再现意图”用于指定如何将源颜色空间的颜色映射到图形上下文的目标颜色空间的颜色范围内。调用函数<code>CGContextSetRenderingIntent</code>设置再现意图，传入枚举类型<code>CGColorRenderingIntent</code></p>
<ol>
<li>kCGRenderingIntentDefault：使用默认的渲染意图。</li>
<li>kCGRenderingIntentAbsoluteColorimetric：绝对色度渲染意图。将输出设备颜色域外的颜色映射为输出设备域内与之最接近的颜色。这可以产生一个裁减效果，因为色域外的两个不同的颜色值可能被映射为色域内的同一个颜色值。当图形使用的颜色值同时包含在源色域及目标色域内时，这种方法是最好的。常用于logo或者使用专色(spot color)时。</li>
<li>kCGRenderingIntentRelativeColorimetric：相对色度渲染意图。转换所有的颜色(包括色域内的)，以补偿图形上下文的白点与输出设备白点之间的色差。kCGRenderingIntentPerceptual：感知渲染意图。通过压缩图形上下文的色域来适应输出设备的色域，并保持源颜色空间的颜色之间的相对性。感知渲染意图适用于相片及其它复杂的高细度图片。</li>
<li>kCGRenderingIntentSaturation：饱和度渲染意图。把颜色转换到输出设备色域内时，保持颜色的相对饱和度。结果是包含亮度、饱和度颜色的图片。饱和度意图适用于生成低细度的图片，如描述性图表。</li>
</ol>
<h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><p>变换是使用Quartz内置的变换函数对绘图进行平移、旋转和缩放变换。</p>
<h2 id="修改CTM"><a href="#修改CTM" class="headerlink" title="修改CTM"></a>修改CTM</h2><p>CTM是Current Transformation Matrix，当前变换矩阵。可以操作CTM来平移、旋转、缩放page，绘制对象在page上，自然也会变换。</p>
<p>通过<code>CGContextDrawImage</code>函数绘制图片到page上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextDrawImage(context, CGRectMake(20, 40, 100, 150), [UIImage imageNamed:@&quot;img&quot;].CGImage);</span><br></pre></td></tr></table></figure>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161215-4.png" alt="将图片绘制到page上"></p>
<p>可以看到，图片是上下颠倒的。是因为iOS的UIKit坐标是以左上角为原点，y轴向下，Quartz 2D的图形绘制引擎坐标是左下角为原点，y轴向上。因为坐标轴上下相反，所以图片上下颠倒。macOS的坐标布局和Quartz 2D一样，以左下角为坐标原点，y轴向上。</p>
<p>注意要先进行CTM变换操作，再<code>CGContextDrawImage</code>画图。</p>
<h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><p>调用函数<code>CGContextTranslateCTM</code>指定沿x轴和y轴的平移位置。沿x轴平移100，沿y轴平移50：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextTranslateCTM(context, 100, 50);</span><br></pre></td></tr></table></figure>

<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>调用函数<code>CGContextRotateCTM</code>指定旋转角度，是以坐标原点为中心，旋转指定角度。这个坐标原点是指iOS的UIKit的左上角坐标原点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRotateCTM(context, M_PI_4);</span><br></pre></td></tr></table></figure>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161215-5.png" alt="旋转前与旋转后的图片比较"></p>
<p>函数传入的是弧度值，可以定义以下方法，传入角度值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static inline double radians (double degrees) &#123;return degrees * M_PI&#x2F;180;&#125;</span><br></pre></td></tr></table></figure>

<p>等价于上面的旋转函数调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRotateCTM(context, radians(45.));</span><br></pre></td></tr></table></figure>

<h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>调用函数<code>CGContextScaleCTM</code>实现缩放操作，也是以坐标原点为中心，x，y，w，h皆缩放为指定比例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextScaleCTM(context, 0.5, 0.5);</span><br></pre></td></tr></table></figure>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161215-6.png" alt="缩放前后的图片比较"></p>
<h3 id="累计变换操作"><a href="#累计变换操作" class="headerlink" title="累计变换操作"></a>累计变换操作</h3><p>上文说道，使用<code>CGContextDrawImage</code>函数画的图片上下颠倒，可以使用累计变换操作将图片扶正。累计变换操作的执行顺序不同，会导致不同结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGRect imgRect &#x3D; CGRectMake(100, 40, 100, 130);</span><br><span class="line">CGContextTranslateCTM(context, imgRect.size.width + imgRect.origin.x * 2, imgRect.size.height + imgRect.origin.y * 2);</span><br><span class="line">CGContextRotateCTM(context, M_PI);</span><br><span class="line">CGContextDrawImage(context, imgRect, [UIImage imageNamed:@&quot;img&quot;].CGImage);</span><br></pre></td></tr></table></figure>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161216-0.png" alt="图片扶正结果"></p>
<h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>仿射变换可以实现与CTM函数相同的变换操作，使用仿射变换函数构造矩阵，调用函数<code>CGContextConcatCTM</code>应用于CTM，达到变换效果。</p>
<p>仿射变换函数：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CGAffineTransformMakeTranslation</td>
<td align="left">构造平移矩阵，指定移动x,y值</td>
</tr>
<tr>
<td align="left">CGAffineTransformTranslate</td>
<td align="left">在现有的变换操作基础上使用平移操作</td>
</tr>
<tr>
<td align="left">CGAffineTransformMakeRotation</td>
<td align="left">构造旋转矩阵，指定旋转弧度</td>
</tr>
<tr>
<td align="left">CGAffineTransformRotate</td>
<td align="left">在现有的变换操作基础上使用旋转操作</td>
</tr>
<tr>
<td align="left">CGAffineTransformMakeScale</td>
<td align="left">构造缩放矩阵，指定x,y拉伸或收缩坐标</td>
</tr>
<tr>
<td align="left">CGAffineTransformScale</td>
<td align="left">在现有的变换操作基础上使用旋转操作</td>
</tr>
</tbody></table>
<p>构造变换矩阵的函数应用，执行结果和上文中图片一样，等价于上文中CTM函数变换操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;平移</span><br><span class="line">CGAffineTransform translation &#x3D; CGAffineTransformMakeTranslation(100, 50);</span><br><span class="line">CGContextConcatCTM(context, translation);</span><br><span class="line">&#x2F;&#x2F;旋转</span><br><span class="line">CGAffineTransform rotation &#x3D; CGAffineTransformMakeRotation(M_PI_4);</span><br><span class="line">CGContextConcatCTM(context, rotation);</span><br><span class="line">&#x2F;&#x2F;缩放</span><br><span class="line">CGAffineTransform scale &#x3D; CGAffineTransformMakeScale(0.5, 0.5);</span><br><span class="line">CGContextConcatCTM(context, scale);</span><br></pre></td></tr></table></figure>

<p>在当前变换的基础上叠加变换操作，和上文中的累计变换操作等价：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGAffineTransform translate &#x3D; CGAffineTransformTranslate(CGContextGetCTM(context), 100, 50);</span><br><span class="line">CGAffineTransform rotate &#x3D; CGAffineTransformRotate(translate, M_PI_4);</span><br><span class="line">CGAffineTransform scale &#x3D; CGAffineTransformScale(rotate, 0.5, 0.5);</span><br><span class="line">CGContextConcatCTM(context, scale);</span><br></pre></td></tr></table></figure>

<hr>
<p>参考文章：<a href="http://southpeak.github.io/categories/translate/" target="_blank" rel="noopener">南峰子翻译的Quartz2D编程指南</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Quartz2D</tag>
      </tags>
  </entry>
  <entry>
    <title>Quartz 2D（一）概念、图形上下文、路径</title>
    <url>/2016/12/13/Quartz2D1/</url>
    <content><![CDATA[<p>Quartz 2D是二维图形绘制引擎，可以实现N多图形图像的操作功能，如基本路径的绘制、透明度、描影、绘制阴影、透明层、颜色管理、反锯齿、PDF文档生成和PDF元数据访问。</p>
<a id="more"></a>

<h2 id="画布Page"><a href="#画布Page" class="headerlink" title="画布Page"></a>画布Page</h2><p>在图像操作过程中使用了<code>绘画者模型</code>，绘制过程是将绘制层铺到画布上，这个画布称为<code>Page</code>。类似于Photoshop中，将每个图层叠加放在画布上，形成最后的图像。</p>
<h2 id="图形上下文Graphics-Context"><a href="#图形上下文Graphics-Context" class="headerlink" title="图形上下文Graphics Context"></a>图形上下文Graphics Context</h2><p><code>图形上下文(Graphics Context)</code>是一个数据类型<code>CGContextRef</code>，它存放了Quartz 2D绘制的图形输出信息，可以看做是图形到设备输出的介质工具。Quartz 2D绘制的图形可以放到多种设备上，比如：PDF文件、显示器窗口、bitmap(位图)、view的Layer层等等，这就需要不同的<code>Graphics Context</code>来完成输出到不同设备上的工作。这好比人要上高速需要汽车，去海上需要船，去天空需要飞机，这里人相当于图形，高速路、海、天空相当于设备，而汽车、船、飞机就是<code>Graphics Context</code>。</p>
<p><code>Graphics Context</code>的几种类型</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Bitmap <span class="keyword">Graphics</span> <span class="keyword">Context</span></span><br><span class="line"><span class="number">2.</span> <span class="keyword">PDF</span> <span class="keyword">Graphics</span> <span class="keyword">Context</span></span><br><span class="line"><span class="number">3.</span> Window <span class="keyword">Graphics</span> <span class="keyword">Context</span></span><br><span class="line"><span class="number">4.</span> Layer <span class="keyword">Context</span></span><br><span class="line"><span class="number">5.</span> Post <span class="keyword">Graphics</span> <span class="keyword">Context</span></span><br></pre></td></tr></table></figure>

<h2 id="Quartz-2D的数据类型"><a href="#Quartz-2D的数据类型" class="headerlink" title="Quartz 2D的数据类型"></a>Quartz 2D的数据类型</h2><p>Quartz 2D API属于Code Graphics框架，所以Quartz 2D的数据类型是以CG开头的。有以下数据类型：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">CGPathRef</span>：用于向量图，可创建路径，并进行填充或描画(stroke)</span><br><span class="line"><span class="number">2.</span> <span class="built_in">CGImageRef</span>：用于表示bitmap图像和基于采样数据的bitmap图像遮罩。</span><br><span class="line"><span class="number">3.</span> <span class="built_in">CGLayerRef</span>：用于表示可用于重复绘制(如背景)和幕后(offscreen)绘制的绘画层</span><br><span class="line"><span class="number">4.</span> <span class="built_in">CGPatternRef</span>：用于重绘图</span><br><span class="line"><span class="number">5.</span> <span class="built_in">CGShadingRef</span>、<span class="built_in">CGGradientRef</span>：用于绘制渐变</span><br><span class="line"><span class="number">6.</span> <span class="built_in">CGFunctionRef</span>：用于定义回调函数，该函数包含一个随机的浮点值参数。当为阴影创建渐变时使用该类型</span><br><span class="line"><span class="number">7.</span> <span class="built_in">CGColorRef</span>, <span class="built_in">CGColorSpaceRef</span>：用于告诉Quartz如何解释颜色</span><br><span class="line"><span class="number">8.</span> <span class="built_in">CGImageSourceRef</span>,<span class="built_in">CGImageDestinationRef</span>：用于在Quartz中移入移出数据</span><br><span class="line"><span class="number">9.</span> <span class="built_in">CGFontRef</span>：用于绘制文本</span><br><span class="line"><span class="number">10.</span> <span class="built_in">CGPDFDictionaryRef</span>, <span class="built_in">CGPDFObjectRef</span>, <span class="built_in">CGPDFPageRef</span>, <span class="built_in">CGPDFStream</span>, <span class="built_in">CGPDFStringRef</span>, and <span class="built_in">CGPDFArrayRef</span>：用于访问PDF的元数据</span><br><span class="line"><span class="number">11.</span> <span class="built_in">CGPDFScannerRef</span>, <span class="built_in">CGPDFContentStreamRef</span>：用于解析PDF元数据</span><br><span class="line"><span class="number">12.</span> <span class="built_in">CGPSConverterRef</span>：用于将PostScript转化成PDF。在iOS中不能使用。</span><br></pre></td></tr></table></figure>

<h2 id="图形状态"><a href="#图形状态" class="headerlink" title="图形状态"></a>图形状态</h2><p>Quartz通过修改图形状态来修改绘制结果，图形状态直接决定了图形的最终渲染结果。图形状态包含用于绘制程序的参数，绘制参数改变了，图形自然就变了。比如修改了填充色值，图形颜色就变了。</p>
<h2 id="iOS中使用Graphics-Context绘制图形"><a href="#iOS中使用Graphics-Context绘制图形" class="headerlink" title="iOS中使用Graphics Context绘制图形"></a>iOS中使用Graphics Context绘制图形</h2><p>在iOS中要想用Quartz 2D在屏幕上绘图，需要自定义一个UIView，在UIView的<code>- (void)drawRect:(CGRect)rect</code>方法中实现绘图操作，这个方法会在UIView显示在屏幕上和需要被刷新的时候调用。创建上下文的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">    CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上下文中绘制图形：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">    &#x2F;&#x2F;获取图形上下文</span><br><span class="line">    CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">    &#x2F;&#x2F;设置红色透明度0.5的填充色</span><br><span class="line">    CGContextSetRGBFillColor(context, 1, 0, 0, 0.5);</span><br><span class="line">    &#x2F;&#x2F;填充一个矩形frame为(10, 20, 100, 40)</span><br><span class="line">    CGContextFillRect(context, CGRectMake(10, 20, 100, 40));</span><br><span class="line">    &#x2F;&#x2F;设置蓝色透明度0.5的填充色</span><br><span class="line">    CGContextSetRGBFillColor(context, 0, 0, 1, 0.5);</span><br><span class="line">    &#x2F;&#x2F;填充一个矩形frame为(10, 20, 40,  100)</span><br><span class="line">    CGContextFillRect(context, CGRectMake(10, 20, 40, 100));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161209-0.png?raw=true" alt="显示结果"></p>
<p>注意：设置填充色和填充矩形的方法顺序不能颠倒，不然填充色填充不到想填充的矩形中。得不到填充色填充的会是黑色。</p>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>路径可以构建出多种图形，可以是点、直线、弧线、不规则线、规则或不规则形状，可以对闭合路径进行填充行程面。使用路径绘制出想要的图形，有两步：创建路径和绘制路径。创建出点、线等路径，使用函数<code>CGContextDrawPath</code>绘制路径。</p>
<h3 id="点"><a href="#点" class="headerlink" title="点"></a>点</h3><p>点是依靠x、y值固定的位置，可作为路径的起始点位置。比如要画一个线段，必须要有一个起点和一个终点，两点确定一条线段。使用函数<code>CGContextMoveToPoint</code>来确定起始点，传入图形上下文和x,y坐标点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;确定一个坐标为(10,10)的点</span><br><span class="line">CGContextMoveToPoint(context, 10, 10);</span><br></pre></td></tr></table></figure>

<h3 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h3><p>有起始点，再指定一个终点位置就能确定一条直线了，使用函数<code>CGContextAddLineToPoint</code>来指定终点位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">	  &#x2F;&#x2F;获取图形上下文</span><br><span class="line">    CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">    &#x2F;&#x2F;设置起点</span><br><span class="line">    CGContextMoveToPoint(context, 20, 20);</span><br><span class="line">    &#x2F;&#x2F;起点延长至终点位置</span><br><span class="line">    CGContextAddLineToPoint(context, 50, 50);</span><br><span class="line">    &#x2F;&#x2F;绘制路径</span><br><span class="line">    CGContextDrawPath(context, kCGPathStroke);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>CGContextAddLineToPoint</code>函数指定多个位置点，线段会一个接一个画下去，形成折线图形。也可以使用<code>CGContextAddLines</code>函数一次性指定多个位置点，完成折线图形，此时无需指定起始点，第一个点默认为起始点(即使用<code>CGContextMoveToPoint</code>指定起始点也无效)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一个一个点继续加</span><br><span class="line">CGContextMoveToPoint(context, 20, 20);    </span><br><span class="line">CGContextAddLineToPoint(context, 50, 50);</span><br><span class="line">CGContextAddLineToPoint(context, 30, 80);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;一次性指定多个点</span><br><span class="line">CGPoint pos[3] &#x3D; &#123;CGPointMake(80, 20), CGPointMake(20, 50), CGPointMake(100, 200)&#125;;</span><br><span class="line">CGContextAddLines(context, pos, 3);</span><br></pre></td></tr></table></figure>

<p>由于<code>CGContextAddLineToPoint</code>函数必须得有<code>CGContextMoveToPoint</code>函数固定起始点，<code>CGContextAddLines</code>函数默认第一个点为起始点，所以<code>CGContextAddLines</code>后面可以跟着<code>CGContextAddLineToPoint</code>继续加点画线，能连成一组折线，而<code>CGContextMoveToPoint</code>+<code>CGContextAddLineToPoint</code>画线后面不能跟<code>CGContextAddLines</code>，会画成两组无关联的折线。</p>
<h3 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h3><p>画圆弧提供了两个函数，一个是<code>CGContextAddArc</code>，依次指定<code>图形上下文</code>、<code>圆心坐标</code>、<code>半径</code>、<code>起始弧度</code>、<code>终止弧度</code>、<code>画线顺时针(1)或逆时针(0)</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextAddArc(context, 100, 200, 30, 0, M_PI, 0);</span><br><span class="line">CGContextDrawPath(context, kCGPathStroke);</span><br></pre></td></tr></table></figure>

<p>第二个函数是<code>CGContextAddArcToPoint</code>，三点+半径确定一个圆弧。<code>CGContextMoveToPoint</code>函数确定第一个点，<code>CGContextAddArcToPoint</code>添加第二个点、第三个点和还有半径。原理：以第二点为中心，分别向第一点、第三点延长两条射线，射线夹角小于180°的一侧，以指定半径画圆弧，圆弧与射线相切。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextMoveToPoint(context, 100, 100);</span><br><span class="line">CGContextAddArcToPoint(context, 100, 150, 150, 150, 50);</span><br><span class="line">CGContextDrawPath(context, kCGPathStroke);</span><br></pre></td></tr></table></figure>

<h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><p>画Bezier曲线也提供了两个函数，函数<code>CGContextAddCurveToPoint</code>用于画三次Bezier曲线，由一个起点、一个终点和两个控制点构成一条三次Bezier曲线。当两个控制点在起点和终点连线的同侧时，曲线会只有一个拱向，在不同侧时有两个拱向。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextMoveToPoint(context, 100, 100);</span><br><span class="line">CGContextAddCurveToPoint(context, 150, 50, 200, 200, 300, 100);</span><br><span class="line">CGContextDrawPath(context, kCGPathStroke);</span><br></pre></td></tr></table></figure>

<p>画二次Bezier曲线，使用函数CGContextAddQuadCurveToPoint。以当前点为起始点，指定一个控制点一个终点，确定一条二次Bezier曲线。控制点决定了曲线拱的方向，该函数只能创建一个拱向的Bezier曲线，而且曲线不可能交叉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextMoveToPoint(context, 100, 100);</span><br><span class="line">CGContextAddQuadCurveToPoint(context, 200, 200, 300, 100);</span><br><span class="line">CGContextDrawPath(context, kCGPathStroke);</span><br></pre></td></tr></table></figure>

<h3 id="闭合路径"><a href="#闭合路径" class="headerlink" title="闭合路径"></a>闭合路径</h3><p>Quartz 2D提供函数<code>CGContextClosePath</code>来闭合路径。就是将终点和起点用直线连接起来，使整个路径闭合。对于直线、弧、曲线等不能自动闭合的路径，如果想完成路径闭合必须调用该函数。</p>
<p>调用了<code>CGContextClosePath</code>完成闭合路径后，再调用<code>Add...</code>添加路径的函数，添加直线、弧线、曲线等路径，会从闭合路径的起始点开始。如果没有完成闭合路径函数的调用，则从终点继续开始新添加的路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextMoveToPoint(context, 100, 100);</span><br><span class="line">CGContextAddCurveToPoint(context, 150, 50, 150, 200, 300, 100);</span><br><span class="line">CGContextClosePath(context);</span><br><span class="line">CGContextAddLineToPoint(context, 200, 500);</span><br><span class="line">CGContextDrawPath(context, kCGPathStroke);</span><br></pre></td></tr></table></figure>

<h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><p>使用函数<code>CGContextAddRect</code>来画矩形，函数中的<code>rect</code>中x,y是矩形左上角，宽高是矩形的宽高。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextAddRect(context, CGRectMake(20, 20, 100, 40));</span><br><span class="line">CGContextDrawPath(context, kCGPathStroke);</span><br></pre></td></tr></table></figure>

<h3 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h3><p>使用函数<code>CGContextAddEllipseInRect</code>来画椭圆，是以矩形来确定椭圆。坐标参数意义和矩形一样，以确定的矩形内切画出的椭圆。矩形的圆心即是椭圆的圆心，矩形的宽高即是椭圆的长轴短轴，当矩形的宽高相等时，椭圆就是一个圆了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextAddEllipseInRect(context, CGRectMake(0, 0, 30, 50));</span><br><span class="line">CGContextDrawPath(context, kCGPathStroke);</span><br></pre></td></tr></table></figure>

<h2 id="创建路径"><a href="#创建路径" class="headerlink" title="创建路径"></a>创建路径</h2><ul>
<li>在开始绘制路径前，调用 CGContextBeginPath 或 UI。</li>
<li>直线、弧、曲线开始于当前点。空路径没有当前点；我们必须调用CGContextMoveToPoint来设置第一个子路径的起始点，或者调用一个便利函数来隐式地完成该任务。</li>
<li>如果要闭合当前子路径，调用函数 CGContextClosePath。随后路径将开始一个新的子路径，即使我们不显示设置一个新的起始点。</li>
<li>当绘制弧时，Quartz 将在当前点与弧的起始点间绘制一条直线。</li>
<li>添加椭圆和矩形的 Quartz 程序将在路径中添加新的闭合子路径。</li>
<li>我们必须调用绘制函数来填充或者描边一条路径，因为创建路径时并不会绘制路径。</li>
<li>Quartz 提供了两个数据类型来创建可复用路径 CGPathRef 和 CGMutablePathRef。</li>
<li>Quartz 提供了一个类似于操作图形上下文的 CGPath 的函数集合。这些路径函数操作 CGPath 对象，而不是图形上下文。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="built_in">CGPathCreateMutable</span> 取代 <span class="built_in">CGContextBeginPath</span></span><br><span class="line"><span class="number">2.</span>	<span class="built_in">CGPathMoveToPoint</span> 取代 <span class="built_in">CGContextMoveToPoint</span></span><br><span class="line"><span class="number">3.</span>	<span class="built_in">CGPathAddLineToPoint</span> 取代 <span class="built_in">CGContexAddLineToPoint</span></span><br><span class="line"><span class="number">4.</span>	<span class="built_in">CGPathAddCurveToPoint</span> 取代 <span class="built_in">CGContexAddCurveToPoint</span></span><br><span class="line"><span class="number">5.</span>	<span class="built_in">CGPathAddEllipseInRect</span> 取代 <span class="built_in">CGContexAddEllipseInRect</span></span><br><span class="line"><span class="number">6.</span>	<span class="built_in">CGPathAddArc</span> 取代 <span class="built_in">CGContexAddArc</span></span><br><span class="line"><span class="number">7.</span>	<span class="built_in">CGPathAddRect</span> 取代 <span class="built_in">CGContexAddRect</span></span><br><span class="line"><span class="number">8.</span>	<span class="built_in">CGPathCloseSubpath</span> 取代 <span class="built_in">CGContexClosePath</span></span><br></pre></td></tr></table></figure>

<p>如果想要添加一个路径到图形上下文，可以调用CGContextAddPath。路径将保留在图形上下文中，直到Quartz绘制它。我们可以调用CGContextAddPath再次添加路径。</p>
<h2 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h2><p>通过图形上下文加上一系列创建路径的函数得到最终的路径，还需要绘制路径操作，才能使得路径呈现。如上文中一直用到的绘制路径的函数操作<code>CGContextDrawPath(context, kCGPathStroke);</code>。</p>
<p>绘制路径分为描边和填充，描边是绘制路径的边框，填充是绘制路径所包含的区域。</p>
<h3 id="影响描边的属性"><a href="#影响描边的属性" class="headerlink" title="影响描边的属性"></a>影响描边的属性</h3><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">解释</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CGContextSetLineWidth</td>
<td align="left">描边路径的宽度</td>
<td align="left">单位是用户空间单位</td>
</tr>
<tr>
<td align="left">CGContextSetLineJoin</td>
<td align="left">指定描边的连接点样式</td>
<td align="left">枚举类型:Miter(尖角),Round(圆角),Bevel(平角)</td>
</tr>
<tr>
<td align="left">CGContextSetLineCap</td>
<td align="left">指定直线端点样式</td>
<td align="left">枚举类:Butt,Round,Square</td>
</tr>
<tr>
<td align="left">CGContextSetMiterLimit</td>
<td align="left">转角的量级</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">CGContextSetLineDash</td>
<td align="left">虚线模式</td>
<td align="left">指定虚线数组和虚线相位控制虚线大小和位置</td>
</tr>
<tr>
<td align="left">CGContextSetStrokeColorSpace</td>
<td align="left">描边颜色空间</td>
<td align="left">封装了颜色和颜色空间的CGColorRef</td>
</tr>
<tr>
<td align="left">CGContextSetStrokeColor</td>
<td align="left">设置描边颜色</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">CGContextSetStrokePattern</td>
<td align="left">笔触模式</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="填充路径"><a href="#填充路径" class="headerlink" title="填充路径"></a>填充路径</h3><p>填充规则有两种：非零缠绕数规则（nonzero winding number rule）、偶数-奇数规则（even-odd rule）。</p>
<p>默认的填充规则为非零缠绕数规则。方法或枚举带有“EO”的为偶数-奇数规则。</p>
<p>非零缠绕数的填充规则与绘制的方向有关、偶数-奇数规则则与方向无关。如图。</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/eosampleone.gif" alt="非零缠绕数规则和偶数奇数规则"></p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CGContextEOFillPath</td>
<td align="left">使用偶数奇数规则填充当前路径</td>
</tr>
<tr>
<td align="left">CGContextFillPath</td>
<td align="left">使用非零缠绕数规则填充当前路径</td>
</tr>
<tr>
<td align="left">CGContextFillRect</td>
<td align="left">快速填充一个矩形</td>
</tr>
<tr>
<td align="left">CGContextFillRects</td>
<td align="left">快速填充N个矩形</td>
</tr>
<tr>
<td align="left">CGContextFillEllipseInRect</td>
<td align="left">快速填充一个椭圆形</td>
</tr>
<tr>
<td align="left">CGContextDrawPath</td>
<td align="left">填充或描边路径</td>
</tr>
</tbody></table>
<p>CGContextDrawPath函数的使用：</p>
<ul>
<li>CGContextDrawPath(context, kCGPathFill) 填充路径。</li>
<li>CGContextDrawPath(context, kCGPathEOFill) 使用奇偶规则填充路径。</li>
<li>CGContextDrawPath(context, kCGPathStroke) 描边路径。</li>
<li>CGContextDrawPath(context, kCGPathFillStroke) 填充并描边路径。</li>
<li>CGContextDrawPath(context, kCGPathEOFillStroke) 使用奇偶规则填充并描边路径。</li>
</ul>
<h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><p>混合模式是Quartz将绘图绘制到背景上的方式，其实就是前景图和背景图怎么混合叠加。叠加公式如下：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">result = (<span class="built_in">alpha</span> * foreground) + (<span class="number">1</span> - <span class="built_in">alpha</span>) *<span class="built_in">background</span></span><br></pre></td></tr></table></figure>

<p>Quartz默认使用普通混合模式，也就是<code>kCGBlendModeNormal</code>。下面举例几个混合模式的样式，案例样式的代码见下一节<code>裁剪路径</code>：</p>
<table>
<thead>
<tr>
<th align="center">kCGBlendModeNormal</th>
<th align="center">kCGBlendModeMultiply</th>
<th align="center">kCGBlendModeScreen</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161213-0.png" alt="普通模式"></td>
<td align="center"><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161213-1.png" alt="正片叠底"></td>
<td align="center"><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161213-2.png" alt="屏幕混合"></td>
</tr>
</tbody></table>
<p>16种混合模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kCGBlendModeNormal,		&#x2F;&#x2F;普通</span><br><span class="line">kCGBlendModeMultiply,		&#x2F;&#x2F;正片叠底</span><br><span class="line">kCGBlendModeScreen,		&#x2F;&#x2F;屏幕</span><br><span class="line">kCGBlendModeOverlay,		&#x2F;&#x2F;叠加</span><br><span class="line">kCGBlendModeDarken,		&#x2F;&#x2F;暗化</span><br><span class="line">kCGBlendModeLighten,		&#x2F;&#x2F;亮化</span><br><span class="line">kCGBlendModeColorDodge,		&#x2F;&#x2F;色彩减淡</span><br><span class="line">kCGBlendModeColorBurn,		&#x2F;&#x2F;色彩加深</span><br><span class="line">kCGBlendModeSoftLight,		&#x2F;&#x2F;柔光</span><br><span class="line">kCGBlendModeHardLight,		&#x2F;&#x2F;强光</span><br><span class="line">kCGBlendModeDifference,		&#x2F;&#x2F;差值</span><br><span class="line">kCGBlendModeExclusion,		&#x2F;&#x2F;排除</span><br><span class="line">kCGBlendModeHue,			&#x2F;&#x2F;色相</span><br><span class="line">kCGBlendModeSaturation,		&#x2F;&#x2F;饱和度</span><br><span class="line">kCGBlendModeColor,		&#x2F;&#x2F;颜色</span><br><span class="line">kCGBlendModeLuminosity,		&#x2F;&#x2F;亮度</span><br></pre></td></tr></table></figure>

<h2 id="裁剪路径"><a href="#裁剪路径" class="headerlink" title="裁剪路径"></a>裁剪路径</h2><p>裁剪是一个遮罩，会遮住不允许绘制的地方。裁剪区域是一个闭合路径，Quartz只会渲染裁剪区域里面的东西，外面的东西不渲染。通过函数<code>CGContextClip</code>裁剪，具体的裁剪代码和执行结果如下，注意代码位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRef context &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">&#x2F;** 裁剪 *&#x2F;</span><br><span class="line">CGContextBeginPath(context);</span><br><span class="line">CGContextAddArc(context, 200, 200, 150, 0, 2 * M_PI, 0);</span><br><span class="line">CGContextClosePath(context);</span><br><span class="line">CGContextClip(context);</span><br><span class="line"></span><br><span class="line">CGContextSetRGBFillColor(context, 0.5, 0.2, 1, 1);</span><br><span class="line">CGContextFillRect(context, CGRectMake(100, 50, 50, 300));</span><br><span class="line">CGContextSetRGBFillColor(context, 0.8, 0.3, 0.1, 1);</span><br><span class="line">CGContextFillRect(context, CGRectMake(150, 50, 50, 300));</span><br><span class="line">CGContextSetRGBFillColor(context, 0.5, 0.1, 0.4, 1);</span><br><span class="line">CGContextFillRect(context, CGRectMake(200, 50, 50, 300));</span><br><span class="line">CGContextSetRGBFillColor(context, 0, 0.5, 0.1, 1);</span><br><span class="line">CGContextFillRect(context, CGRectMake(250, 50, 50, 300));</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;设置混合模式，自行替换上述16中混合模式查看效果</span><br><span class="line">CGContextSetBlendMode(context, kCGBlendModeMultiply); </span><br><span class="line"></span><br><span class="line">CGContextSetRGBFillColor(context, 0.5, 0.2, 1, 1);</span><br><span class="line">CGContextFillRect(context, CGRectMake(20, 100, 350, 50));</span><br><span class="line">CGContextSetRGBFillColor(context, 0.8, 0.3, 0.1, 1);</span><br><span class="line">CGContextFillRect(context, CGRectMake(20, 150, 350, 50));</span><br><span class="line">CGContextSetRGBFillColor(context, 0.5, 0.1, 0.4, 1);</span><br><span class="line">CGContextFillRect(context, CGRectMake(20, 200, 350, 50));</span><br><span class="line">CGContextSetRGBFillColor(context, 0, 0.5, 0.1, 1);</span><br><span class="line">CGContextFillRect(context, CGRectMake(20, 250, 350, 50));</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20161213-3.png" alt="裁剪路径和混合模式的执行结果"></p>
<hr>
<p>参考文章：<a href="http://southpeak.github.io/categories/translate/" target="_blank" rel="noopener">南峰子翻译的Quartz2D编程指南</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Quartz2D</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS时间问题</title>
    <url>/2016/12/08/iOS%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在iOS开发中，经常会遇到各种各样的时间问题，8小时时差，时间戳，求时间间隔，农历等等。解决办法网上比比皆是，但大多零零散散，很多资料并没有说明其中问题。这里集中总结一下，以便于以后查阅和供大家参考。有我自己的理解，错漏之处请大家吐槽。</p>
<a id="more"></a>

<h2 id="NSDate的8小时问题"><a href="#NSDate的8小时问题" class="headerlink" title="NSDate的8小时问题"></a>NSDate的8小时问题</h2><h3 id="NSDate转字符串时间"><a href="#NSDate转字符串时间" class="headerlink" title="NSDate转字符串时间"></a>NSDate转字符串时间</h3><p>初始化一个<code>NSDate</code>时间<code>[NSDate date]</code>，获取的是零时区的时间（格林尼治的时间: 年-月-日 时:分:秒: +时区），而北京时间是东八区时间，因为时区不同，所以打印的时间相差了8小时。此刻表示的时间是一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDate *date &#x3D; [NSDate date];</span><br><span class="line">NSLog(@&quot;date时间 &#x3D; %@&quot;, date);</span><br><span class="line"></span><br><span class="line">NSDateFormatter *formatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">[formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss Z&quot;];</span><br><span class="line">NSString *dateStr &#x3D; [formatter stringFromDate:date];</span><br><span class="line">NSLog(@&quot;字符串时间 &#x3D; %@&quot;, dateStr);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-12-07 10:44:24.470 timeTest[32743:2995134] date时间 &#x3D; 2016-12-07 02:44:24 +0000</span><br><span class="line">2016-12-07 10:44:24.471 timeTest[32743:2995134] 字符串时间 &#x3D; 2016-12-07 10:44:24 +0800</span><br></pre></td></tr></table></figure>

<p>打印结果前面的时间是北京时间：<code>2016-12-07 10:44:24.470</code>。而<code>date</code>打印出来的时间显示少了8小时，因为它表示的是<code>零时区(+0000)</code>时间<code>02:44:24</code>。此刻对应东八区的北京时间就是<code>10:44:24</code>。只是时区不同，表示的时间点是一样的。好比1公斤和2斤，重量是一样的。<code>[NSDate date]</code>获取的时间单位是<code>零时区(+0000)</code>，我们所要的北京时间的单位是<code>东八区(+0800)</code>。</p>
<p>系统会默认<code>[NSDate date]</code>获取的时间为零时区时间，而经过<code>NSDateFormatter</code>转化为字符串时间就是当前所在时区的准确时间，并没有8小时误差。</p>
<h3 id="转字符串时间的时区设定"><a href="#转字符串时间的时区设定" class="headerlink" title="转字符串时间的时区设定"></a>转字符串时间的时区设定</h3><p>上文中NSDate时间转为字符串时间并没有设置<code>NSDateFormatter</code>的<code>timeZone</code>。不设置会默认使用当前所在的时区，与设置系统时区<code>formatter.timeZone = [NSTimeZone systemTimeZone]</code>的效果是一样的。</p>
<p>也可以设置时区，获取指定时区的字符串时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDate *date &#x3D; [NSDate date];</span><br><span class="line">NSDateFormatter *formatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">[formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</span><br><span class="line">formatter.timeZone &#x3D; [NSTimeZone timeZoneWithName:@&quot;Asia&#x2F;Shanghai&quot;];&#x2F;&#x2F;东八区时间</span><br><span class="line">NSString *dateStr &#x3D; [formatter stringFromDate:date];</span><br><span class="line">NSLog(@&quot;字符串时间 &#x3D; %@&quot;, dateStr);</span><br></pre></td></tr></table></figure>

<p>这时获取的时间就是东八区时间，哪怕手机拿到零时区的格林尼治，获取的也是东八区的时间，因为这里指定时区了。也有如下时区指定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">formatter.timeZone &#x3D; [NSTimeZone timeZoneWithName:@&quot;Asia&#x2F;Tokyo&quot;];&#x2F;&#x2F;东九区时间</span><br><span class="line">formatter.timeZone &#x3D; [NSTimeZone timeZoneWithName:@&quot;GMT&quot;];&#x2F;&#x2F;零区时间</span><br></pre></td></tr></table></figure>

<p>通过下面方法可得到系统支持的时区对应的字符串常量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray *zones &#x3D; [NSTimeZone knownTimeZoneNames];</span><br><span class="line">for (NSString *zone in zones) &#123;</span><br><span class="line">   NSLog(@&quot;时区名 &#x3D; %@&quot;, zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/timezone.jpg?raw=true" alt="时区对照表"></p>
<h3 id="字符串时间转NSDate"><a href="#字符串时间转NSDate" class="headerlink" title="字符串时间转NSDate"></a>字符串时间转NSDate</h3><p>字符串时间转为NSDate时间也会有时区问题。也会遇到有所谓的8小时误差，其实就是时区不同。比如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDateFormatter *formatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">[formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss Z&quot;];</span><br><span class="line">NSDate *newDate &#x3D; [formatter dateFromString:@&quot;2016-12-07 14:06:24 +0800&quot;];</span><br><span class="line">NSLog(@&quot;newDate &#x3D; %@&quot;, newDate);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-12-07 14:12:17.468 timeTest[34279:3155380] newDate &#x3D; 2016-12-07 06:06:24 +0000</span><br></pre></td></tr></table></figure>

<p><code>NSDateFormatter</code>的指定格式是：<code>@&quot;yyyy-MM-dd HH:mm:ss Z&quot;</code>。这里面的<code>Z</code>指的是时区。要转化的字符串时间格式必须和这个格式匹配，上面给定的字符串时间是：<code>@&quot;2016-12-07 14:06:24 +0800&quot;</code>，是一个东八区时间，转化为NSDate后是零区时间<code>2016-12-07 06:06:24 +0000</code>，字面显示上少了8小时，其实时间一样。</p>
<p>其实如果上面给定的字符串时间为<code>@&quot;2016-12-07 14:06:24 +0000&quot;</code>，转化出来的NSDate时间会完全一样，因为字符串时间为零时区时间，不存在时区误差。大家可以试一下。</p>
<p>当不指定字符串时间的时区时，即没有后面的<code>+0800</code>，同时要把<code>NSDateFormatter</code>时间格式里的<code>Z</code>去掉，保证格式匹配。系统会认为字符串时间是系统所在时区的时间，转化为NSDate时间是零时区时间。</p>
<p>同样，也可以使用<code>formatter.timeZone = [NSTimeZone timeZoneWithName:@&quot;GMT&quot;];</code>这种方式指定字符串时间的时区，和用<code>Z</code>对应<code>+0000</code>是一样的。</p>
<h3 id="NSDate转当前时区的NSDate时间"><a href="#NSDate转当前时区的NSDate时间" class="headerlink" title="NSDate转当前时区的NSDate时间"></a>NSDate转当前时区的NSDate时间</h3><p>因为<code>[NSDate date]</code>得出的时间是零时区时间，当我们要获取当前所在时区的NSDate时间时，通常会用以下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDate *date &#x3D; [NSDate date];</span><br><span class="line">NSTimeZone *zone &#x3D; [NSTimeZone systemTimeZone];</span><br><span class="line">NSInteger interval &#x3D; [zone secondsFromGMTForDate:date];</span><br><span class="line">NSDate *localDate &#x3D; [date  dateByAddingTimeInterval:interval];</span><br><span class="line">NSLog(@&quot;localDate &#x3D; %@&quot;,localDate);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-12-07 14:49:03.777 timeTest[34519:3183548] localDate &#x3D; 2016-12-07 14:49:03 +0000</span><br></pre></td></tr></table></figure>

<p>上面代码中<code>zone</code>是当前时区，<code>interval</code>是当前时区和零时区时间的差值，最后结果<code>localDate</code>是零时区时间<code>date</code>加上这个差值<code>interval</code>，得到当前时区的NSDate时间。更有甚者，在开发中直接加<code>8*60*60</code>或<code>28800</code>这样的值，因为相差8小时嘛。这样在东八区没问题，在其他时区时间就错了。</p>
<p>其实这种做法是不科学的，因为得到的最终时间还是零时区时间，时间后面明显是<code>+0000</code>，在使用中一般不显示时区，所以认为当做当前时区的时间使用也未尝不可。此为大坑！</p>
<p>坑1：这时如果转为字符串时间，又会增加8小时。因为做时间转换的时候，系统会认为这个NSDate是零时区，得到的字符串时间是东八区的。</p>
<p>解决办法是：将错就错，字符串时间也设置为零时区的字符串时间。从深坑跌入更深的坑！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDate *date &#x3D; [NSDate date];</span><br><span class="line">NSTimeZone *zone &#x3D; [NSTimeZone systemTimeZone];</span><br><span class="line">NSInteger interval &#x3D; [zone secondsFromGMTForDate:date];</span><br><span class="line">NSDate *localDate &#x3D; [date dateByAddingTimeInterval:interval];</span><br><span class="line"></span><br><span class="line">NSDateFormatter *formatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">[formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</span><br><span class="line">formatter.timeZone &#x3D; [NSTimeZone timeZoneWithName:@&quot;UTC&quot;];</span><br><span class="line">NSString *dateStr &#x3D; [formatter stringFromDate:localDate];</span><br><span class="line">NSLog(@&quot;字符串时间 &#x3D; %@&quot;, dateStr);</span><br></pre></td></tr></table></figure>

<p>这里的<code>@&quot;UTC&quot;</code>是指世界标准时间，也是现在用的时间标准，东八区比这个时间也是快8小时，这里填<code>@&quot;GMT&quot;</code>也是可以的。</p>
<p>坑2：在与后台交互时，有时需要<code>+0000</code>时区，这时只能手动拼接字符串更改这个时区字段，改为正确的时区。</p>
<p><strong>所以，在开发中尽量不要这么做，当时间要求显示、存储或与后台交互的时候，使用字符串时间！不要使用转化的NSDate。</strong></p>
<h2 id="时间换算，时间戳的概念"><a href="#时间换算，时间戳的概念" class="headerlink" title="时间换算，时间戳的概念"></a>时间换算，时间戳的概念</h2><h3 id="当前时间转时间戳"><a href="#当前时间转时间戳" class="headerlink" title="当前时间转时间戳"></a>当前时间转时间戳</h3><p>时间戳是指1970年1月1日0时0分0秒到当前时间的秒数。注意：这里的当前时间是指零时区的NSDate时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDate *date &#x3D; [NSDate date];</span><br><span class="line">NSTimeInterval timeIn &#x3D; [date timeIntervalSince1970];</span><br><span class="line">NSLog(@&quot;时间戳 &#x3D; %.0f&quot;, timeIn);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-12-07 15:41:04.000 timeTest[34994:3232390] 时间戳 &#x3D; 1481096464</span><br></pre></td></tr></table></figure>

<h3 id="时间戳转当前时间"><a href="#时间戳转当前时间" class="headerlink" title="时间戳转当前时间"></a>时间戳转当前时间</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDate *date &#x3D; [NSDate date];</span><br><span class="line">NSTimeInterval timeIn &#x3D; [date timeIntervalSince1970];</span><br><span class="line">NSDate *newDate &#x3D; [NSDate dateWithTimeIntervalSince1970:timeIn];</span><br><span class="line">NSDateFormatter *dateFormatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">[dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss Z&quot;];</span><br><span class="line">NSString *newTime &#x3D; [dateFormatter stringFromDate:newDate];</span><br><span class="line">NSLog(@&quot;初始化时间 &#x3D; %@，时间戳&#x3D;%.0f，时间戳转为NSDate时间 &#x3D; %@，转为字符串时间 &#x3D; %@&quot;, date, timeIn, newDate, newTime);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-12-07 16:11:56.146 timeTest[35186:3253589] 初始化时间 &#x3D; 2016-12-07 08:11:56 +0000，时间戳&#x3D;1481098316，时间戳转为NSDate时间 &#x3D; 2016-12-07 08:11:56 +0000，转为字符串时间 &#x3D; 2016-12-07 16:11:56 +0800</span><br></pre></td></tr></table></figure>

<p>注意时间戳使用的NSDate时间是当前零时区的时间！当前零时区时间！当前零时区时间！重要的事情说三遍！不要进行NSDate转当前时区的NSDate时间，再转时间戳。下面是验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDate *date &#x3D; [NSDate date];</span><br><span class="line">NSLog(@&quot;系统零时区NSDate时间 &#x3D; %@&quot;, date);    </span><br><span class="line">NSTimeInterval timeIn &#x3D; [date timeIntervalSince1970];</span><br><span class="line">NSLog(@&quot;系统零时区NSDate时间转化为时间戳 &#x3D; %.0f&quot;, timeIn);</span><br><span class="line">NSTimeZone *zone &#x3D; [NSTimeZone systemTimeZone];</span><br><span class="line">NSInteger interval &#x3D; [zone secondsFromGMTForDate:date];</span><br><span class="line">NSDate *localDate &#x3D; [date  dateByAddingTimeInterval:interval];</span><br><span class="line">NSLog(@&quot;转化为本地NSDate时间 &#x3D; %@&quot;, localDate);</span><br><span class="line">NSTimeInterval timeIn2 &#x3D; [localDate timeIntervalSince1970];</span><br><span class="line">NSLog(@&quot;本地NSDate时间转化为时间戳 &#x3D; %.0f&quot;, timeIn2);</span><br><span class="line">NSDate *detaildate &#x3D; [NSDate dateWithTimeIntervalSince1970:timeIn];</span><br><span class="line">NSDate *detaildate2 &#x3D; [NSDate dateWithTimeIntervalSince1970:timeIn2];</span><br><span class="line">NSDateFormatter *dateFormatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">[dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss Z&quot;];</span><br><span class="line">NSString *newTime &#x3D; [dateFormatter stringFromDate:detaildate];</span><br><span class="line">NSString *newTime2 &#x3D; [dateFormatter stringFromDate:detaildate2];</span><br><span class="line">NSLog(@&quot;最终转为字符串时间1 &#x3D; %@， 时间2 &#x3D; %@&quot;, newTime, newTime2);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-12-07 16:13:57.834 timeTest[35211:3255842] 系统零时区NSDate时间 &#x3D; 2016-12-07 08:13:57 +0000</span><br><span class="line">2016-12-07 16:13:57.834 timeTest[35211:3255842] 系统零时区NSDate时间转化为时间戳 &#x3D; 1481098438</span><br><span class="line">2016-12-07 16:13:57.835 timeTest[35211:3255842] 转化为本地NSDate时间 &#x3D; 2016-12-07 16:13:57 +0000</span><br><span class="line">2016-12-07 16:13:57.835 timeTest[35211:3255842] 本地NSDate时间转化为时间戳 &#x3D; 1481127238</span><br><span class="line">2016-12-07 16:13:57.836 timeTest[35211:3255842] 最终转为字符串时间1 &#x3D; 2016-12-07 16:13:57 +0800， 时间2 &#x3D; 2016-12-08 00:13:57 +0800</span><br></pre></td></tr></table></figure>

<p>问题解释详见上文的<code>NSDate转当前时区的NSDate时间</code>。</p>
<h2 id="时间操作与比较"><a href="#时间操作与比较" class="headerlink" title="时间操作与比较"></a>时间操作与比较</h2><h3 id="时间初始化和比较方法"><a href="#时间初始化和比较方法" class="headerlink" title="时间初始化和比较方法"></a>时间初始化和比较方法</h3><p>几个时间初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化当前时间，返回零时区时间</span><br><span class="line">NSDate *date &#x3D; [NSDate date];</span><br><span class="line">&#x2F;&#x2F;以当前时间为准，正数超前指定秒数，负数延后指定秒数</span><br><span class="line">NSDate *laterDate &#x3D; [NSDate dateWithTimeIntervalSinceNow:60];</span><br><span class="line">&#x2F;&#x2F;以2001-01-01 00:00:00 +0000为基准，正数超前指定秒数，负数延后指定秒数</span><br><span class="line">NSDate *newDate &#x3D; [NSDate dateWithTimeIntervalSinceReferenceDate:60];</span><br><span class="line">&#x2F;&#x2F;以1970-01-01 00:00:00 +0000为基准，正数超前指定秒数，负数延后指定秒数</span><br><span class="line">NSDate *newDate1 &#x3D; [NSDate dateWithTimeIntervalSince1970:60];</span><br><span class="line">&#x2F;&#x2F;实例方法，以指定时间为基准，正数超前指定秒数，负数延后指定秒数</span><br><span class="line">NSDate *newDate2 &#x3D; [date dateByAddingTimeInterval:60];</span><br><span class="line">&#x2F;&#x2F;很久以后的某一天</span><br><span class="line">NSDate *newDate3 &#x3D; [NSDate distantFuture];</span><br><span class="line">&#x2F;&#x2F;很久以前的某一天</span><br><span class="line">NSDate *newDate4 &#x3D; [NSDate distantPast];</span><br></pre></td></tr></table></figure>

<p>几个时间比较方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;比较两个时间是否相等</span><br><span class="line">- (BOOL)isEqualToDate:(NSDate *)otherDate;</span><br><span class="line">&#x2F;&#x2F;两个时间比较，返回较早时间</span><br><span class="line">- (NSDate *)earlierDate:(NSDate *)anotherDate;</span><br><span class="line">&#x2F;&#x2F;两个时间比较，返回较晚时间</span><br><span class="line">- (NSDate *)laterDate:(NSDate *)anotherDate;</span><br><span class="line">&#x2F;&#x2F;两个时间比较，返回枚举类型</span><br><span class="line">- (NSComparisonResult)compare:(NSDate *)other;</span><br></pre></td></tr></table></figure>

<p>几个计算时间间隔的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;返回实例时间与refDate时间间隔秒数</span><br><span class="line">- (NSTimeInterval)timeIntervalSinceDate:(NSDate *)refDate;</span><br><span class="line">&#x2F;&#x2F;返回实例时间与当前时间间隔秒数</span><br><span class="line">- (NSTimeInterval)timeIntervalSinceNow;</span><br><span class="line">&#x2F;&#x2F;返回实例时间的时间戳</span><br><span class="line">- (NSTimeInterval)timeIntervalSince1970;</span><br><span class="line">&#x2F;&#x2F;返回实例时间和2001-01-01 00:00:00 +0000的间隔秒数</span><br><span class="line">- (NSTimeInterval)timeIntervalSinceReferenceDate;</span><br><span class="line">&#x2F;&#x2F;返回当前时间和2001-01-01 00:00:00 +0000的间隔秒数</span><br><span class="line">+ (NSTimeInterval)timeIntervalSinceReferenceDate;</span><br></pre></td></tr></table></figure>

<h3 id="获取年月日时分秒周时区"><a href="#获取年月日时分秒周时区" class="headerlink" title="获取年月日时分秒周时区"></a>获取年月日时分秒周时区</h3><p>oc里的时间坑太多，根本没办法像其他语言那样直接time.year就能获取年份。要想获取NSDate的年月日需要使用日历对象<code>NSCalendar</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDate *date &#x3D; [NSDate date];</span><br><span class="line">NSCalendar *cal &#x3D; [NSCalendar currentCalendar];</span><br><span class="line">NSDateComponents *dateComps &#x3D; [cal components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay|NSCalendarUnitHour|NSCalendarUnitMinute|NSCalendarUnitSecond|NSCalendarUnitWeekday|NSCalendarUnitWeekOfMonth|NSCalendarUnitWeekOfYear|NSCalendarUnitTimeZone fromDate:date];</span><br><span class="line">NSLog(@&quot;时间 &#x3D; %@&quot;, date);</span><br><span class="line">NSLog(@&quot;年&#x3D;%ld,月&#x3D;%ld,日&#x3D;%ld,时&#x3D;%ld,分&#x3D;%ld,秒&#x3D;%ld,周&#x3D;%ld,本月第%ld周,本年第%ld周,时区&#x3D;%@&quot;, dateComps.year, dateComps.month, dateComps.day, dateComps.hour, dateComps.minute, dateComps.second, dateComps.weekday, dateComps.weekOfMonth, dateComps.weekOfYear, dateComps.timeZone.name);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-12-07 17:20:41.639 timeTest[35734:3311752] 时间 &#x3D; 2016-12-07 09:20:41 +0000</span><br><span class="line">2016-12-07 17:20:41.640 timeTest[35734:3311752] 年&#x3D;2016,月&#x3D;12,日&#x3D;7,时&#x3D;17,分&#x3D;20,秒&#x3D;41,周&#x3D;4,本月第2周,本年第50周,时区&#x3D;Asia&#x2F;Shanghai</span><br></pre></td></tr></table></figure>

<p><code>NSDateComponents</code>创建方法中添加的枚举<code>NSCalendarUnit</code>，是后面要获取的年月日时分秒必须对应添加的。比如要获取年<code>dateComps.year</code>，就需要添加枚举<code>NSCalendarUnitYear</code>。</p>
<p>可以看到，<code>[NSDate date]</code>时间可以使用<code>NSCalendar</code>直接获取当前时区的时分秒，打印的<code>时</code>和<code>时区</code>即可看出。这是<code>[NSCalendar currentCalendar]</code>日历对象初始化的原因，也可以用<code>[[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian]</code>指定Identifier的方式初始化阳历日历。可以试试指定Identifier为<code>NSCalendarIdentifierChinese</code>，打印的是中国农历。</p>
<p><code>dateComps.weekOfMonth</code>是今天属于本月的第几周。</p>
<p><code>dateComps.weekOfYear</code>是今天属于本年的第几周。</p>
<p><code>dateComps.weekday</code>是星期，这个和日常使用有些不同。上述程序打印的是<code>周=4</code>，但2016-12-07是<code>周三</code>。这里<code>weekday</code>的对应关系是：周日-1，周一-2，周二-3，周三-4，周四-5，周五-6，周六-7。毕竟国外惯例周日是每周的第一天。</p>
<h2 id="农历"><a href="#农历" class="headerlink" title="农历"></a>农历</h2><p>获取农历的工具方法，可根据需求添加农历节日和二十四节气</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (NSString *)LunarForSolarYear:(int)wCurYear Month:(int)wCurMonth Day:(int)wCurDay</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;农历日期名</span><br><span class="line">    NSArray *cDayName &#x3D;  [NSArray arrayWithObjects:@&quot;*&quot;,@&quot;初一&quot;,@&quot;初二&quot;,@&quot;初三&quot;,@&quot;初四&quot;,@&quot;初五&quot;,@&quot;初六&quot;,@&quot;初七&quot;,@&quot;初八&quot;,@&quot;初九&quot;,@&quot;初十&quot;,@&quot;十一&quot;,@&quot;十二&quot;,@&quot;十三&quot;,@&quot;十四&quot;,@&quot;十五&quot;,@&quot;十六&quot;,@&quot;十七&quot;,@&quot;十八&quot;,@&quot;十九&quot;,@&quot;二十&quot;,@&quot;廿一&quot;,@&quot;廿二&quot;,@&quot;廿三&quot;,@&quot;廿四&quot;,@&quot;廿五&quot;,@&quot;廿六&quot;,@&quot;廿七&quot;,@&quot;廿八&quot;,@&quot;廿九&quot;,@&quot;三十&quot;,nil];</span><br><span class="line">    &#x2F;&#x2F;农历月份名</span><br><span class="line">    NSArray *cMonName &#x3D;  [NSArray arrayWithObjects:@&quot;*&quot;,@&quot;正月&quot;,@&quot;二月&quot;,@&quot;三月&quot;,@&quot;四月&quot;,@&quot;五月&quot;,@&quot;六月&quot;,@&quot;七月&quot;,@&quot;八月&quot;,@&quot;九月&quot;,@&quot;十月&quot;,@&quot;冬月&quot;,@&quot;腊月&quot;,nil];</span><br><span class="line">    &#x2F;&#x2F;公历每月前面的天数</span><br><span class="line">    const int wMonthAdd[12] &#x3D; &#123;0,31,59,90,120,151,181,212,243,273,304,334&#125;;</span><br><span class="line">    &#x2F;&#x2F;农历数据</span><br><span class="line">    const int wNongliData[100] &#x3D; &#123;2635,333387,1701,1748,267701,694,2391,133423,1175,396438</span><br><span class="line">        ,3402,3749,331177,1453,694,201326,2350,465197,3221,3402</span><br><span class="line">        ,400202,2901,1386,267611,605,2349,137515,2709,464533,1738</span><br><span class="line">        ,2901,330421,1242,2651,199255,1323,529706,3733,1706,398762</span><br><span class="line">        ,2741,1206,267438,2647,1318,204070,3477,461653,1386,2413</span><br><span class="line">        ,330077,1197,2637,268877,3365,531109,2900,2922,398042,2395</span><br><span class="line">        ,1179,267415,2635,661067,1701,1748,398772,2742,2391,330031</span><br><span class="line">        ,1175,1611,200010,3749,527717,1452,2742,332397,2350,3222</span><br><span class="line">        ,268949,3402,3493,133973,1386,464219,605,2349,334123,2709</span><br><span class="line">        ,2890,267946,2773,592565,1210,2651,395863,1323,2707,265877&#125;;</span><br><span class="line">    static int nTheDate,nIsEnd,m,k,n,i,nBit;</span><br><span class="line">    &#x2F;&#x2F;计算到初始时间1921年2月8日的天数：1921-2-8(正月初一)</span><br><span class="line">    nTheDate &#x3D; (wCurYear - 1921) * 365 + (wCurYear - 1921) &#x2F; 4 + wCurDay + wMonthAdd[wCurMonth - 1] - 38;</span><br><span class="line">    if((!(wCurYear % 4)) &amp;&amp; (wCurMonth &gt; 2))</span><br><span class="line">        nTheDate &#x3D; nTheDate + 1;</span><br><span class="line">    &#x2F;&#x2F;计算农历天干、地支、月、日</span><br><span class="line">    nIsEnd &#x3D; 0;</span><br><span class="line">    m &#x3D; 0;</span><br><span class="line">    while(nIsEnd !&#x3D; 1) &#123;</span><br><span class="line">        if(wNongliData[m] &lt; 4095)</span><br><span class="line">            k &#x3D; 11;</span><br><span class="line">        else</span><br><span class="line">            k &#x3D; 12;</span><br><span class="line">        n &#x3D; k;</span><br><span class="line">        while(n&gt;&#x3D;0) &#123;</span><br><span class="line">            &#x2F;&#x2F;获取wNongliData(m)的第n个二进制位的值</span><br><span class="line">            nBit &#x3D; wNongliData[m];</span><br><span class="line">            for(i&#x3D;1;i&lt;n+1;i++)</span><br><span class="line">                nBit &#x3D; nBit&#x2F;2;</span><br><span class="line">            nBit &#x3D; nBit % 2;</span><br><span class="line">            </span><br><span class="line">            if (nTheDate &lt;&#x3D; (29 + nBit)) &#123;</span><br><span class="line">                nIsEnd &#x3D; 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            nTheDate &#x3D; nTheDate - 29 - nBit;</span><br><span class="line">            n &#x3D; n - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(nIsEnd)</span><br><span class="line">            break;</span><br><span class="line">        m &#x3D; m + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    wCurYear &#x3D; 1921 + m;</span><br><span class="line">    wCurMonth &#x3D; k - n + 1;</span><br><span class="line">    wCurDay &#x3D; nTheDate;</span><br><span class="line">    if (k &#x3D;&#x3D; 12) &#123;</span><br><span class="line">        if (wCurMonth &#x3D;&#x3D; wNongliData[m] &#x2F; 65536 + 1)</span><br><span class="line">            wCurMonth &#x3D; 1 - wCurMonth;</span><br><span class="line">        else if (wCurMonth &gt; wNongliData[m] &#x2F; 65536 + 1)</span><br><span class="line">            wCurMonth &#x3D; wCurMonth - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;生成农历月</span><br><span class="line">    NSString *szNongliMonth;</span><br><span class="line">    if (wCurMonth &lt; 1) &#123;</span><br><span class="line">        szNongliMonth &#x3D; [NSString stringWithFormat:@&quot;闰%@&quot;,(NSString *)[cMonName objectAtIndex:-1 * wCurMonth]];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        szNongliMonth &#x3D; (NSString *)[cMonName objectAtIndex:wCurMonth];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;生成农历日</span><br><span class="line">    NSString *szNongliDay &#x3D; [cDayName objectAtIndex:wCurDay];</span><br><span class="line">    &#x2F;&#x2F;合并</span><br><span class="line">    NSString *lunarDate &#x3D; [NSString stringWithFormat:@&quot;%@-%@&quot;,szNongliMonth,szNongliDay];</span><br><span class="line">    return lunarDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS10</tag>
      </tags>
  </entry>
  <entry>
    <title>我想做个APP，多长时间，多少钱</title>
    <url>/2016/11/30/%E6%88%91%E6%83%B3%E5%81%9A%E4%B8%AAAPP%EF%BC%8C%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4%EF%BC%8C%E5%A4%9A%E5%B0%91%E9%92%B1/</url>
    <content><![CDATA[<p>在一个阳光明媚的下午，我正瘫坐在椅子上改bug。忽然有人给我发微信：“我想做个app，多长时间，多少钱？”</p>
<p>从我从业iOS开发到现在，这个问题被问过无数次，比那句：“你是程序员，那你会修电脑吗？”还要令人烦。毕竟那只是句玩笑话，而这句在其他人（更多时候是你的boss，经理这些非程序员出身的IT内行人）看来是你的专业，是你必须要知道的，你能回答不知道吗？显得你太不专业了。但这句话最专业、最负责任的回答就是：“我不知道！”</p>
<a id="more"></a>

<p>问我问题的是朋友的朋友，一个在传统行业浸淫多年的人，立志要突破传统行业的束缚，做互联网浪潮中的弄潮儿。当时听他说这句话的时候我有点懵逼：互联网浪潮中的弄潮儿？指示十多年前马云、马化腾那一批吗？现在互联网都蔓延成海了，哪还有潮让你浪，能做一条杂鱼苟延残喘的活下去就不错了。</p>
<p>我真想回答“我不知道”，毕竟还有好多bug等着我改呢，没必要在这浪费时间。但又想到毕竟有过一面之缘，直接回答不知道，是不是显得有点不给面子？在这个问题上，很多时候就是这么栽进坑里的。</p>
<p>“什么类型的app？”这句话发出去，毫无疑问的掉坑里了。他给我发了个app截图，说：“跟这个差不多，不用那么复杂，简单点就行。”</p>
<p>我一看，好嘛，淘宝？！你还真是打算做弄潮儿啊！我说：“淘宝啊？得十多年吧。”加了一个呵呵的表情，一方面想表达我认为你是在开玩笑，我也是开玩笑的回复，另一方面是我想呵呵你一脸。其实我也不算敷衍，淘宝03年成立，做到现在也十多年了。</p>
<p>他明显没有get到我的意思，反而埋怨我没get到他的点。说：“我的意思是淘宝这个类型的app，肯定不用跟淘宝似的那么复杂。简单点，有个列表，可以卖东西就行，几天能弄出来？重要的是要快！”看这意思是：我已想到一个天才创意，就差一个能把创意转化成app的高效程序员了，一定要高效，几天就能做出来，上架使用，推广全国。</p>
<p>这时我能想到的最靠谱的建议是：花钱收购现有的，你觉得最符合你创意理念的那款app。当然这个看似调侃实则靠谱的回答是没办法说出口的。我语重心长的回答道：“电商类app，只保留必要功能：商品展示、登录注册、购物车、下单支付、订单记录，精简到最简单，只是iOS客户端的实现代码也不可能几天内写完。“</p>
<p>本以为我这么说对方会重新估量开发一款app的复杂度，没想到对方急了：”不用考虑那么复杂，先做出一个最简单的，其他的慢慢迭代。就告诉我最快多长时间能搞定，大概花多少钱就行。“</p>
<p>这就是耍流氓了，好话说了一火车，油盐不进。我要还妄想改变他的想法，我就是2B了。索性开门见山的说：三个月。在团队完备，不改需求的前提下。找个人兼职外包，按平均日薪结算。</p>
<p>对方没再回话，不知道是听从我的建议去紧张筹备项目小组了，还是觉得我是个菜狗，这么点小事竟然张口就说三个月，三个月吃屎都赶不上热乎的了。我估计是后者的概率大。喝了口水抖擞抖擞精神，继续改我的bug。遥想当年我也曾豪言壮语，但到最后都跌的遍体鳞伤……</p>
<p>此类情况遇到N多次了，像这种无关自己工作的外部人士咨询行情的还好，毕竟你只需要给出自己认为合理的建议即可。人家也不一定采纳，说不定只是做个对比筛选，事后成功与否都事不关己。但多数情况下是boss或部门经理会问你这个问题，那回答的时候就不是这样轻轻松松侃侃而谈了。毕竟，说出去的话是要兑现的，挖了坑自己填不上，是要栽进去的。</p>
<p>我认为：任何没有完整功能逻辑原型图就问开发时间的都是耍流氓，有原型图问开发时间事后改需求的都是耍无赖。这两者的共同点就是玩死人不偿命。</p>
<p>为什么开发不能像其他行业那样精准预估工期呢？因为开发工作的变数太大。以最常见的app登录功能举例，常见的登录方式有：账号+密码、手机号+验证码和第三方平台登录。手机+验证码需要找短信服务商，要考虑验证码的送达速度和费用问题。第三方登录需要注册账号，创建应用，以及认证开发者资质。腾讯开放平台创建应用需要填写appid，要想有appid需要在iTunes Connect里创建应用，在此之前必须有苹果的开发者账号，申请开发者账号是要公司级还是个人级的？公司级的需要提供邓白氏码。所有这一切都需要时间审核，部分资质认证、账号注册需要花钱。</p>
<p>以上是平台账号问题，下面说开发问题。有登录就得有注册，要保证用户的唯一性，需要有一个唯一标识。以手机号作为唯一标识的话，采用第三方登录的没有手机号，分配独立用户id作为唯一标示的话，先用手机号登录，再用微信登录，就会产生两个用户，如何实现绑定手机号合并用户呢？还有是否保留账号+密码注册呢？如果保留的话还需要有找回密码功能，找回密码是要邮箱验证还是手机验证码验证呢……</p>
<p>一款app并不是简简单单找个码农，噼里啪啦敲一顿键盘就能完成的。至少需要以下几种角色：产品经理，能拍板项目功能逻辑出原型图，把控整个项目进度和团队配合；设计师，根据原型图做高保真交互设计；服务端工程师，做后台数据处理，提供客户端所需接口；客户端工程师，实现app所有的功能逻辑，性能优化，上架应用市场；测试工程师，测试app功能逻辑的正确性和性能。这些只是角色标配，并非每个角色都对应一个人。比如客户端可能需要Android、iOS、WP多个开发工程师，开发往往会兼任测试工作，后台有时会代理产品经理工作。又或者你是精通设计的全栈工程师，对产品又有资深造诣，那便可以身兼所有角色。所以这里又牵扯到团队协作，再默契的团队都会存在沟通成本，只是成本高低的问题。全栈工程师单人开发，没有沟通成本的单兵作战，时间成本会大大增加。所以说：程序开发是一个充满无数不可预知变化的职业，不可能精准预估工期。</p>
<p>道理我们都懂，那开发一个app到底要多长时间呢？预估工期虽然令人讨厌，但确实是一个客户端程序员该具备的能力。当看到原型图预估时间的时候，往往只估算了敲app代码的时间，而且还是个理想化时间。认为自己胸怀万码，光标到处bug灰飞烟灭，功能实现如有神助，代码编译一次通过，简直是码生赢家啊。现实会毫不留情的给你狠狠地一巴掌。比如一个原型图上有10个界面，都是最简单的push跳转，用Storyboard一个小时就能画完，剩下七个小时写数据展示，so easy啊，然后洋洋得意的告诉boss一天就能搞定。然后Storyboard代码版本冲突了，解决冲突用了仨小时，接口响应方式没指明，参数格式写错了，调了仨小时。六个小时过去后，慌了……</p>
<p>之所以不可预估，是因为存在太多的不确定因素。一些不确定因素会因为经验积累而变为确定因素，另一些不确定因素却会一直存在。程序员拿到需求的时候，需要有一个心理预估，每个功能模块多久能完成，哪些逻辑是我以前写过的，哪些框架是需要谷歌才会用的，哪些页面目前还不能确定实现方法。对每个模块分配一个时间块，不求预估准确，但求时间精确，最后把这些时间块加起来，然后乘一个π值，得到的便是一个相对合理的开发工期预估。随着经验积累，慢慢地不需要乘π值了，乘2.5，乘2，乘1.5……能乘以1那就是大神了，乘以0.x就超神了。其实有经验的产品经理也会以这种方式来计算程序员的工期预估，毕竟有经验的产品经理都是被程序员不擅长工期预估而坑过无数次的。唉，相爱相杀，产品狗何苦为难程序猿，程序猿何苦坑害产品狗。</p>
<p>还有开发一个app要多少钱？这个问题其实不应该问程序员，毕竟程序员大多是写死程序、拿死工资的码农。即便是外包公司的程序员也不会接触到公司业务，除非是谈过外包项目，很有经验的产品负责人才能明白这里的行情。我没在外包公司待过，但私下里接过外包项目，大概了解过外包行情。</p>
<p>找个人接外包一般会有两种工资算法，一种是按日薪支付，一种是按预算均分。按日薪支付是指预估出该项目大概需要多长时间，并与甲方谈妥时间点，找产品做原型，找设计出图，找程序员开发，并按日支付项目参与者在职岗位的平均日薪，当然参与者需要在规定时间内完成工作。按预算均分是指该项目甲方一共能给多少预算，开发该项目的所有人员均分这笔预算。这种方式适合熟人团队开发小项目，例如之前接的一个小项目三万块，后台、iOS、Android一人一万，原型图和设计是甲方提供的，开发时间总计两周。其实有时间的话，还是蛮乐意接这种小外包的。</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
        <tag>外包</tag>
      </tags>
  </entry>
  <entry>
    <title>微信报名系统H5页面开发</title>
    <url>/2016/11/28/%E5%BE%AE%E4%BF%A1%E6%8A%A5%E5%90%8D%E7%B3%BB%E7%BB%9FH5%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>工作需要，用HTML5写一个微信的内置网页，是一个参会报名流程。上次写html还是上学时交作业，现在着实有些手忙脚乱了，现学现用、磕磕绊绊，项目总算告一段落，到了要总结一下的时候了。简单记录了做这个项目时所遇到的问题，有些问题在网上能搜到解决办法，有些问题是为了实现效果耍的小聪明。</p>
<a id="more"></a>

<h2 id="工具以及框架"><a href="#工具以及框架" class="headerlink" title="工具以及框架"></a>工具以及框架</h2><p>由于我只负责h5界面(<del>让我负责java后台也做不来。我对好多语言都有兴趣，对java就是提不起兴趣，或许是因为大学学java学烦了。</del>)，所以就用了<a href="http://www.dcloud.io/" target="_blank" rel="noopener">HBuilder</a>只码web界面，这个开发工具开发h5网页来说很便利，比如它有代码提醒、边改边看模式、手机端网页运行、运行到iPhone上等等功能，但也有不好用的地方，比如快捷键、搜索方式等。</p>
<p>还有开发微信内置web网页必不可少的工具：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1455784140&token=&lang=zh_CN" target="_blank" rel="noopener">微信web开发者工具</a>。很不幸的说开发到中期才发现这个工具，明明就在微信JS-SDK下面就是视而不见。目前这个工具已经升级为开发小程序专用编译器，不能调试微信内置web页面。</p>
<p>当然还有谷歌浏览器Google Chrome，浏览器来说，我之前是火狐党，开发这个项目才用了谷歌浏览器。谷歌的开发者工具挺好用的，有错误调试，样式修改，多种手机屏幕调试。还有<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421141115&token=&lang=zh_CN" target="_blank" rel="noopener">微信JS-SDK说明文档</a>火狐浏览器上目录点击无效，谷歌浏览器就可以调转到相应内容。还有一点，项目中用到了一个别人写好的<code>picker</code>控件，在火狐浏览器上打开一团糟，谷歌浏览器完美运行，幸运的是微信内置浏览器也运行无误。重点说明：我不是火狐黑，项目之外依旧继续用火狐。这时可以感觉到web开发做浏览器兼容还是有很多工作的。</p>
<p>开发微信用的东西肯定要用微信提供的开发样式库<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1455784134&token=&lang=zh_CN" target="_blank" rel="noopener">WeUI</a>，毕竟风格相近直接拿来用就行，即便是不一样，改起来也方便很多。包括微信的JS-SDK的<a href="http://203.195.235.76/jssdk/" target="_blank" rel="noopener">demo示例代码</a></p>
<p>还有号称最接近原生APP体验的高性能前端框架<a href="http://dev.dcloud.net.cn/mui/" target="_blank" rel="noopener">MUI</a>，项目中的picker就是用的这里的。</p>
<h2 id="微信分享调用和地图功能"><a href="#微信分享调用和地图功能" class="headerlink" title="微信分享调用和地图功能"></a>微信分享调用和地图功能</h2><h3 id="分享功能重写，调用地图"><a href="#分享功能重写，调用地图" class="headerlink" title="分享功能重写，调用地图"></a>分享功能重写，调用地图</h3><p>微信分享和地图调用都使用了微信提供的JS-SDK，公众平台有详细的说明文档。这里只记录一些调用步骤和遇到的问题。</p>
<p>微信分享不用单独去写，微信内置网页右上角会自动加入分享功能，默认分享出去的网页样式标题为页面标题，图片为网页中第一张图片，简介也是第一段文字。如果想自定义这些样式内容，就需要重写分享方法。</p>
<p>引入js文件，建议调用<code>https</code>的js地址，如果页面启用了<code>https</code>，使用<code>http</code>的js地址在iOS9中将无法调用sdk</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://res.wx.qq.com/open/js/jweixin-1.0.0.js"</span> type=<span class="string">"text/javascript"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>调用config方法，配置权限验证</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">	debug: <span class="literal">true</span>,<span class="comment">//开启调试模式，一直有alert出现。发布页面时改为false</span></span><br><span class="line">	appId: <span class="string">'wx1234567890032222'</span>,<span class="comment">//微信公众号唯一标示。</span></span><br><span class="line">	timestamp: timestamp,<span class="comment">//时间戳</span></span><br><span class="line">	nonceStr: nonceStr,<span class="comment">//随机串</span></span><br><span class="line">	signature: signature,<span class="comment">//签名</span></span><br><span class="line">	jsApiList: [</span><br><span class="line">		<span class="string">'checkJsApi'</span>,<span class="comment">//验证客户端版本是否支持sdk</span></span><br><span class="line">		<span class="string">'onMenuShareTimeline'</span>,<span class="comment">//分享朋友圈</span></span><br><span class="line">		<span class="string">'onMenuShareAppMessage'</span>,<span class="comment">//发送给朋友</span></span><br><span class="line">		<span class="string">'openLocation'</span>,<span class="comment">//地图</span></span><br><span class="line">		<span class="string">'showOptionMenu'</span><span class="comment">//开启右上角按钮内页面分享按钮</span></span><br><span class="line">	]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">wx.ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 1 判断当前版本是否支持指定 JS 接口，支持批量判断</span></span><br><span class="line">	wx.checkJsApi(&#123;</span><br><span class="line">		jsApiList: [<span class="string">'getNetworkType'</span>, <span class="string">'previewImage'</span>],</span><br><span class="line">		success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">// 地理位置</span></span><br><span class="line">	<span class="built_in">document</span>.querySelector(<span class="string">'#openLocation'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		wx.openLocation(&#123;</span><br><span class="line">			latitude: <span class="number">22.537180</span>,<span class="comment">//纬度</span></span><br><span class="line">			longitude: <span class="number">113.976250</span>,<span class="comment">//经度</span></span><br><span class="line">			name: <span class="string">'xxxx酒店'</span>,<span class="comment">//位置名</span></span><br><span class="line">			address: <span class="string">'地址说明'</span>,</span><br><span class="line">			scale: <span class="number">14</span>,<span class="comment">//地图缩放级别范围从1~28</span></span><br><span class="line">			infoUrl: <span class="string">''</span><span class="comment">//在查看位置界面底部显示的超链接,可点击跳转</span></span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.1 监听“分享给朋友”，按钮点击、自定义分享内容及分享结果接口</span></span><br><span class="line">	wx.onMenuShareAppMessage(&#123;</span><br><span class="line">		title: <span class="string">'分享标题'</span>,</span><br><span class="line">		desc: <span class="string">'分享简介'</span>,</span><br><span class="line">		link: <span class="string">'https://www.baidu.com'</span>,<span class="comment">//分享地址</span></span><br><span class="line">		imgUrl: <span class="string">'http://oalg33nuc.bkt.clouddn.com/image/wechatshareimg.jpg'</span>,<span class="comment">//分享图片的地址</span></span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.2 监听“分享到朋友圈”按钮点击、自定义分享内容及分享结果接口</span></span><br><span class="line">	wx.onMenuShareTimeline(&#123;</span><br><span class="line">		title: <span class="string">'分享标题'</span>,</span><br><span class="line">		desc: <span class="string">'分享简介'</span>,</span><br><span class="line">		link: <span class="string">'https://www.baidu.com'</span>,<span class="comment">//分享地址</span></span><br><span class="line">		imgUrl: <span class="string">'http://oalg33nuc.bkt.clouddn.com/image/wechatshareimg.jpg'</span>,<span class="comment">//分享图片的地址</span></span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	wx.showOptionMenu();<span class="comment">//显示微信右上角点开的分享按钮</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这一块前端网页还是比较简单的，因为所需要的<code>签名signature</code>等参数都是后台算好给的。生成签名需要<code>jsapi_ticket</code>，要拿到<code>jsapi_ticket</code>需要<code>access_token</code>，获取<code>access_token</code>的步骤和在iOS原生应用中做微信分享是一样的，拿<code>appid</code>和<code>secret</code>等参数调用接口获取<code>access_token</code>。</p>
<h3 id="分享按钮显示-隐藏"><a href="#分享按钮显示-隐藏" class="headerlink" title="分享按钮显示/隐藏"></a>分享按钮显示/隐藏</h3><p>分享按钮的显示问题，有时候要求只要指定页面分享出去，其他页面不能要分享，要隐藏掉分享按钮(发给朋友/分享到朋友圈/复制链接/收藏/邮件等等等)。</p>
<table>
<thead>
<tr>
<th align="center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG65.jpeg?raw=true" alt="显示按钮"></th>
<th align="center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG66.jpeg?raw=true" alt="隐藏按钮"></th>
</tr>
</thead>
</table>
<p>显示的页面需要在<code>wx.config</code>的<code>jsApiList:[]</code>里面添加<code>showOptionMenu</code>。并调用<code>wx.showOptionMenu();</code>显示方法。</p>
<p>隐藏的页面需要在<code>wx.config</code>的<code>jsApiList:[]</code>里面添加<code>hideOptionMenu</code>。并调用<code>wx.hideOptionMenu();</code>隐藏方法。</p>
<p>有隐藏就要对应有显示，比如第一个页面不作操作默认显示。第二个页面隐藏了，返回第一个页面分享按钮也会被隐藏。所以第一个页面要有显示调用。</p>
<h2 id="MUI的Picker使用问题"><a href="#MUI的Picker使用问题" class="headerlink" title="MUI的Picker使用问题"></a>MUI的Picker使用问题</h2><h3 id="调用MUI的Picker"><a href="#调用MUI的Picker" class="headerlink" title="调用MUI的Picker"></a>调用MUI的Picker</h3><p>用的MUI框架里的picker，调用起来还是很方便的，<code>layer: 2</code>是联级数量，支持多级picker，如果是单级的layer省略不写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cityPicker = <span class="keyword">new</span> $.PopPicker(&#123;</span><br><span class="line">	layer: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line">cityPicker.setData(cityData);</span><br><span class="line"><span class="keyword">var</span> showCityPickerButton = <span class="built_in">document</span>.getElementById(<span class="string">'showCityPicker'</span>);</span><br><span class="line"><span class="keyword">var</span> cityResult = <span class="built_in">document</span>.getElementById(<span class="string">'selectCityContent'</span>);</span><br><span class="line">showCityPickerButton.addEventListener(<span class="string">'tap'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.activeElement.blur();</span><br><span class="line">	cityPicker.show(<span class="function"><span class="keyword">function</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">		alert(items[<span class="number">0</span>].text + <span class="string">' '</span> + items[<span class="number">1</span>].text);<span class="comment">//点击确认时的选择结果</span></span><br><span class="line">		<span class="comment">//返回 false 可以阻止选择框的关闭</span></span><br><span class="line">		<span class="comment">//return false;</span></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="PopPicker在软键盘弹出时不能完全隐藏"><a href="#PopPicker在软键盘弹出时不能完全隐藏" class="headerlink" title="PopPicker在软键盘弹出时不能完全隐藏"></a>PopPicker在软键盘弹出时不能完全隐藏</h3><p>用的时候还有点问题，在火狐浏览器里，picker的cell都挤在一起了，根本无法滑动。至于是什么原因我也没有研究，因为在微信内置浏览器里可以用。还有另一个bug是不能不改的，iOS中有问题，Android中没问题。就是在输入信息页面，直接点击靠近屏幕下边缘的输入框，页面向上偏移，滑动页面时原本隐藏的picker粗线了。如下左图，右图才是它该有的样子。</p>
<table>
<thead>
<tr>
<th align="center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG67.jpeg?raw=true" alt="picker出现了"></th>
<th align="center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG68.jpeg?raw=true" alt="正常的样子，不该出现"></th>
</tr>
</thead>
</table>
<p>需要在mui.poppicker.js中增加初始化、show和hide方法中display的改变。解决办法如下，或见<a href="http://ask.dcloud.net.cn/article/603" target="_blank" rel="noopener">iOS键盘弹出后PopPicker出现的临时解决方法</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//init构造函数最后增加两行：</span></span><br><span class="line">self.panel.style.display = <span class="string">'none'</span>;</span><br><span class="line">self.body.style.display = <span class="string">'none'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示</span></span><br><span class="line">show: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">	<span class="comment">//增加以下2行</span></span><br><span class="line">	self.panel.style.display = <span class="string">'block'</span>;</span><br><span class="line">	self.body.style.display = <span class="string">'block'</span>;</span><br><span class="line">	self.callback = callback;</span><br><span class="line">	self.mask.show();</span><br><span class="line">	<span class="built_in">document</span>.body.classList.add($.className(<span class="string">'poppicker-active-for-page'</span>));</span><br><span class="line">	self.panel.classList.add($.className(<span class="string">'active'</span>));</span><br><span class="line">	<span class="comment">//处理物理返回键</span></span><br><span class="line">	self.__back = $.back;</span><br><span class="line">	$.back = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		self.hide();</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//隐藏</span></span><br><span class="line">hide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">if</span> (self.disposed) <span class="keyword">return</span>;</span><br><span class="line">	self.panel.classList.remove($.className(<span class="string">'active'</span>));</span><br><span class="line">	self.mask.close();</span><br><span class="line">	<span class="built_in">document</span>.body.classList.remove($.className(<span class="string">'poppicker-active-for-page'</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//增加以下2行</span></span><br><span class="line">	self.panel.style.display = <span class="string">'none'</span>;</span><br><span class="line">	self.body.style.display = <span class="string">'none'</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//处理物理返回键</span></span><br><span class="line">	$.back=self.__back;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MUI的样式mui-min-css与微信的weui-min-css冲突"><a href="#MUI的样式mui-min-css与微信的weui-min-css冲突" class="headerlink" title="MUI的样式mui.min.css与微信的weui.min.css冲突"></a>MUI的样式mui.min.css与微信的weui.min.css冲突</h3><p>因为做的是微信内置网页，所以使用了微信提供的<code>weui.min.css</code>样式，在做picker的时候，需要导入MUI的<code>mui.min.css</code>样式。这样一来<code>weui.min.css</code>里的很多div样式被覆盖了，写好的样式变成一团糟。只能放弃使用<code>mui.min.css</code>。</p>
<p>因为只用了picker，<code>mui.min.css</code>的作用并不多，只有在picker出现时，后面的半透明蒙版。去掉<code>mui.min.css</code>后，这层蒙版便不再出现了。这个问题还是挺大的，影响交互，picker显示时，还可以编辑输入框。</p>
<p>阅遍<code>mui.min.css</code>终于找到这层蒙版的样式控制，把下面这段css代码拿出来，放到自定义的css样式内即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.mui-backdrop</span> &#123;</span><br><span class="line">	<span class="attribute">position</span>: fixed;</span><br><span class="line">	<span class="attribute">z-index</span>: <span class="number">998</span>;</span><br><span class="line">	<span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="iOS第三方输入法遮盖输入框"><a href="#iOS第三方输入法遮盖输入框" class="headerlink" title="iOS第三方输入法遮盖输入框"></a>iOS第三方输入法遮盖输入框</h2><p>这是一个非常头疼的问题，之前一直没有发现，因为我根本不用第三方输入法。iOS原生输入法已经很强大了，搞不懂为什么还有人用搜狗百度之流的垃圾输入法，难道仅仅为了皮肤吗？Too naive。</p>
<p>即使用其他输入法，按顺序点击输入框，或者点击网页内弹出的软键盘上面自带工具条上的左右箭头键，切换输入框，这样操作也不会出现输入法遮盖输入框问题。而且这个问题在Android上也不存在。</p>
<p>唯独，一上来就点击页面底下的输入框，第三方输入法弹出缓慢，页面偏移距离计算错误，出现了输入法遮盖输入框的问题。好多网页出现这种问题，比如：各大门户网站的登录界面。</p>
<p>解决办法有点low，但还是比较完美的解决了这个bug，定义js方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	SCROLLY = <span class="number">300</span>;</span><br><span class="line">	TIMER_NAME = <span class="number">200</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">textfocusClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">window</span>.scrollY &lt; SCROLLY) &#123;</span><br><span class="line">				<span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">400</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, TIMER_NAME)</span><br><span class="line">	&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>会被输入法遮盖的输入框调用方法:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"userNameInput"</span> <span class="attr">onclick</span>=<span class="string">"textfocusClick()"</span> <span class="attr">placeholder</span>=<span class="string">"请输入"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>定义的js方法，第三方输入法弹出时window.scrollY的值小于系统输入法弹出的，我大致试验出一个300的值(网络上给出的100等小值根本不行)。如果小于这个值就说明是第三方输入法首次弹出，要偏移页面<code>window.scrollTo(0, 400);</code>，偏移的数值根据需要设定。输入法本身就弹出了，再切换输入框，window.scrollY值会和系统输入法的一样，不会小于SCROLLY，所以不能偏移页面。因为网页会自动偏移，再进行代码偏移，会出现页面闪动。</p>
<p>输入框添加的是<code>onclick</code>点击事件，只有在点击输入框获取焦点的时候才调用，在用工具条上的切换按钮切换输入框焦点时不会调用。</p>
<h2 id="警示框的悬浮显示"><a href="#警示框的悬浮显示" class="headerlink" title="警示框的悬浮显示"></a>警示框的悬浮显示</h2><p>警示框不固定在页面上，不随页面滑动而滑动，要求悬浮在导航条下面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line">		<span class="keyword">var</span> t = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">		box.style.top = t + <span class="string">"px"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置警示框div的id为<code>box</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position:absolute;width: 100%;height: 45px; left: 0px;"</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="placeholder样式"><a href="#placeholder样式" class="headerlink" title="placeholder样式"></a>placeholder样式</h2><p>自定义输入框placeholder的文字样式，包括字号大小，字体颜色等，css样式如下。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* all */</span></span><br><span class="line"><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123;<span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="attribute">padding-top</span>: <span class="number">2px</span>;&#125;</span><br><span class="line"><span class="selector-pseudo">::-moz-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125;  <span class="selector-tag">firefox</span> 19+ </span><br><span class="line"><span class="selector-pseudo">:-ms-input-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125; <span class="comment">/* ie */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:-moz-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* individual: webkit */</span></span><br><span class="line"><span class="selector-id">#field2</span><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#00f</span>; &#125;</span><br><span class="line"><span class="selector-id">#field3</span><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#090</span>; <span class="attribute">background</span>:lightgreen; <span class="attribute">text-transform</span>:uppercase; &#125;</span><br><span class="line"><span class="selector-id">#field4</span><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123; <span class="attribute">font-style</span>:italic; <span class="attribute">text-decoration</span>:overline; <span class="attribute">letter-spacing</span>:<span class="number">3px</span>; <span class="attribute">color</span>:<span class="number">#999</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* individual: mozilla */</span></span><br><span class="line"><span class="selector-id">#field2</span><span class="selector-pseudo">::-moz-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#00f</span>; &#125;</span><br><span class="line"><span class="selector-id">#field3</span><span class="selector-pseudo">::-moz-placeholder</span> &#123; <span class="attribute">color</span>:<span class="number">#090</span>; <span class="attribute">background</span>:lightgreen; <span class="attribute">text-transform</span>:uppercase; &#125;</span><br><span class="line"><span class="selector-id">#field4</span><span class="selector-pseudo">::-moz-placeholder</span> &#123; <span class="attribute">font-style</span>:italic; <span class="attribute">text-decoration</span>:overline; <span class="attribute">letter-spacing</span>:<span class="number">3px</span>; <span class="attribute">color</span>:<span class="number">#999</span>; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="正则使用"><a href="#正则使用" class="headerlink" title="正则使用"></a>正则使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myreg = <span class="regexp">/^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(17[0-9]&#123;1&#125;)|(18[0-9]&#123;1&#125;))+\d&#123;8&#125;)$/</span>;</span><br><span class="line"><span class="keyword">if</span>(myreg.test(phoneNumText)) &#123;</span><br><span class="line">	alert(<span class="string">"手机号正确"</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS9的适配特性</title>
    <url>/2016/11/27/ios9adaptation/</url>
    <content><![CDATA[<p><a href="https://github.com/ChenYilong/iOS9AdaptationTips#certificate-transparency" target="_blank" rel="noopener">参考文章内容</a></p>
<h2 id="安全的https请求"><a href="#安全的https请求" class="headerlink" title="安全的https请求"></a>安全的https请求</h2><p>iOS9默认把http请求，改为https请求。afn底层应用NSURLConnection受到影响。这一做法称为ATS, App Transport Security 应用程序的安全传输</p>
<a id="more"></a>

<p><strong>TLS1.0 == SSL3.1</strong></p>
<p>HTTP+SSL/TLS+TCP = HTTPS</p>
<h3 id="为了访问http，在info-plist加入以下字段，退回到不安全的网络请求。"><a href="#为了访问http，在info-plist加入以下字段，退回到不安全的网络请求。" class="headerlink" title="为了访问http，在info.plist加入以下字段，退回到不安全的网络请求。"></a>为了访问http，在info.plist加入以下字段，退回到不安全的网络请求。</h3><p>App Transport Security Settings</p>
<p>Allow Arbitrary Loads</p>
<p>NSAppTransportSecurity</p>
<p>NSAllowArbitraryLoads</p>
<h3 id="新特性的解释"><a href="#新特性的解释" class="headerlink" title="新特性的解释"></a>新特性的解释</h3><p>xcode7在编辑app的时候，iOS9下不能进行网络访问。如果从AppStore上下载app，还能正常进行网络访问。</p>
<p>因为ATS是在iOS9.X-SDK下的新特性，AppStore上的应用是基于iOS8.x-SDK或者iOS7.X-SDK的，所以不受iOS9新特性约束。 只有在xcode7 + iOS9才会产生ATS特性。</p>
<h2 id="后台定位问题"><a href="#后台定位问题" class="headerlink" title="后台定位问题"></a>后台定位问题</h2><p>iOS9的后台定位，如果不适配iOS9，则不能偷偷的在后台定位，后台定位的时候，会有蓝条显示。</p>
<p>请求后台定位权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 实例化定位管理器</span><br><span class="line">_locationManager &#x3D; [[CLLocationManager alloc] init];</span><br><span class="line">&#x2F;&#x2F; 2. 设置代理</span><br><span class="line">_locationManager.delegate &#x3D; self;</span><br><span class="line">&#x2F;&#x2F; 3. 定位精度</span><br><span class="line">[_locationManager setDesiredAccuracy:kCLLocationAccuracyBest];</span><br><span class="line">&#x2F;&#x2F; 4.请求用户权限：分为：⓵只在前台开启定位⓶在后台也可定位，</span><br><span class="line">&#x2F;&#x2F;注意：建议只请求⓵和⓶中的一个，如果两个权限都需要，只请求⓶即可，</span><br><span class="line">&#x2F;&#x2F;⓵⓶这样的顺序，将导致bug：第一次启动程序后，系统将只请求⓵的权限，⓶的权限系统不会请求，只会在下一次启动应用时请求⓶</span><br><span class="line">if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;&#x3D; 8) &#123;</span><br><span class="line">	&#x2F;&#x2F;[_locationManager requestWhenInUseAuthorization];&#x2F;&#x2F;⓵只在前台开启定位</span><br><span class="line">	[_locationManager requestAlwaysAuthorization];&#x2F;&#x2F;⓶在后台也可定位</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 5.iOS9新特性：将允许出现这种场景：同一app中多个location manager：一些只能在前台定位，另一些可在后台定位（并可随时禁止其后台定位）。</span><br><span class="line">if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;&#x3D; 9) &#123;</span><br><span class="line">	_locationManager.allowsBackgroundLocationUpdates &#x3D; YES;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 6. 更新用户位置</span><br><span class="line">[_locationManager startUpdatingLocation];</span><br></pre></td></tr></table></figure>

<p>还需要添加info.plist配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSLocationAlwaysUsageDescription<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>应用请求后台定位权限<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>UIBackgroundModes<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>location<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="企业级应用分发问题"><a href="#企业级应用分发问题" class="headerlink" title="企业级应用分发问题"></a>企业级应用分发问题</h2><p>iOS9取消了企业级证书信任按钮。<br>需要去设置-通用-设备管理 里面手动信任打包应用的证书。</p>
<h2 id="Bitcode"><a href="#Bitcode" class="headerlink" title="Bitcode"></a>Bitcode</h2><p>watch 必须包含bitcode iOS不强制支持bitcode  mac os 不支持</p>
<p>通俗解释 在线版安卓ART模式， ART模式 Android runtime 是安卓的系统优化的一种模式，在应用安装的时候，或进行一次预编译，将代码转化为机器语言存储在本地。在每次运行时就不需要进行一次编译了，提升了执行效率。同时也会有预编译后的容量问题，以及应用是否兼容该模式等问题。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS9</tag>
      </tags>
  </entry>
  <entry>
    <title>制作.a和.framework静态库</title>
    <url>/2016/11/14/%E5%88%B6%E4%BD%9C-a%E5%92%8C-framework%E9%9D%99%E6%80%81%E5%BA%93/</url>
    <content><![CDATA[<p>iOS库一般有开源库，静态库和动态库。</p>
<p>开源库是指源代码开放的功能代码，比如AFNetworking。</p>
<p>静态库是指内部代码逻辑看不到，依靠相应的.h头文件调用内部方法的功能模块。有<code>.a静态库</code>和<code>.framework</code>两种形式。比如：百度导航的<code>libbaiduNaviSDK.a</code>，百度地图<code>BaiduMapAPI_Map.framework</code>。使用时要完全拷贝到工程中，调用。</p>
<a id="more"></a>

<p>动态库同样看不到内部代码逻辑，有<code>.dylib</code>(现在为<code>.tbd</code>)和<code>.framework</code>两种形式。比如常见的<code>libz.tbd</code>和<code>Foundation.framework</code>。由系统动态加载到内存中调用。</p>
<p>系统的<code>.framework</code>是动态库，自己创建的<code>.framework</code>是静态库。</p>
<p>本文中所用到的工程代码详见<a href="https://github.com/mxdios/libXDAttributedTool" target="_blank" rel="noopener">github地址libXDAttributedTool</a></p>
<p><strong>注意：</strong></p>
<p><strong>苹果禁止开发者在项目中使用自己创建的动态库。</strong></p>
<p><strong>swift无法制作.a静态库，只能创建.framework静态库。因为.a静态库需要.h头文件配合使用。</strong></p>
<h2 id="制作-a静态库"><a href="#制作-a静态库" class="headerlink" title="制作.a静态库"></a>制作.a静态库</h2><p>.a静态库是iOS开发中常用的一种库文件，通常为一些第三方提供的功能模块。</p>
<p>以我写的一个工具方法<a href="https://github.com/mxdios/XDAttributedTool" target="_blank" rel="noopener">给字符串设置富文本模式</a>为例创建.a静态库</p>
<h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>创建项目，选择iOS -&gt; Framework &amp; Library -&gt; Cocoa Touch Static Library</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160908-0.png?raw=true" alt="创建工程"></p>
<p>将要打包.a静态库的功能代码拖到新建的项目中。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160908-1.png?raw=true" alt="创建工程"></p>
<h3 id="配置工程"><a href="#配置工程" class="headerlink" title="配置工程"></a>配置工程</h3><p>添加要打包.a静态库的代码文件，和添加相对应的.h头文件</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-1.png?raw=true" alt="添加文件"></p>
<p>设置release模式</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-2.png?raw=true" alt="设置release模式"></p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-3.png?raw=true" alt="设置release模式"></p>
<h3 id="编译文件"><a href="#编译文件" class="headerlink" title="编译文件"></a>编译文件</h3><p>真机设备编译，生成真机使用的.a静态库：选择<code>iOS Device</code>设备，<code>command + b</code>编译。编译成功后，<code>.liblibAttributedTool.a</code>由红色变为黑色。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-4.png?raw=true" alt="编译文件"></p>
<p>模拟器编译，生成模拟器使用的.a静态库：选择一个模拟器，<code>.liblibAttributedTool.a</code>会又变为红色，<code>command + b</code>编译。编译成功后，<code>.liblibAttributedTool.a</code>由红色变为黑色。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-4.png?raw=true" alt="编译文件"></p>
<p>这时便生成了两个.a文件，分别用于真机和模拟器</p>
<h3 id="合并-a文件"><a href="#合并-a文件" class="headerlink" title="合并.a文件"></a>合并.a文件</h3><p>选中编译后变黑的<code>liblibAttributedTool.a</code>右键 Show in Finder。<code>Release-iphoneos</code>和<code>Release-iphonesimulator</code>分别为真机和模拟器下生成的静态库文件。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-6.png?raw=true" alt="合并"></p>
<p>打开终端，输入<code>lipo -create</code> <code>空格</code> 拖入模拟器下的静态库.a <code>空格</code> 拖入真机下的静态库.a <code>空格</code> 输入<code>-output</code> <code>空格</code> 输入合并后的.a存放路径/静态库名字 <code>回车</code>。这里演示合并后的名字为<code>libXDAttributedTool.a</code>存放在桌面了，<code>ls</code>显示当前路径下的文件。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-7.png?raw=true" alt="合并"></p>
<p>验证合并后的.a静态库支持的有效架构</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160909-8.png?raw=true" alt="验证"></p>
<h3 id="使用-a静态库"><a href="#使用-a静态库" class="headerlink" title="使用.a静态库"></a>使用.a静态库</h3><p>将合并后的.a静态库和.h头文件(随便在真机或模拟器生成的库文件夹里选一个即可，或者用原项目中的.h头文件)放到一个文件夹内，拖入工程，导入.h文件即可使用。</p>
<p>项目中的<code>libAttributedTool</code>是打包.a静态库的源文件工程</p>
<p>项目中的<code>XDAttributedTool</code>是打包完成，使用.a静态库的测试工程</p>
<p>开源代码使用请见<a href="https://github.com/mxdios/XDAttributedTool" target="_blank" rel="noopener">XDAttributedTool</a></p>
<h2 id="制作-framework静态库"><a href="#制作-framework静态库" class="headerlink" title="制作.framework静态库"></a>制作.framework静态库</h2><p>.framework静态库也经常使用，比如百度地图的一系列<code>BaiduMapAPI</code>都是.framework静态库。</p>
<h3 id="创建工程-1"><a href="#创建工程-1" class="headerlink" title="创建工程"></a>创建工程</h3><p>创建项目，选择iOS -&gt; Framework &amp; Library -&gt; Cocoa Touch Framework。这一步跟打包.a静态库类似，跟打包.a时的截图不一样，是因为Xcode升级了。打包.a时用的Xcode7.3，打包.framework用的Xcode8.0，这就是拖坑不填的结果。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-0.png" alt="img"></p>
<p>将要打包的功能代码拖到新建的项目中。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-1.png" alt="img"></p>
<h3 id="配置工程-1"><a href="#配置工程-1" class="headerlink" title="配置工程"></a>配置工程</h3><p>在<code>Build Phases</code>里的<code>Headers</code>，把需要暴露在外面的.h文件拖动到<code>Public</code>下面，把不需要暴露的.m文件拖动到<code>Project</code>下面。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-2.png" alt="img"></p>
<p>在新创建的工程里有一个和工程名一样的.h头文件，在该文件中引入全部需要暴露的.h文件。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-3.png" alt="img"></p>
<h3 id="添加脚本"><a href="#添加脚本" class="headerlink" title="添加脚本"></a>添加脚本</h3><p>创建Aggregate，点击<code>TARGETS</code>下面的加号，Xcode8.0在<code>Cross-platform</code>里面的<code>Aggregate</code>，Xcode8之前的在<code>Other</code>里面<code>Aggregate</code>。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/2016-10-144.30.53.png" alt="img"></p>
<p>在新添加的<code>Aggregate</code>的<code>Build Phases</code>里面，点击加号，选择<code>New Run Script Phase</code>，添加Run Script脚本。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/2016-10-144.44.46.png" alt="img"></p>
<p>在Run Script代码框中添加脚本。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-4.png" alt="img"></p>
<p>完整脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sets the target folders and the final framework product.</span><br><span class="line"># 如果工程名称和Framework的Target名称不一样的话，要自定义FMKNAME</span><br><span class="line"># 例如: FMK_NAME &#x3D; &quot;MyFramework&quot;</span><br><span class="line">FMK_NAME&#x3D;$&#123;PROJECT_NAME&#125;</span><br><span class="line"># Install dir will be the final output to the framework.</span><br><span class="line"># The following line create it in the root folder of the current project.</span><br><span class="line">INSTALL_DIR&#x3D;$&#123;SRCROOT&#125;&#x2F;Products&#x2F;$&#123;FMK_NAME&#125;.framework</span><br><span class="line"># Working dir will be deleted after the framework creation.</span><br><span class="line">WRK_DIR&#x3D;build</span><br><span class="line">DEVICE_DIR&#x3D;$&#123;WRK_DIR&#125;&#x2F;Release-iphoneos&#x2F;$&#123;FMK_NAME&#125;.framework</span><br><span class="line">SIMULATOR_DIR&#x3D;$&#123;WRK_DIR&#125;&#x2F;Release-iphonesimulator&#x2F;$&#123;FMK_NAME&#125;.framework</span><br><span class="line"># -configuration $&#123;CONFIGURATION&#125;</span><br><span class="line"># Clean and Building both architectures.</span><br><span class="line">xcodebuild -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphoneos clean build</span><br><span class="line">xcodebuild -configuration &quot;Release&quot; -target &quot;$&#123;FMK_NAME&#125;&quot; -sdk iphonesimulator clean build</span><br><span class="line"># Cleaning the oldest.</span><br><span class="line">if [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]</span><br><span class="line">then</span><br><span class="line">rm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line">fi</span><br><span class="line">mkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line">cp -R &quot;$&#123;DEVICE_DIR&#125;&#x2F;&quot; &quot;$&#123;INSTALL_DIR&#125;&#x2F;&quot;</span><br><span class="line"># Uses the Lipo Tool to merge both binary files (i386 + armv6&#x2F;armv7) into one Universal final product.</span><br><span class="line">lipo -create &quot;$&#123;DEVICE_DIR&#125;&#x2F;$&#123;FMK_NAME&#125;&quot; &quot;$&#123;SIMULATOR_DIR&#125;&#x2F;$&#123;FMK_NAME&#125;&quot; -output &quot;$&#123;INSTALL_DIR&#125;&#x2F;$&#123;FMK_NAME&#125;&quot;</span><br><span class="line">rm -r &quot;$&#123;WRK_DIR&#125;&quot;</span><br><span class="line">open &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="配置armv7s"><a href="#配置armv7s" class="headerlink" title="配置armv7s"></a>配置armv7s</h3><p>在<code>TARGETS</code>第一个包下面，<code>Build Settings</code>下面<code>Architectures</code>这一行，点击选择<code>Other</code>，在弹出框中加上armv7s。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-5.png" alt="img"></p>
<h3 id="配置Mach-O-Type"><a href="#配置Mach-O-Type" class="headerlink" title="配置Mach-O Type"></a>配置Mach-O Type</h3><p>在<code>TARGETS</code>第一个包下面，<code>Build Settings</code>下面<code>Mach-O Type</code>，修改为<code>Static Library</code>。修改后编译打包的才是静态库，不然会是动态库。</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/2017-07-26-11-05-33.png" alt="img"></p>
<p>使用动态库需要在<code>General</code> -&gt; <code>Embedded Binaries</code>下引入动态库，不然会报错。其实苹果禁止开发者使用自己创建的动态库。</p>
<h3 id="编译工程"><a href="#编译工程" class="headerlink" title="编译工程"></a>编译工程</h3><p>选中新创建的<code>TARGETS</code>，command + b 编译工程，编译完成后会自动弹出Finder里打包完成的.framework静态库。</p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-6.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/mxdios/libXDAttributedTool/master/image/QQ20161014-8.png" alt="img"></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>静态库</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS10升级后的一些问题</title>
    <url>/2016/11/11/iOS10%E5%8D%87%E7%BA%A7%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在2016年9月14日凌晨iOS10系统准时推送过来了，作为懒人之前的beta版一直没有升级试用。今天果断手机和Xcode一起升级了，新系统新面貌带来新bug。记录一下升级iOS10和Xcode8.0后遇到的问题。</p>
<a id="more"></a>

<h2 id="开发者证书不能使用"><a href="#开发者证书不能使用" class="headerlink" title="开发者证书不能使用"></a>开发者证书不能使用</h2><p>General里面Signing变成如下样子，Automatically manage signing 自动签名管理。报错了，之前一直使用的企业级开发者证书不可用了。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG79.jpeg?raw=true" alt="img"></p>
<p>Build Settings 里面的 Code Signing Identity 清一色选择为企业级开发者证书。还是报错</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160914-0.png?raw=true" alt="img"></p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160914-1.png?raw=true" alt="img"></p>
<p><strong>解决办法：</strong></p>
<p>取消Automatically manage signing的选择，会出现两个Signing，分别对应Debug和Release，选择该项目对应使用的Provisioning Profiles即可</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160914-2.png?raw=true" alt="img"></p>
<h2 id="注释快捷键command-失效"><a href="#注释快捷键command-失效" class="headerlink" title="注释快捷键command+/失效"></a>注释快捷键command+/失效</h2><p>Xcode8.0的注释// 生成快捷键 command+/失效了</p>
<p><strong>解决办法：</strong></p>
<p>终端运行命令：<code>sudo /usr/libexec/xpccachectl</code><br>Password：<code>输入开机密码</code><br>重启Mac生效</p>
<p>生效后空行快捷键，只在代码行能产生/解除注释，空行不能产生注释。记得之前可以来这….</p>
<h2 id="Xcode控制台输出问题"><a href="#Xcode控制台输出问题" class="headerlink" title="Xcode控制台输出问题"></a>Xcode控制台输出问题</h2><h3 id="无用log打印"><a href="#无用log打印" class="headerlink" title="无用log打印"></a>无用log打印</h3><p>升级Xcode8.0之后运行项目，控制台疯狂打印了N多东西，完全看不懂啊，完犊子了，这么多需要适配的…</p>
<p>眼不见心不烦，下面就提供去掉这些乱七八糟打印内容的方法。</p>
<p><strong>解决办法：</strong></p>
<p>在<code>Edit Scheme...</code>下的Run -&gt; Arguments -&gt; Environment Variables 添加  <code>OS_ACTIVITY_MODE</code> = <code>disable</code></p>
<p>具体见下图</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160914-3.png?raw=true" alt="img"></p>
<h3 id="真机测试log屏蔽"><a href="#真机测试log屏蔽" class="headerlink" title="真机测试log屏蔽"></a>真机测试log屏蔽</h3><p>经过上述修改，在iOS10模拟器中无用的log输出被屏蔽了，但是真机测试的时候，没有log输出，log日志被完全屏蔽了。不知是屏蔽无用log的设置，还是xcode8为了提高真机测试性能屏蔽了log日志？真机测试的log也很重要。</p>
<p>为了app正式发布时不打印log，让打印操作<code>NSLog</code>只在<code>Debug</code>环境下运行，采用了下面的办法自定义<code>NSLog</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">#define XDLog(...) NSLog(__VA_ARGS__)</span><br><span class="line">#else</span><br><span class="line">#define XDLog(...)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>iOS10之后，在真机中<code>NSLog</code>无法打印log，可以使用<code>printf()</code>，具体修改见下面自定义log：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">#define XDString [NSString stringWithFormat:@&quot;%s&quot;, __FILE__].lastPathComponent</span><br><span class="line">#define XDLog(...) printf(&quot;%s %d行: %s\n\n&quot;,[XDString UTF8String], __LINE__, [[NSString stringWithFormat:__VA_ARGS__] UTF8String]);</span><br><span class="line">#else</span><br><span class="line">#define XDLog(...)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><code>XDString</code>是获取的该log在哪个文件里，<code>__LINE__</code>该log在第几行。<code>printf()</code>是c语言方法，所以要用<code>UTF8String</code>转义，不然每个log都会有警告。</p>
<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>网络获取数据，做容错处理，判断某个字段是否符合需要的数据类型。之前一度用如下判断方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[NSStringFromClass([userDict[@&quot;plates&quot;] class]) isEqualToString:@&quot;__NSCFArray&quot;]</span><br></pre></td></tr></table></figure>
<p>如果<code>userDict[@&quot;plates&quot;]</code>的数据类型是数组的话，打印出来的就是<code>__NSCFArray</code>类型。同样如果是字典类型的话，打印出来的就是<code>__NSCFDictionary</code>。但是iOS10之后，打印出来的不同了，同样的数组类型，打印出来的是<code>__NSSingleObjectArrayI</code>。</p>
<p>之前的这种判断方法很欠考虑，还是利用下面的方法比较靠谱：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[userDict[@&quot;plates&quot;] isKindOfClass:[NSArray class]]</span><br></pre></td></tr></table></figure>

<h2 id="URL-Schemes跳转系统设置"><a href="#URL-Schemes跳转系统设置" class="headerlink" title="URL Schemes跳转系统设置"></a>URL Schemes跳转系统设置</h2><p>跳转系统设置分为<strong>跳转到系统设置列表</strong>和<strong>跳转到自己app的系统设置</strong>。</p>
<p>跳转系统设置列表的方法在iOS10被彻底关闭了，也就是说你已不能从app跳转到系统设置列表里了。但是还可以跳转到自己app的系统设置</p>
<p>例如：我的某个app使用地理定位，运行app时会检测是否开启地理定位，如果未开启，提醒alert，用如下代码点击跳转到地理定位的开启设置里。</p>
<p>iOS10之前使用下面方法可以跳转到系统设置列表，列表里有自己的app，可以点击进去做相应设置.使用时要添加URL Schemes，字段为<code>prefs</code>。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161010-0.png?raw=true" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSURL *url &#x3D; [NSURL URLWithString:@&quot;prefs:root&#x3D;LOCATION_SERVICES&quot;];</span><br><span class="line">if ([[UIApplication sharedApplication] canOpenURL:url]) &#123;</span><br><span class="line">		[[UIApplication sharedApplication] openURL:url];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>iOS10时该方法被关闭了，只能通过下面方法跳转到自己app的系统设置，使用<code>UIApplicationOpenSettingsURLString</code>，这个字段是在iOS8时出现的。在使用这个方法时，注意iOS8/iOS9时可以使用<code>openURL:</code>，iOS10建议使用<code>openURL:options:completionHandler:</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSURL *url &#x3D; [NSURL URLWithString:UIApplicationOpenSettingsURLString];</span><br><span class="line">if ([[UIApplication sharedApplication] canOpenURL:url]) &#123;</span><br><span class="line">    if (iOS10) &#123;</span><br><span class="line">        [[UIApplication sharedApplication] openURL:url options:@&#123;&#125; completionHandler:^(BOOL success) &#123;</span><br><span class="line">            XDLog(@&quot;success &#x3D; %d&quot;, success);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [[UIApplication sharedApplication] openURL:url];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<table>
<thead>
<tr>
<th align="center">跳转到系统设置列表，iOS10之前可用</th>
<th align="center">跳转到自己app的系统设置，iOS8以后可用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/2016%E5%B9%B410%E6%9C%8810%E6%97%A5%E4%B8%8A%E5%8D%8811.31.12.png?raw=true" alt="img"></td>
<td align="center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/2016%E5%B9%B410%E6%9C%8810%E6%97%A5%E4%B8%8A%E5%8D%8811.33.55.png?raw=true" alt="img"></td>
</tr>
</tbody></table>
<h3 id="附prefs-root"><a href="#附prefs-root" class="headerlink" title="附prefs:root"></a>附prefs:root</h3><p>prefs:root=General&amp;path=About<br>prefs:root=General&amp;path=ACCESSIBILITY<br>prefs:root=AIRPLANE_MODE<br>prefs:root=General&amp;path=AUTOLOCK<br>prefs:root=General&amp;path=USAGE/CELLULAR_USAGE<br>prefs:root=Brightness<br>prefs:root=General&amp;path=Bluetooth<br>prefs:root=General&amp;path=DATE_AND_TIME<br>prefs:root=FACETIME<br>prefs:root=General<br>prefs:root=General&amp;path=Keyboard<br>prefs:root=CASTLE<br>prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP<br>prefs:root=General&amp;path=INTERNATIONAL<br>prefs:root=LOCATION_SERVICES<br>prefs:root=ACCOUNT_SETTINGS<br>prefs:root=MUSIC<br>prefs:root=MUSIC&amp;path=EQ<br>prefs:root=MUSIC&amp;path=VolumeLimit<br>prefs:root=General&amp;path=Network<br>prefs:root=NIKE_PLUS_IPOD<br>prefs:root=NOTES<br>prefs:root=NOTIFICATIONS_ID<br>prefs:root=Phone<br>prefs:root=Photos<br>prefs:root=General&amp;path=ManagedConfigurationList<br>prefs:root=General&amp;path=Reset<br>prefs:root=Sounds&amp;path=Ringtone<br>prefs:root=Safari<br>prefs:root=General&amp;path=Assistant<br>prefs:root=Sounds<br>prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK<br>prefs:root=STORE<br>prefs:root=TWITTER<br>prefs:root=General&amp;path=USAGE<br>prefs:root=VIDEO<br>prefs:root=General&amp;path=Network/VPN<br>prefs:root=Wallpaper<br>prefs:root=WIFI<br>prefs:root=INTERNET_TETHERING  </p>
<h2 id="plist里声明获取隐私数据权限"><a href="#plist里声明获取隐私数据权限" class="headerlink" title="plist里声明获取隐私数据权限"></a>plist里声明获取隐私数据权限</h2><p>访问隐私数据需要在plist里声明，在iOS10之前只需要声明地理定位之类的敏感隐私数据，获取照片、相机等不需要再plist里声明。iOS10之后，这些也必须声明，不声明会crash。需要声明的用户数据有：</p>
<blockquote>
<p>Contacts（联系人）, Calendar（日历）, Reminders（提醒事件）, Photos（照片）, Bluetooth Sharing（蓝牙共享）, Microphone（麦克风）, Camera（相机）, Location（位置）, Health（健康）, HomeKit（家居）, Media Library（媒体库）, Motion（运动）, CallKit（打电话）, Speech Recognition（语言识别）, SiriKit（Siri）, TV Provider（电视提供商）.</p>
</blockquote>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160921-0.png?raw=true" alt="img"></p>
<p>后面string字段填写弹出用户允许时展示的描述信息。<strong>注意，这里必须要写明获取该权限的用途，不然会被AppStore拒绝上架的。</strong></p>
<h2 id="某些app链接网络失败"><a href="#某些app链接网络失败" class="headerlink" title="某些app链接网络失败"></a>某些app链接网络失败</h2><p>iOS10之后出现了实用无线局域网与蜂窝移动网络的允许授权弹窗，有些应用没有出现这个弹窗，莫名其妙的就连不上网络了，去设置的“使用无线局域网与蜂窝移动的应用”里找也找不到，搜索该应用，也没有开启使用网络授权的开关。</p>
<p>其实只需要在“使用无线局域网与蜂窝移动的应用”里面修改任意一个应用的使用网络设置，再打开连不上网的应用，就会出现网络授权弹窗。这是一个系统bug，希望后续的iOS10.x.x系统会修复。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS10</tag>
      </tags>
  </entry>
  <entry>
    <title>提交应用到AppStore的准备工作</title>
    <url>/2016/11/10/%E6%8F%90%E4%BA%A4%E5%BA%94%E7%94%A8%E5%88%B0AppStore%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>本文详细记录了提交应用到AppStore的准备工作，以及准备的内容对应AppStore上APP的呈现方式，还列出某些内容是不能随意修改的，以及填写时的注意点，还有我提交APP时踩到的坑。对已有过上架经验的开发者来说本文意义不大，但是当产品经理问上架AppStore需要什么资料时，可以把本文分享给他。</p>
<a id="more"></a>

<h2 id="App信息"><a href="#App信息" class="headerlink" title="App信息"></a>App信息</h2><p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160815-7.png?raw=true" alt="iTunes Connect内APP信息截图"></p>
<h3 id="公司名称"><a href="#公司名称" class="headerlink" title="公司名称"></a>公司名称</h3><p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/WechatIMG1081.jpeg?raw=true" alt="12306显示的公司名称"></p>
<p>公司名字是指显示在这里的名字。这个只针对公司级账号说的，个人账号不能设置公司名称，只能以开发商名字显示。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160930-0.png?raw=true" alt="设置公司名"></p>
<p>每个账号在iTunes Connect里创建第一个应用的时候，可以设置公司名字。如果不设置的话，就显示开发商名字。日后不能修改公司名字，也不能重新设置。只能给苹果开发者发邮件，要求去掉公司名显示开发商名字。</p>
<h3 id="app名称"><a href="#app名称" class="headerlink" title="app名称"></a>app名称</h3><p>您的 App 在 App Store 中显示的名称。名称长度不能超过<del>255个字符</del> 50个字符（新审核指南修改）。并不等同于app安装完成在手机上显示的名字，这里的名称可以写为名字+简介。</p>
<p>例如：天猫在AppStore展示的名称如下图，应用名为“天猫”</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/image/%E5%9B%BE%E7%89%87%201.png" alt="天猫"></p>
<h3 id="隐私政策网址-可不填"><a href="#隐私政策网址-可不填" class="headerlink" title="隐私政策网址(可不填)"></a>隐私政策网址(可不填)</h3><p>您所在机构的隐私政策网址(URL)。面向儿童或提供自动续费的 App 内购买项目或免费订阅的 App, 均需要隐私政策。另外, 需用帐户注册、使用现有帐户访问、或由法律另行规定的 App 也需隐私政策。对于收集用户或设备相关数据的 App, 亦推荐使用隐私政策。</p>
<h3 id="套装ID"><a href="#套装ID" class="headerlink" title="套装ID"></a>套装ID</h3><p>套装 ID 必须与您在 Xcode 中使用的 ID 相符。该 ID 在您上传第一个构建版本后便无法更改。</p>
<p>开发人员设置的，在开发信息配置里<code>Certificates, Identifiers &amp; Profiles</code>注册的<code>Identifiers</code>。一般与工程中的<code>Bundle Identifier</code>相同，如果<code>Identifiers</code>使用了通配符<code>*</code>则不需要完全一样(应用有消息推送功能，不能使用通配符！)。</p>
<h3 id="SKU"><a href="#SKU" class="headerlink" title="SKU"></a>SKU</h3><p>您 App 专有的 ID, 此 ID 不会在 App Store 中显示。</p>
<p>开发人员设置，注意保持唯一性。</p>
<h3 id="Apple-ID"><a href="#Apple-ID" class="headerlink" title="Apple ID"></a>Apple ID</h3><p>为您的 App 自动生成的 ID。无需设置，在<code>iTunes Connect</code>创建了应用就会生成此ID。做qq登录分享功能在腾讯开放平台注册应用时需要提交这个ID。</p>
<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>最能准确描述此 App 的类别。分为主要类别和次要类别，次要类别可不填。有如下类别：</p>
<p>报刊杂志、财务、参考、导航、儿童、工具、购物、健康健美、教育、旅游、美食佳饮、商品指南、商务、社交、摄影与录像、生活、体育、天气、图书、效率、新闻、医疗、音乐、游戏、娱乐。</p>
<p>详情请见：<a href="https://itunesconnect.apple.com/itc/static/category_definitions" target="_blank" rel="noopener">AppStore类别定义</a></p>
<h3 id="分级"><a href="#分级" class="headerlink" title="分级"></a>分级</h3><p>此 App 分级将在所有平台的 App Store 中显示。此分级根据分级限制最高的 App 平台而定。</p>
<h2 id="App版本信息"><a href="#App版本信息" class="headerlink" title="App版本信息"></a>App版本信息</h2><h3 id="app预览和屏幕快照"><a href="#app预览和屏幕快照" class="headerlink" title="app预览和屏幕快照"></a>app预览和屏幕快照</h3><p>屏幕快照必须为 JPG 或 PNG 格式，且必须采用 RGB 颜色空间。 App 预览必须为 M4V、MP4 或 MOV 格式，且不能超过 500 MB。</p>
<p>现在只需要提交5.5英寸的图片，其他尺寸会沿用5.5的图片，尺寸为1242*2208。可以设计几张app介绍图或者用手机截屏。也可以用模拟器保存界面快照，操作：<code>command + s</code>，注意模拟器有显示百分比，在<code>模拟器-&gt;Window-&gt;Scale</code>里面，快捷键是<code>command + 12345</code>，保存界面快照时要<code>command + 1</code>100%模拟器显示。非Retina屏(低分辨率)的Mac模拟器会超过屏幕，但不影响快照保存。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160815-4.png?raw=true" alt="屏幕快照"></p>
<h3 id="描述-关键字-技术支持网址-营销网址"><a href="#描述-关键字-技术支持网址-营销网址" class="headerlink" title="描述/关键字/技术支持网址/营销网址"></a>描述/关键字/技术支持网址/营销网址</h3><p>描述：对您 App 的描述，用以详细说明特性和功能。它还将用于您的 Apple Watch App。显示于AppStore中的内容提要</p>
<p>关键字：一个或多个关键词，用以描述您的 App。关键词将使 App Store 搜索结果更加准确。</p>
<p>技术支持网址：您的 App 技术支持信息网址(URL)。该网址(URL)将会在 App Store 中显示。显示位置为<code>开发人员网站</code>。点击在Safari中打开网址。一般会填写官网地址。</p>
<p>营销网址：您的 App 营销信息网址(URL)。该网址(URL)会在 App Store 中显示。可不填写。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160815-5.png?raw=true" alt="app描述显示的位置"></p>
<h2 id="构建版本"><a href="#构建版本" class="headerlink" title="构建版本"></a>构建版本</h2><p>提交app到AppStore审核最重要的地方！提交打包好的.api文件</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/image/QQ20160815-11.png" alt="构建版本"></p>
<p>但并不是在这里面上传.api文件。而是需要用<code>Application Loader</code>交付应用程序。<code>Application Loader</code>的位置在<code>Xcode</code> -&gt; <code>Open DeveloperTool</code> -&gt; <code>Application loader</code>，或者在应用程序里<code>Xcode.app</code>右键显示包内容 -&gt; <code>Contents</code> -&gt; <code>Applications</code> -&gt; <code>Application loader.app</code>，选择交付应用程序。这里要事先登录上架应用的开发者账号，也就是打包.api文件时配置发布证书的开发者账号。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161212-0.png?raw=true" alt="使用Application loader交付应用程序"></p>
<p>在交付应用程序的时候，点背的话会一直显示<code>正在通过AppStore进行鉴定</code>，然后就一直等然后也没有然后，我曾晚上11点交付应用程序，然后就这样显示了一夜，第二天醒来依旧正在通过AppStore进行鉴定。</p>
<p>至于为什么会这样，相信大家都心知肚明。好多开发者选择翻墙交付应用程序，我也经常这么干，亲测挺快的。其实有时候人品正，在墙内也可以很快交付。我还在网上找到过一个解决办法，需要修改Application Loader里的一个文件内容，亲测过确实有效。</p>
<p>路径为</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app显示包内容 -&gt; Contents/Applications/Application Loader.app显示包内容 -&gt; Contents/itms/java/<span class="class"><span class="keyword">lib</span>/<span class="title">net</span>.<span class="title">properties</span></span></span><br></pre></td></tr></table></figure>
<p>或者路径为</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app显示包内容 -&gt; Contents/Applications/Application Loader.app显示包内容 -&gt; Contents/MacOS/itms/java/<span class="class"><span class="keyword">lib</span>/<span class="title">net</span>.<span class="title">properties</span></span></span><br></pre></td></tr></table></figure>
<p>打开这个文件，把第34行的<code>http.proxyPort=443</code> 改为<code>https.proxyPort=80</code> 再提交应用就ok了。</p>
<h2 id="App综合信息"><a href="#App综合信息" class="headerlink" title="App综合信息"></a>App综合信息</h2><h3 id="app图标"><a href="#app图标" class="headerlink" title="app图标"></a>app图标</h3><p>此图标将用于 App Store，其格式必须为 JPG 或 PNG，最低分辨率至少为 72 DPI，并采用 RGB 色彩空间。它不能包含图层或圆角。尺寸为1024*1024。</p>
<p>在开发中，只需要让设计同事提供一个1024*1024的app图标即可，可以用<a href="https://itunes.apple.com/cn/app/prepo/id476533227?mt=12" target="_blank" rel="noopener">Prepo</a>生成各种需要的图标尺寸。</p>
<h3 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h3><p>拥有您的 App 专有权的人员或实体的名称，前面是获得权利的年份（例如“2008 Acme Inc”），请勿提供网址(URL)，显示在AppStore。不填写年份，只填写所有权组织或个人也可以。</p>
<h3 id="商务代表联系信息"><a href="#商务代表联系信息" class="headerlink" title="商务代表联系信息"></a>商务代表联系信息</h3><p>您可以为您的 App 在韩国 App Store 中提供额外信息，这一额外信息只会显示在韩国 App Store 中。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160815-9.png?raw=true" alt="分级显示和版权信息显示"></p>
<h3 id="分级-1"><a href="#分级-1" class="headerlink" title="分级"></a>分级</h3><p>为app指定分级，一般都会指定低级，但也要根据实际情况。会影响AppStore审核。如果所有分级全选无，为4+等级，会询问此app是否是针对儿童的，根据实际情况选择。</p>
<p><a href="https://itunesconnect.apple.com/itc/views/shared/app_store_rating_matrix.html" target="_blank" rel="noopener">了解详情</a></p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160815-10.png?raw=true" alt="分级列表"></p>
<h2 id="APP审核信息"><a href="#APP审核信息" class="headerlink" title="APP审核信息"></a>APP审核信息</h2><p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160815-3.png?raw=true" alt="APP审核信息"></p>
<h3 id="联系信息："><a href="#联系信息：" class="headerlink" title="联系信息："></a>联系信息：</h3><p>一般会填写开发者的联系信息，在App审核中有问题会联系开发者，其实有问题被拒绝上架了也没联系过我，iTunes Connect里会有拒绝原因。app审核结果不会通过这个联系方式反馈，会反馈给开发者账号邮箱。可以下载<code>Connect</code>应用，登录提交app的开发者账号，随时接收审核状态消息推送。<del>我不会说这个应用一点都不好用，但只此一家别无分号，爱用不用</del></p>
<h3 id="演示账户："><a href="#演示账户：" class="headerlink" title="演示账户："></a>演示账户：</h3><p>提供给AppStore审核人员用于登录app的账号密码，必须有效可登录，<strong>非常重要,别问我是怎么知道的(ㄒoㄒ)~~orz</strong>。有的应用是手机号+验证码登录，需要事先让服务器同事留好后门，设定固定手机号+固定验证码能随时登录。(按说这应该开发时就得做到，不然开发者每次登录操作都获取验证码多麻烦，而且这还是要花钱的)</p>
<h3 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h3><p>对审核过程会有所帮助的、有关您 App 的额外信息, 包括在测试中需要的 App 特别设置等。额外说明app里某些影响到审核的部分，可以放入图片链接或者操作视频链接以弥补审核人员不能操作到的部分(比如：p2p项目中绑定银行卡)。</p>
<h3 id="版本发布："><a href="#版本发布：" class="headerlink" title="版本发布："></a>版本发布：</h3><p>这个根据实际情况设置，随便设置，为了一切尽在掌控，我会选择手动发布此版本，你应该体会一下应用审核通过点击发布按钮那一刻的感觉！（千万别点击开发者撤下提交的版本…）</p>
<h2 id="之前不幸踩过的一些坑，被AppStore拒了"><a href="#之前不幸踩过的一些坑，被AppStore拒了" class="headerlink" title="之前不幸踩过的一些坑，被AppStore拒了"></a>之前不幸踩过的一些坑，被AppStore拒了</h2><ol>
<li><p><strong>微信登录/支付/分享：</strong>微信没有提供网页登录。如果手机没有安装微信，不能提醒用户下载微信。正确做法是隐藏掉微信按钮。</p>
</li>
<li><p><strong>qq登录：</strong>qq登录提供了网页登录，但是如果手机没安装qq，腾讯有时会一(chou)意(bu)孤(yao)行(lian)的跳转到qq应用下载页。如果是这样的话一定被拒！正确做法是：一定要测试没有qq客户端的时候登录会不会到网页qq登录，如果跳到了qq下载页，联系腾讯客服人员，提供appid，他们会给改好。</p>
</li>
<li><p><strong>举报功能：</strong>如果应用中存在用户发布的内容，比如用户可以发布状态、帖子等(类似微博)，就必须有举报功能。</p>
</li>
<li><p><strong>新版本检测：</strong>这一条是后来加的审核规则(苹果的审核规则号称大道无形，就是一切我说了算，说你不行你就不行行也不行，见过最搞笑的被拒案例是：一个娱乐型app被拒了，理由是我们感觉您的app不具有娱乐性。全公司懵逼…)。检测是否有新版本之前是可以的，后来苹果不允许了，新版本检测都放到AppStore里进行。但是这种行为并不是不允许的，苹果不允许的是用户在app内手动检测新版本，换句话说app内不允许存在检测新版本的按钮操作，可以隐式的调用后台接口检测后台的版本库，弹窗提醒用户有新版本。</p>
</li>
<li><p><strong>iOS/iPhone/iPad/Mac等名词：</strong>这些苹果专属的名词在app中如果有展示，一定不要写错了，注意大小写，如果错了一定被拒。不展示的话就无所谓了，比如说在代码中定义一个变量名写IpHonE都没人管你(写这样的变量名不排除同事会砍死你)。</p>
</li>
<li><p><strong>未完成模块：</strong>AppStore不接受测试版或未完成版，某个模块如果未完成千万不要为了用户体验贱贱的写上模块开发中…之类的提示，这样会被拒绝上架的。留一个空白页面或者按钮点击没反应可能会上架成功。</p>
</li>
<li><p><strong>64位/https/bitcode：</strong>应用必须支持64位包括应用中使用的静态库，如果不支持64位，交付应用程序就会失败，根本到不了审核。https安全网络请求，目前为止并没有强制这样做，不保证以后会不会强制。比如现在app必须包含<code>IPv6-only</code>网络支持。bitcode Watch应用必须支持，iOS应用可支持可不支持，Mac应用不支持。</p>
</li>
<li><p><strong>后台地理定位：</strong>使用后台地理定位Background Modes为打开状态，需要在<code>info.plist</code>的<code>NSLocationAlwaysUsageDescription</code>字段添加文字描述，说清楚后台地理定位用在什么地方了。</p>
<blockquote>
<p>Please revise the NSLocationAlwaysUsageDescription value in the info.plist to specify the intended purpose of using the user’s location while the app is in the background.</p>
</blockquote>
<p> 还有一个很重要的地方，就是必须在提交app到AppStore时填写的描述里添加电池使用免责声明，提示用户后台定位操作会消耗电量并且影响电池续航能力。这个规则略坑啊</p>
<blockquote>
<p>Please also add the following battery use disclaimer in your Application Description:<br>“Continued use of GPS running in the background can dramatically decrease battery life.”</p>
</blockquote>
</li>
<li><p><strong>其他权限获取：</strong>iOS10以后增加了一些原本不需要的权限介绍，比如获取相机/相册等。这些都需要在<code>info.plist</code>里增加字段，不然在iOS10上会崩溃，肯定会被拒的。iOS10更多问题请见<a href="https://github.com/mxdios/notebook/blob/master/notebooks/iOS10%E5%8D%87%E7%BA%A7%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98.md" target="_blank" rel="noopener">iOS10升级后的一些问题</a></p>
</li>
<li><p><strong>app内购：</strong>苹果规定，虚拟产品要走app内购(<del>走内购苹果会拿走30%的利润，感觉好赚钱的样子</del>)，不能走第三方支付。问题是：总有一些产品经理会拿一些案例说服开发者可以走第三方支付，比如：微博购买会员可以使用微信支付宝等支付(还有上述第二条qq登录问题，忘记了是不是糗事百科还是哪个段子应用，一直跳转qq下载页，竟然依旧上架无忧，还有若干带有新版本检测功能的app在AppStore大行其道，这样让开发者很难做啊，说实现不了会被指责无能的)。开发者解释无效后，被AppStore狠狠地打脸拒绝。下次直接对产品说：那是微博产品经理和苹果公司合作洽谈的结果，毕竟微博在iPhone手机里有内置的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>AppStore</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发笔记</title>
    <url>/2016/11/09/iOS%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>记录了在iOS开发中踩过的坑和一些问题解决</strong></p>
<p>本文不断更新中…</p>
<a id="more"></a>


<h2 id="微信的openid"><a href="#微信的openid" class="headerlink" title="微信的openid"></a>微信的openid</h2><p>微信的openid对于某个用户来说并不是唯一的，某个用户对某个公众号或者对某个微信开放平台下某个appid生成的是唯一的。appid改变，openid也会改变。公众号下和app下获得的openid不同，现阶段无法实现相同操作。使用unionid打通用户，微信开放平台上绑定了公众号，这时获取的unionid会一致。</p>
<h2 id="Cell进入编辑状态，内容覆盖编辑按钮"><a href="#Cell进入编辑状态，内容覆盖编辑按钮" class="headerlink" title="Cell进入编辑状态，内容覆盖编辑按钮"></a>Cell进入编辑状态，内容覆盖编辑按钮</h2><p>删除一条cell时，最常用的方法就是侧滑删除。</p>
<p>还有就是点击编辑按钮，cell进入编辑状态，点击红色减号button，出现删除按钮，点击删除完成删除操作。这时会出现问题，cell上的内容遮盖了删除按钮，如下图所示。</p>
<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/image/Untitleds.gif" alt="如图"></p>
<p>解决这个问题，只需要在自定义cell里加如下代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isEditing) &#123;</span><br><span class="line">        [<span class="keyword">self</span> sendSubviewToBack:<span class="keyword">self</span>.contentView];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://imagedb-1257991841.cos.ap-beijing.myqcloud.com/QQ20160722-0.png" alt="结果"></p>
<h2 id="View中部分内嵌UIWebView"><a href="#View中部分内嵌UIWebView" class="headerlink" title="View中部分内嵌UIWebView"></a>View中部分内嵌UIWebView</h2><p>在开发中，有的界面要求部分原生，部分根据服务器返回的URL地址显示网页。这就需要计算这部分网页的size。不然就会显示不全或者留白太多</p>
<p>创建UIWebView 并加载页面</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIWebView</span> *webview = [[<span class="built_in">UIWebView</span> alloc] init]; <span class="comment">//创建webview</span></span><br><span class="line">webview.delegate = <span class="keyword">self</span>;  <span class="comment">//设置代理</span></span><br><span class="line">[webview loadHTMLString:url baseURL:<span class="literal">nil</span>]; <span class="comment">//加载网页</span></span><br><span class="line">[<span class="keyword">self</span>.view addSubview:webview]; <span class="comment">//添加到view上</span></span><br></pre></td></tr></table></figure>

<p>在webView的代理方法中获取网页实际size</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView</span><br><span class="line">&#123;</span><br><span class="line">    webView.width = <span class="keyword">self</span>.view.width; <span class="comment">//实际宽度</span></span><br><span class="line">    webView.height = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"document.body.scrollHeight"</span>].floatValue; <span class="comment">//实际高度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置UITextField的placeholder字体的颜色和字号"><a href="#设置UITextField的placeholder字体的颜色和字号" class="headerlink" title="设置UITextField的placeholder字体的颜色和字号"></a>设置UITextField的placeholder字体的颜色和字号</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">textField.placeholder = <span class="string">@"请输入用户名"</span>;  </span><br><span class="line">[textField setValue:[<span class="built_in">UIColor</span> redColor] forKeyPath:<span class="string">@"_placeholderLabel.textColor"</span>];  </span><br><span class="line">[textField setValue:[<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">16</span>] forKeyPath:<span class="string">@"_placeholderLabel.font"</span>];</span><br></pre></td></tr></table></figure>

<h2 id="按钮的拖动效果和点击事件并存"><a href="#按钮的拖动效果和点击事件并存" class="headerlink" title="按钮的拖动效果和点击事件并存"></a>按钮的拖动效果和点击事件并存</h2><p>需求是一个按钮可以在屏幕中随意拖动，不能拖出屏幕外。距离屏幕最边缘有10像素的距离。拖动结束后，根据距离左右两侧哪侧近，靠到近的一侧。</p>
<p>定义<code>Bool</code>类型的全部变量，控制是否执行点击事件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> _isClick;</span><br></pre></td></tr></table></figure>

<p>创建按钮添加拖动和点击事件</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加点击事件</span></span><br><span class="line">[btn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(btnClick:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line"><span class="comment">//添加拖动事件</span></span><br><span class="line">[btn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(dragMoving:withEvent:)forControlEvents: <span class="built_in">UIControlEventTouchDragInside</span>];</span><br><span class="line"><span class="comment">//添加拖动结束时的事件</span></span><br><span class="line">[btn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(dragEnded:withEvent:)forControlEvents: <span class="built_in">UIControlEventTouchUpInside</span>];</span><br></pre></td></tr></table></figure>

<p>实现事件方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拖动过程中</span></span><br><span class="line">- (<span class="keyword">void</span>)dragMoving:(<span class="built_in">UIControl</span> *)c withEvent:ev</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> point = [[[ev allTouches] anyObject] locationInView:<span class="keyword">self</span>.view];   </span><br><span class="line">    point.x = MIN(MAX(point.x, btn.width * <span class="number">0.5</span> + <span class="number">10</span>) , <span class="keyword">self</span>.view.width - btn.width * <span class="number">0.5</span> - <span class="number">10</span>);<span class="comment">//范围</span></span><br><span class="line">    point.y = MIN(MAX(point.y, <span class="number">100</span>), <span class="keyword">self</span>.view.height - btn.height * <span class="number">0.5</span> - <span class="number">10</span>);<span class="comment">//范围</span></span><br><span class="line">    c.center = point;</span><br><span class="line">    _isClick = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拖动结束</span></span><br><span class="line">- (<span class="keyword">void</span>)dragEnded:(<span class="built_in">UIControl</span> *)c withEvent:ev</span><br><span class="line">&#123;</span><br><span class="line">    XDLog(<span class="string">@"dragEnded...."</span>);   </span><br><span class="line">    <span class="built_in">CGPoint</span> point = [[[ev allTouches] anyObject] locationInView:<span class="keyword">self</span>.view];</span><br><span class="line">    point.x = MIN(MAX(point.x, btn.width * <span class="number">0.5</span> + <span class="number">10</span>), <span class="keyword">self</span>.view.width - btn.width * <span class="number">0.5</span> - <span class="number">10</span>);<span class="comment">//范围</span></span><br><span class="line">    point.y = MIN(MAX(point.y, <span class="number">100</span>) , <span class="keyword">self</span>.view.height - btn.height * <span class="number">0.5</span> - <span class="number">10</span>);<span class="comment">//范围</span></span><br><span class="line">    c.center = point;</span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.2</span> animations:^&#123;</span><br><span class="line">        c.centerX = c.centerX &lt; <span class="keyword">self</span>.view.width - c.centerX ? <span class="number">30</span> : <span class="keyword">self</span>.view.width - <span class="number">30</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    _isClick = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点击事件</span></span><br><span class="line">- (<span class="keyword">void</span>)btnClick:(<span class="built_in">UIButton</span> *)btn</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_isClick) &#123;</span><br><span class="line">    	<span class="comment">//点击方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UITableViewCell左滑编辑字体颜色设置"><a href="#UITableViewCell左滑编辑字体颜色设置" class="headerlink" title="UITableViewCell左滑编辑字体颜色设置"></a>UITableViewCell左滑编辑字体颜色设置</h2><p>设置按钮，iOS8之后API，用下面代码设置多个按钮</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">UITableViewRowAction</span> *&gt; *)tableView:(<span class="built_in">UITableView</span> *)tableView editActionsForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span>(^rowActionHandler)(<span class="built_in">UITableViewRowAction</span> *, <span class="built_in">NSIndexPath</span> *) = ^(<span class="built_in">UITableViewRowAction</span> * _Nonnull action, <span class="built_in">NSIndexPath</span> * _Nonnull indexPath) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@  index = %ld"</span>, action.title, indexPath.row);</span><br><span class="line">        [tableView setEditing:<span class="literal">NO</span> animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">UITableViewRowAction</span> *action1 = [<span class="built_in">UITableViewRowAction</span> rowActionWithStyle:<span class="built_in">UITableViewRowActionStyleNormal</span> title:<span class="string">@"编辑"</span> handler:rowActionHandler];</span><br><span class="line">    <span class="built_in">UITableViewRowAction</span> *action2 = [<span class="built_in">UITableViewRowAction</span> rowActionWithStyle:<span class="built_in">UITableViewRowActionStyleNormal</span> title:<span class="string">@"删除"</span> handler:rowActionHandler];</span><br><span class="line">    <span class="built_in">UITableViewRowAction</span> *action3 = [<span class="built_in">UITableViewRowAction</span> rowActionWithStyle:<span class="built_in">UITableViewRowActionStyleNormal</span> title:<span class="string">@"喜欢"</span> handler:rowActionHandler];</span><br><span class="line">    action1.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    action2.backgroundColor = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line">    action3.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    <span class="keyword">return</span> @[action3,action1,action2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式显示的样式是系统自带的，系统指定字体和文字颜色。</p>
<p>按钮可以修改文字颜色，添加标题图片，背景图片等。<code>UITableViewRowAction</code>的显示为<code>UIButton</code>，修改<code>UIButton</code>的显示样式，cell的多个编辑按钮都会变化</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">UIButton</span> appearance] setTitleColor:[<span class="built_in">UIColor</span> blackColor] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">[[<span class="built_in">UIButton</span> appearance] setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"searchtool"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">[[<span class="built_in">UIButton</span> appearance] setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"searchtool"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</span><br></pre></td></tr></table></figure>

<p>值得注意的是下面这种方式设置字号无效</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">UIButton</span> appearance].titleLabel.font = XDFont(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>只有一个按钮的话可以使用<code>NSAttributedString</code>设置显示文字的字体、字号、颜色等</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *attributes = @&#123;<span class="built_in">NSFontAttributeName</span>:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">10</span>], <span class="built_in">NSForegroundColorAttributeName</span>:[<span class="built_in">UIColor</span> redColor]&#125;;</span><br><span class="line"><span class="built_in">NSAttributedString</span> *attributedTitle = [[<span class="built_in">NSAttributedString</span> alloc] initWithString:<span class="string">@"编辑"</span> attributes: attributes];</span><br><span class="line">[[<span class="built_in">UIButton</span> appearance] setAttributedTitle:attributedTitle forState:<span class="built_in">UIControlStateNormal</span>];</span><br></pre></td></tr></table></figure>

<p><em>这种实现方式并不好有诸多问题，当有多个按钮分别设置不同的字体字号颜色时，这种方式无法实现，当找到有效方法再添加….此条权当问题记录</em></p>
<h2 id="用Application-Loader交付应用程序时，一直正在通过AppStore进行鉴定"><a href="#用Application-Loader交付应用程序时，一直正在通过AppStore进行鉴定" class="headerlink" title="用Application Loader交付应用程序时，一直正在通过AppStore进行鉴定"></a>用Application Loader交付应用程序时，一直正在通过AppStore进行鉴定</h2><p>需要修改Application Loader里的一个文件内容。</p>
<p>路径为</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app显示包内容 -&gt; Contents/Applications/Application Loader.app显示包内容 -&gt; Contents/itms/java/<span class="class"><span class="keyword">lib</span>/<span class="title">net</span>.<span class="title">properties</span></span></span><br></pre></td></tr></table></figure>
<p>或者路径为</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app显示包内容 -&gt; Contents/Applications/Application Loader.app显示包内容 -&gt; Contents/MacOS/itms/java/<span class="class"><span class="keyword">lib</span>/<span class="title">net</span>.<span class="title">properties</span></span></span><br></pre></td></tr></table></figure>
<p>打开这个文件，把第34行的http.proxyPort=443 改为https.proxyPort=80  再提交应用就ok了</p>
<h2 id="pdf的展示"><a href="#pdf的展示" class="headerlink" title="pdf的展示"></a>pdf的展示</h2><p>项目里要求读取从服务器下载下来的pdf，pdf文件是一个发票文件，下载到本地Documents目录下，展示出来。问题来了，发票上的印章不见了。</p>
<p>我将这个pdf文件放到了各种应用中打开，结果是：微信、qq、印象笔记、掌阅iReader、Safari、iBooks、WPS Office、mac上的预览，除了WPS Office、mac上的预览能显示出印章，其他的全部显示不出印章，甚至微信、掌阅iReader连发票上的分割线都显示不出来。</p>
<p>而且，用WPS Office打开，可以点击印章删除，可以点击分割线删除。这时我感觉印章和分割线是在pdf上的标注，就像以前使用Adobe的工具给pdf加标注文字，选中文字高亮显示。</p>
<p><strong>最开始使用了最简单的展示pdf文件的方法：UIWebView</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *paths = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>);</span><br><span class="line"><span class="built_in">NSString</span> *documentsDirectory = [paths objectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSString</span> *filePDF = [documentsDirectory  stringByAppendingPathComponent:<span class="string">@"file.pdf"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种webview加载方式</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:_filePath];</span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line">[_webView loadRequest:request];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种webview加载方式</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:_filePath];</span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:_filePath];</span><br><span class="line">[_webView loadData:data MIMEType:<span class="string">@"application/pdf"</span> textEncodingName:<span class="string">@"UTF-8"</span> baseURL:url];</span><br></pre></td></tr></table></figure>

<p>失败！</p>
<p><strong>转而使用<code>Quartz 2D</code>绘制pdf</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="comment">//旋转坐标系</span></span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, <span class="keyword">self</span>.frame.size.height<span class="number">-60</span>);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">CGPDFPageRef</span> pdfPage = <span class="built_in">CGPDFDocumentGetPage</span>(_pdfDoc, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">CGContextSaveGState</span>(context);</span><br><span class="line">    <span class="built_in">CGAffineTransform</span> pdfTransform = <span class="built_in">CGPDFPageGetDrawingTransform</span>(pdfPage, kCGPDFCropBox, <span class="keyword">self</span>.bounds, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">CGContextConcatCTM</span>(context, pdfTransform);</span><br><span class="line">    <span class="built_in">CGContextDrawPDFPage</span>(context, pdfPage);</span><br><span class="line">    <span class="built_in">CGContextRestoreGState</span>(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>失败！甚至分割线都没了</p>
<p>这是最常用的两种读取pdf文件的方式，然而还是显示不出来发票上面的印章</p>
<p><strong>使用QLPreviewController预览</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入QuickLook库</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuickLook/QuickLook.h&gt;</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	QLPreviewController *previ = [[QLPreviewController alloc] init];</span><br><span class="line">	previ.view.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.view.width, <span class="keyword">self</span>.view.height - <span class="number">200</span>);</span><br><span class="line">	previ.delegate = <span class="keyword">self</span>;</span><br><span class="line">	previ.dataSource = <span class="keyword">self</span>;</span><br><span class="line">	[<span class="keyword">self</span>.view addSubview:previ.view];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现代理方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 在此代理处加载需要显示的文件</span></span><br><span class="line">- (<span class="built_in">NSURL</span> *)previewController:(QLPreviewController *)previewController previewItemAtIndex:(<span class="built_in">NSInteger</span>)idx</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:filePath];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 返回文件的个数</span></span><br><span class="line">-(<span class="built_in">NSInteger</span>)numberOfPreviewItemsInPreviewController:(QLPreviewController *)controller &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 即将要退出浏览文件时执行此方法</span></span><br><span class="line">-(<span class="keyword">void</span>)previewControllerWillDismiss:(QLPreviewController *)controller &#123;</span><br><span class="line">    XDLog(<span class="string">@"退出"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是失败的没显示出来印章。</p>
<p><strong>在github上找读取pdf的项目</strong></p>
<ul>
<li>UIImage-PDF 将pdf转成image显示，结果失败</li>
<li>Reader 比较著名的pdf阅读项目，支持大文件，加密文件，有着ibooks一样的界面。也有着iBooks一样的结果，同样显示不出来印章</li>
<li>PDFRenderer 结果失败</li>
<li>PDFTest 结果失败</li>
<li>PDFViewTest 结果失败<br>….</li>
</ul>
<p>然后各种谷歌、百度、必应搜索，终于搜到了一个有用的结果</p>
<p>原文如下 </p>
<blockquote><p>公司的项目要读取服务器发来的PDF文件，用网上的方法读取后虽然能读出来，但是发现个问题，PDF文件有的签章不见了。这个可是大问题，试了好多iOS框架库，例如 Reader,FastPdfKit都读不出来。</p>
<p>在知乎上找到一个大神的发言，解释了PDF有的内容读不出来的原因。iOS 对矢量图片的支持如何？ 直接引用其中的一段话:”iOS 的 Core Graphics 框架底层和 OS X 一样，都是基于 PDF 的。所以 iOS 用 PDF 很方便，比如 iOS 的 Quick Look 框架就可以直接看 PDF。如果要是只看文档那样简单的 PDF 的话，一般是没有什么问题的。不过，如果要是想看用 AI 制作的，带有多重描边、填充、网格渐变、阴影、多图层等东西的复杂 PDF 图形的话，有很大机率会出现问题。比如，在 iOS 和 OS X 上常出现的一个问题是，PDF 文稿里隐藏的图层、图形被显示出来。如果查看复杂一些的 PDF，很可能在 Adobe Illustrator、OS X、iOS、Adobe Reader 下查看的效果都不一样。所以说，PDF 虽然一般被认为是跨平台的「安全格式」，不过也并不是 100% 保险。 Adobe Reader 的 iOS 版很可能没有使用 iOS 系统自带的 PDF 和矢量绘图 API，而是自己实现了一个，因此通常 Adobe Reader 显示复杂一些的 PDF 比使用 iOS 原生 API 解析 PDF 的 App 更准确一些。还有， 无论是使用 iOS 原生的 Quick Look 还是用 Adobe Reader 查看，渲染复杂的 PDF 有可能特别慢”。公司PDF的签章好像就是多图层，在文字的底下。</p>
</blockquote>

<p><strong>找了好久，终于找到了一个能读取多图层的PDF文件的框架 - MuPDF</strong></p>
<p>得出一个结论，使用Mupdf</p>
<p><a href="https://github.com/muennich/mupdf" target="_blank" rel="noopener">Mupdf github地址</a></p>
<p><a href="http://www.jianshu.com/p/5fd00530d4bb" target="_blank" rel="noopener">使用方法</a></p>
<h2 id="处理git库不允许上传大于100M的文件"><a href="#处理git库不允许上传大于100M的文件" class="headerlink" title="处理git库不允许上传大于100M的文件"></a>处理git库不允许上传大于100M的文件</h2><p>git库在上传大于50M的文件时会有警告，文件大于100M时直接拒绝push。要将这个文件从本地库和远程库中移除掉，再进行push操作。比如百度地图的导航静态库<code>libbaiduNaviSDK.a</code>就有100多M，做push操作时，直接报错了。</p>
<blockquote><p>remote: warning: Large files detected.<br>remote: error: File gasstation/gasstation/Classes/Main/Lib/BaiduNaviSDK/libbaiduNaviSDK.a is 108.63 MB; this exceeds Git@OSC’s file size limit of 100 MB<br>remote: error: hook declined to update refs/heads/master</p>
</blockquote>

<p>如果这个文件是最近一次commit的，并没有进行push操作，换句话说进行push操作的时候报错了。那么需要删除掉本地库中这个文件的commit记录再进行push</p>
<p>在终端中cd进项目目录，就是项目的<code>.git</code>文件的目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Users/XXX(<span class="built_in">cd</span>后面路径换成自己项目的路径)</span><br></pre></td></tr></table></figure>

<p>输入如下命令</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git rm <span class="comment">--cached /Users/XXX/XXX/libbaiduNaviSDK.a (大文件的路径)</span></span><br><span class="line">git <span class="keyword">commit</span> <span class="comment">--amend -CHEAD</span></span><br></pre></td></tr></table></figure>

<p>到这一步这个大文件从commit记录中移除了，以后的commit也不会再commit它了。此时进行push即可</p>
<p>还有一种情况是你无数次commit了，也不知道哪次把这个大文件commit上了，在进行push的时候报错了。</p>
<p>这时需要将本地代码库回滚，回滚到某个commit之前</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard commit-id :回滚到commit-id，讲commit-id之后提交的commit都去除</span></span><br><span class="line"></span><br><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard HEAD~3：将最近3次的提交回滚</span></span><br></pre></td></tr></table></figure>

<h2 id="删除苹果开发者平台Developer里的App-ID"><a href="#删除苹果开发者平台Developer里的App-ID" class="headerlink" title="删除苹果开发者平台Developer里的App ID"></a>删除苹果开发者平台Developer里的App ID</h2><p>删除苹果开发者平台Developer里的某个AppID本来是很容易的事情，点击Edit -&gt; Delete -&gt; 警示框中红色Delete即可。但是真实情况却坑的一逼……</p>
<p>Developer中的AppID对应项目中的Bundle id，是一个app的唯一标识，包括在App Store中，在各大第三方开放平台中。一般为了保证唯一性，采用公司域名反写＋app项目名的方式命名。</p>
<p>我经历过替换开发者账号的事。事情是这样的：开发某款app在上线AppStore当天，甲方觉得提供商名字不好(因为是个人开发者账号，显示的是人名拼音)要求下架，重新提供开发者账号提交。甲方是上帝，您高兴就好，反正$99不用我掏腰包。就这样上架第一天我亲手点了下架按钮，</p>
<p>问题就来了，Bundle id被旧的开发者帐号占用了，新的没法用了，我不想为了换个开发者帐号把Bundle id改了，毕竟牵扯好几个第三方平台呢。那就删除原来账号的Bundle id，删除的时候有如下提醒：</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160928-0.png?raw=true" alt="img"></p>
<p>在App Store上使用了，不能删除。我只好去iTunes Connect里删除了app（<strong>注意：此为大坑</strong>），问题依旧，只能求助苹果开发者平台的客服人员。</p>
<p>打苹果开发者客服电话: 4006 701 855 <a href="https://developer.apple.com/contact/phone/cn/" target="_blank" rel="noopener">全球电话支持</a>。坑爹的是，苹果客服人员告诉我删除不了，开发者平台中的Bundle id在app构建版本之后，不能修改或删除的。即便是你用该Bundle id发布的应用下架删除了，该Bundle id也会随着该应用永沉大海。不能删！不能改！</p>
<p>客服告诉我最佳的解决办法是迁移应用。将原账号的应用迁移到新账号上，应用所用到的Bundle id也会随之迁移过去。但是我把iTunes Connect里的应用删除了，那就没办法迁移了。摆在我面前的有两条路，第一：重新用旧账号打包提交审核通过，迁移应用到新账号，第二：改Bundle id。苹果客服人员对我如是说，客服诚不欺我啊！</p>
<h2 id="NSUserDefaults存储数组或字典报错"><a href="#NSUserDefaults存储数组或字典报错" class="headerlink" title="NSUserDefaults存储数组或字典报错"></a>NSUserDefaults存储数组或字典报错</h2><p>用NSUserDefaults存储数组或字典的时候报错，程序崩溃了，报错内容如下：</p>
<blockquote>
<p>Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘Attempt to insert non-property list object {xxxxxxxxxx} for key defaultsKey’</p>
</blockquote>
<p>是因为要存的数组或字典对象里存在类似<code>&quot;name&quot; = &quot;&lt;null&gt;&quot;</code>这样的字段，这样的字段不能被解析，所以会报错。</p>
<p>解决办法是将<code>&quot;name&quot; = &quot;&lt;null&gt;&quot;</code>换成<code>&quot;name&quot; = &quot;&quot;</code>，这种替换最好是服务端来做，如果服务端没做的话，移动端处理也可以，处理方式如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:oldDict];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *keyStr <span class="keyword">in</span> dict.allKeys) &#123;</span><br><span class="line">   <span class="keyword">if</span> ([[dict objectForKey:keyStr] isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">       [dict setObject:<span class="string">@""</span> forKey:keyStr];</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       [dict setObject:[dict objectForKey:keyStr] forKey:keyStr];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">"newDict = %@"</span>, dict);</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Charles安装与使用</title>
    <url>/2016/11/04/charles/</url>
    <content><![CDATA[<p>Charles是常用的抓包工具，仿写app获取网络数据最有效的途径。</p>
<a id="more"></a>

<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161104-0.png?raw=true" alt="img"></p>
<p>Charles是付费软件，免费使用30天。超过30天还可以使用，只是每次启动会有10s的延迟，4.0.1版本每隔一段时间会弹出Charles介绍页5s，消失后可继续使用，超过30分钟会弹出警告闪退，重启后即可使用。还是给不付费用户留了条坎坷的活路。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161104-10.png?raw=true" alt="img"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>本文使用的是4.0.1版本，<a href="https://www.charlesproxy.com/download/" target="_blank" rel="noopener">Charles官网下载地址</a>，Charles支持Windows、Mac、Linux，找到对应系统下载安装即可。</p>
<h2 id="设置系统代理"><a href="#设置系统代理" class="headerlink" title="设置系统代理"></a>设置系统代理</h2><p>将Charles设置为系统代理服务器后才能完成抓包操作。安装完成后第一次启动，Charles会请求设置系统代理权限，输入系统登录密码授权。也可以勾选<code>菜单 -&gt; Proxy -&gt; macOS Proxy</code>设置为系统代理。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161104-1.png?raw=true" alt="img"></p>
<p>设置完成之后，点击网页，会有网络请求出现在Charles界面。这就是截取本地的网络访问，也可以截取其他设备上的网络访问，比如iPhone上的app数据抓包，需要进行下面的设置。</p>
<h2 id="钥匙串里信任根证书"><a href="#钥匙串里信任根证书" class="headerlink" title="钥匙串里信任根证书"></a>钥匙串里信任根证书</h2><p>点击<code>菜单 -&gt; Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate</code>，弹出钥匙串，也可以直接手动找到钥匙串打开。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161104-2.png?raw=true" alt="img"></p>
<p>发现钥匙串里Charles证书是不受信任的，选中证书，右键 -&gt; “显示简介”，点信任前的三角号，展开信任（默认收起来的），选择<code>始终信任</code>。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161104-3.png?raw=true" alt="img"></p>
<p>设置完成之后，Charles根证书成为受此账户信任。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161104-4.png?raw=true" alt="img"></p>
<h2 id="设置Charles配置"><a href="#设置Charles配置" class="headerlink" title="设置Charles配置"></a>设置Charles配置</h2><p>需要打开Charles的代理功能，点击<code>菜单 -&gt; Proxy -&gt; Proxy Settings</code>，写入代理端口<code>8888</code>，勾选<code>Enable transparent HTTP proxying</code>，点击OK，如下图所示。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161104-5.png?raw=true" alt="img"></p>
<h2 id="查看电脑ip，并在iPhone上设置http代理"><a href="#查看电脑ip，并在iPhone上设置http代理" class="headerlink" title="查看电脑ip，并在iPhone上设置http代理"></a>查看电脑ip，并在iPhone上设置http代理</h2><p>点击<code>菜单 -&gt; Help -&gt; Local IP Address</code>，可以显示当前电脑运行的ip地址。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161104-6.png?raw=true" alt="img"></p>
<p>在iPhone中<code>设置 -&gt; 无线局域网 -&gt; 连接无线网的详情键(ⓘ)</code>，将HTTP代理选择为<code>手动</code>，服务器输入刚才查看的电脑ip，端口输入刚才设置的<code>8888</code>。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161104-7.png?raw=true" alt="img"></p>
<p>打开iPhone上的app，Charles会出现连接请求，点击<code>Allow</code>完成连接即可。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161104-8.png?raw=true" alt="img"></p>
<p>这时浏览app便能截取app内http请求的数据，下图是访问猫眼app截取到的首页数据。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161104-9.png?raw=true" alt="img"></p>
<p>要截取手机上的https请求的数据，还需要在手机上安装证书。</p>
<h2 id="iPhone上安装证书，截取https数据"><a href="#iPhone上安装证书，截取https数据" class="headerlink" title="iPhone上安装证书，截取https数据"></a>iPhone上安装证书，截取https数据</h2><p>完成上文设置，iPhone中用Safari访问<a href="http://charlesproxy.com/getssl" target="_blank" rel="noopener">http://charlesproxy.com/getssl</a>，会自动跳转到证书安装页，点击右上角安装 -&gt; 输入手机密码 -&gt; 点击右上角安装，即可安装完成。</p>
<p>| <img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161104-11.png?raw=true" alt="img">| <img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161104-12.png?raw=true" alt="img">|</p>
<p>如果弹不出证书安装界面，可以Safari访问<a href="https://www.charlesproxy.com/documentation/additional/legacy-ssl-proxying/" target="_blank" rel="noopener">https://www.charlesproxy.com/documentation/additional/legacy-ssl-proxying/</a>，点击()前面的<code>here</code>即可。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161104-13.png?raw=true" alt="img"></p>
<p>安装完成之后即可对https请求做数据抓包。</p>
<h2 id="查看接口地址以及提交的参数"><a href="#查看接口地址以及提交的参数" class="headerlink" title="查看接口地址以及提交的参数"></a>查看接口地址以及提交的参数</h2><p>点击Charles工具栏上<code>笔</code>的按钮，会出现该条数据的接口地址和请求参数，下图是访问猫眼app的首页数据提交的接口地址和请求参数。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20161104-14.png?raw=true" alt="img"></p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>用Charles抓包app数据完毕，关闭Charles后，记得将手机的无线局域网上的http代理关闭，不然手机就连不上网了。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Charles</tag>
      </tags>
  </entry>
  <entry>
    <title>开发iMessage App</title>
    <url>/2016/09/23/imessageapp/</url>
    <content><![CDATA[<p>iOS10、Xcode8.0发布之后，AppStore上出现了一类新的app —— iMessage App</p>
<p>一些椭圆形的app图标在AppStore上格外另类，这些app都显示<code>仅用于iMessage</code>，还有一些传统的app显示<code>提供iMessage app</code>。</p>
<a id="more"></a>

<p>Apple为自己的软件帝国又开辟了一条新的道路。在社交软件如洪水泛滥的今天，不少人已经几乎忘记了短信这种功能的存在，短信功能的用途恐怕只剩下收验证码、收账单信息了。</p>
<p>Apple此举不知能不能重振短信息的昔日雄风。</p>
<h2 id="iMessage-AppStore"><a href="#iMessage-AppStore" class="headerlink" title="iMessage AppStore"></a>iMessage AppStore</h2><p>iMessage App存在于iOS的AppStore中，但是iMessage app有一个独立完整的AppStore，这个AppStore完全独立于iOS的AppStore，可以在Message（信息）中访问，只显示iMessage App。</p>
<h2 id="普通表情包"><a href="#普通表情包" class="headerlink" title="普通表情包"></a>普通表情包</h2><p>Xcode提供了<code>Sticker Pack Application</code>，这是一个创建表情包的模板，没有任何代码。</p>
<p>在Xcode中创建一个新的工程，选择iOS -&gt; Application -&gt; Sticker Pack Application</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160921-1.png?raw=true" alt="img"></p>
<p>创建完项目之后，发现只有一个Stickers.xcstickers，这里面有一个iMessage App Icon（app图标） 和 Sticker Pack（表情包）</p>
<p>找一些图片，直接拖动到Sticker Pack里面，我直接拖动的发过来的qq表情。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160921-2.png?raw=true" alt="img"></p>
<p>在Xcode的右边，Sticker Pack设置尺寸的地方，这里的三个尺寸是表情的默认大小，在程序运行的时候，表情分别以不同的方式排布。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160921-7.png?raw=true" alt="img"></p>
<p>拖完想要的表情，设置完尺寸之后，command + R运行程序。</p>
<table>
<thead>
<tr>
<th align="center">Small</th>
<th align="center">Medium</th>
<th align="center">Large</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160921-3.png?raw=true" alt="img"></td>
<td align="center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160921-4.png?raw=true" alt="img"></td>
<td align="center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160921-6.png?raw=true" alt="img"></td>
</tr>
</tbody></table>
<p>表情的三个尺寸<code>Small</code>、<code>Medium</code>、<code>Large</code>。apple对这三种尺寸并没有严格限制，只有一些建议的大小：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Small: <span class="number">100</span> x <span class="number">100</span> pt @<span class="number">3</span>x scale (<span class="number">300</span> x <span class="number">300</span> pixel image)</span><br><span class="line"><span class="number">2.</span> Medium: <span class="number">136</span> x <span class="number">136</span> pt @<span class="number">3</span>x scale (<span class="number">378</span> x <span class="number">378</span> pixel image)</span><br><span class="line"><span class="number">3.</span> Large: <span class="number">206</span> x <span class="number">206</span> pt @<span class="number">3</span>x scale (<span class="number">618</span> x <span class="number">618</span> pixel image)</span><br></pre></td></tr></table></figure>

<p>对于图片的大小也有一些限制：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 文件中images不可以大于<span class="number">500</span>kb;</span><br><span class="line"><span class="number">2.</span> iamge不可以小于<span class="number">100</span> x <span class="number">100</span> pt (<span class="number">300</span> x <span class="number">300</span> pixels).</span><br><span class="line"><span class="number">3.</span> iamge不可以大于<span class="number">206</span> x <span class="number">206</span> pt (<span class="number">618</span> x <span class="number">618</span> pixels).</span><br><span class="line"><span class="number">4.</span> 图片格式必须是 PNG, APNG, JPEG, GIF ;</span><br></pre></td></tr></table></figure>

<p>太大的图片可以放到Sticker Pack包里，也能启动运行到程序里，只是无法点击发布，可以找个大图试一下。</p>
<h2 id="动图表情包"><a href="#动图表情包" class="headerlink" title="动图表情包"></a>动图表情包</h2><p>图标格式支持GIF，创建动态表情包可以直接拖GIF图标。</p>
<p>另一种创建动态表情的方式是使用<code>Sticker Sequence</code>，序列存储帧动画的每一帧，组成一组动画。</p>
<p>在Sticker Pack空白处右键，Add Assets -&gt; New Sticker Sequence</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160921-5.png?raw=true" alt="img"></p>
<p>将帧动画的每一帧图片拖动到<code>Frame1</code>、<code>Frame2</code>….<code>FrameN</code>中。添加完毕之后，command + R运行程序即可</p>
<table>
<thead>
<tr>
<th align="center">添加帧图片</th>
<th align="center">运行结果 帧动画/GIF</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160921-8.png?raw=true" alt="img"></td>
<td align="center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160921-9.gif?raw=true" alt="img"></td>
</tr>
</tbody></table>
<p>用<code>Sticker Pack Application</code>可以快速创建一个用于iMessage的表情包，不需要写任何代码。</p>
<h2 id="iMessage-Application"><a href="#iMessage-Application" class="headerlink" title="iMessage Application"></a>iMessage Application</h2><p>这次创建项目要选择iMessage Application</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160921-9.png?raw=true" alt="img"></p>
<p>创建完项目之后会有一个<code>MessagesExtension</code>，这是最重要的文件夹，里面的存放着开发iMessage application的代码、storyboard、图片集合和一些配置信息。</p>
<p>command + R运行程序，会在message里看到在storyboard里默认的<code>Hello World</code>。</p>
<table>
<thead>
<tr>
<th align="center">MessagesExtension</th>
<th align="center">运行结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160921-10.png?raw=true" alt="img"></td>
<td align="center"><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160921-11.png?raw=true" alt="img"></td>
</tr>
</tbody></table>
<p>未完留坑，不会再填 :)</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iMessage</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native笔记1-第一个项目</title>
    <url>/2016/08/02/ReactNative2/</url>
    <content><![CDATA[<p><strong>第一个ReactNative是网络获取电影信息，用列表展示。如图oc中基本的tableview样式</strong></p>
<p><strong>项目源码请见<a href="https://github.com/mxdios/firstReactNative" target="_blank" rel="noopener">firstReactNative</a></strong></p>
<a id="more"></a>

<p>展示我的学写该项目的学习笔记，掺杂了一些我的个人理解，可能会更清楚一些。<a href="https://github.com/reactnativecn/react-native-docs-cn/blob/master/docs/0.28/sample-application-movies.md" target="_blank" rel="noopener">原文地址</a></p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>创建第一个项目，项目名字为<code>firstReactNative</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">react-<span class="keyword">native</span> <span class="keyword">init</span> firstReactNative</span><br></pre></td></tr></table></figure>

<p>用终端或Xcode运行该项目，具体步骤见<a href="https://github.com/mxdios/notebook/blob/master/ReactNative%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.md" target="_blank" rel="noopener">React Native准备工作</a></p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/image/rn1.png" alt="如图"></p>
<h2 id="引入组件"><a href="#引入组件" class="headerlink" title="引入组件"></a>引入组件</h2><p>创建完毕项目打开<code>index.ios.js</code>文件，文件上部有如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class="line">import &#123;</span><br><span class="line">  AppRegistry,</span><br><span class="line">  StyleSheet,</span><br><span class="line">  Text,</span><br><span class="line">  View</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是React Native中的一些组件，需要引入。项目中牵扯到图片展示，需要引入<code>Image</code>组件。</p>
<p>顾名思义第一个<code>import</code>是引入组件框架，第二个<code>import</code>是引入几个常用的组件。</p>
<p><code>AppRegistry</code> 是注册应用组件，应用只有注册之后才能正确渲染，应用只整体注册一次，并不是每个组件都注册，对应该文件最下面的注册应用操作</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">AppRegistry.registerComponent(<span class="string">'firstReactNative'</span>, <span class="function"><span class="params">()</span> =&gt;</span> firstReactNative);</span><br></pre></td></tr></table></figure>

<p><code>StyleSheet</code> 是样式创建组件，在<code>const styles = StyleSheet.create()</code>使用。</p>
<p><code>Text</code> <code>View</code> 是一些常用的控件组件，<code>Image</code>组件添加到这下面，注意要在<code>View</code>后面写<code>,</code>(最后一个后面的<code>,</code>可写可不写)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class="line">import &#123;</span><br><span class="line">  AppRegistry,</span><br><span class="line">  StyleSheet,</span><br><span class="line">  Text,</span><br><span class="line">  View,</span><br><span class="line">  Image,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建模拟数据"><a href="#创建模拟数据" class="headerlink" title="创建模拟数据"></a>创建模拟数据</h2><p>在任意位置添加变量数据<code>URLDATA</code> (不要在其他方法{}内添加)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> URLDATA = [</span><br><span class="line">	&#123;<span class="attr">title</span>: <span class="string">'标题'</span>, <span class="attr">year</span>: <span class="string">'2016'</span>, <span class="attr">posters</span>:&#123;<span class="attr">thumbnail</span>: <span class="string">'http://i.imgur.com/UePbdph.jpg'</span>&#125;&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>iOS9中http请求需要添加允许任意的请求方式，在<code>info.plist</code>里添加<code>App Transport Security Settings</code>在该字段下选择<code>Allow Arbitrary Loads</code>并设置为<code>YES</code>。原因见<a href="https://github.com/mxdios/notebook/blob/master/ios9%E7%9A%84%E9%80%82%E9%85%8D%E7%89%B9%E6%80%A7.md" target="_blank" rel="noopener">iOS9的适配特性</a></p>
<h2 id="修改组件"><a href="#修改组件" class="headerlink" title="修改组件"></a>修改组件</h2><h3 id="渲染组件"><a href="#渲染组件" class="headerlink" title="渲染组件"></a>渲染组件</h3><p>在<code>class firstReactNative extends Component {</code> 里面更改为如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">var</span> movie = URLDATA[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text &gt;&#123;movie.title&#125;&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Text&gt;&#123;movie.year&#125;&lt;/</span>Text&gt;</span><br><span class="line">        &lt;Image source = &#123;&#123;<span class="attr">uri</span>: movie.posters.thumbnail&#125;&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>movie</code>是拿到的模拟数据分别用<code>Text</code> <code>Image</code>渲染到屏幕上。<code>command + R</code>刷新模拟器运行程序。这时候还看不到图片，因为没有指定图片的宽高</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/image/rn2.png" alt="如图"></p>
<h3 id="设置组件样式"><a href="#设置组件样式" class="headerlink" title="设置组件样式"></a>设置组件样式</h3><p>把原有代码块<code>const styles = StyleSheet.create({});</code>删除掉</p>
<p>创建新的渲染样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> styles = StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    flex: <span class="number">1</span>,</span><br><span class="line">    justifyContent: <span class="string">'center'</span>,</span><br><span class="line">    alignItems: <span class="string">'center'</span>,</span><br><span class="line">    backgroundColor: <span class="string">'#F5FCFF'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  thumbnail: &#123;</span><br><span class="line">    width: <span class="number">53</span>,</span><br><span class="line">    height: <span class="number">81</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>并把图片的渲染样式<code>thumbnail</code>添加到组件<code>Image</code>上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Image </span><br><span class="line">	source = &#123;&#123;<span class="attr">uri</span>: movie.posters.thumbnail&#125;&#125;</span><br><span class="line">	style = &#123;styles.thumbnail&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p><code>command + R</code>刷新模拟器运行程序。</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/image/rn3.png" alt="如图"></p>
<h2 id="改变样式排版"><a href="#改变样式排版" class="headerlink" title="改变样式排版"></a>改变样式排版</h2><p>现在是文字在上图片在下的样式，需要调整样式，图片在左边，文字在右边。这是基本的tableview样式</p>
<p>在<code>styles</code>里添加几个样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rightContainer: &#123; <span class="comment">//存放文字view的样式</span></span><br><span class="line">	flex: <span class="number">1</span>, <span class="comment">//是让里面存放的元素具有相同的宽度，忽略存放内容。css样式属性。</span></span><br><span class="line">&#125;,</span><br><span class="line">title: &#123;<span class="comment">//标题样式</span></span><br><span class="line">	fontSize: <span class="number">20</span>,</span><br><span class="line">	marginBottom: <span class="number">8</span>,</span><br><span class="line">	textAlign: <span class="string">'center'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">year: &#123;<span class="comment">//简介样式</span></span><br><span class="line">	textAlign: <span class="string">'center'</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>修改<code>return ()</code>里面的代码，将新添加的样式添加到相应组件上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">  	&lt;Image </span><br><span class="line">      source = &#123;&#123;<span class="attr">uri</span>: movie.posters.thumbnail&#125;&#125;</span><br><span class="line">      style = &#123;styles.thumbnail&#125;</span><br><span class="line">     /&gt;</span><br><span class="line">    &lt;View style = &#123;styles.rightContainer&#125;&gt;</span><br><span class="line">    	&lt;Text style = &#123;styles.title&#125;&gt;&#123;movie.title&#125;&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">    	&lt;Text style = &#123;styles.year&#125;&gt;&#123;movie.year&#125;&lt;/</span>Text&gt;</span><br><span class="line">    &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>View&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>相比于之前代码，<code>&lt;Image /&gt;</code>代码块移动到了<code>&lt;Text&gt;</code>上面，因为image要在文字的左边，从上到下，从左到右渲染，如果还放在text的下面的话，会出现文字在左边，图片在右边的效果，请自行试验。</p>
<p>把<code>Text</code>用一个<code>&lt;View&gt;</code>组件包起来，并赋予样式<code>rightContainer</code>，里面有一个<code>flex: 1</code>属性，这个容器的属性宽度会自动变宽，不会因为内容多少而定，会把图片挤压到屏幕边缘</p>
<p>给文字分别添加<code>title</code> <code>year</code>样式，指定的文字的大小以及居中显示。 <code>marginBottom: 8,</code>是让<code>title</code>下面有8像素的距离。</p>
<p><code>command + R</code>刷新模拟器运行程序。</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/image/Simulator%20Screen%20Shot%202016%E5%B9%B47%E6%9C%8827%E6%97%A5%20%E4%B8%8A%E5%8D%889.34.57.png" alt="image"></p>
<p>至此，基本的单个样式已完成，如图定义完成tableview里单个cell的样式。下面开始获取网络真是数据，完成列表展示</p>
<h2 id="获取网络数据"><a href="#获取网络数据" class="headerlink" title="获取网络数据"></a>获取网络数据</h2><p>从<code>Rotten Tomatoes（美国影评网站烂番茄）</code>的api获取数据</p>
<p>在文件开头<code>import</code>的下面定义接口地址变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> REQUEST_URL = <span class="string">'https://raw.githubusercontent.com/facebook/react-native/master/docs/MoviesExample.json'</span>;</span><br></pre></td></tr></table></figure>

<p>把下面代码放到<code>render()</code>函数之前。在网络获取之前初始化一个null状态，根据<code>this.state.movies == null</code>判断数据是否抓取成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">	<span class="keyword">super</span>(props);</span><br><span class="line">	<span class="keyword">this</span>.state = &#123;</span><br><span class="line">		movies: <span class="literal">null</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">this</span>.fetchData = <span class="keyword">this</span>.fetchData.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加React组件生命周期方法<code>componentDidMount()</code>，在组件加载完毕之后执行，只执行一次，在这里进行数据请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">	<span class="keyword">this</span>.fetchData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写<code>fetchData()</code>函数，网络请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetchData() &#123;</span><br><span class="line">	fetch(REQUEST_URL)</span><br><span class="line">		.then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">		.then(<span class="function">(<span class="params">responseData</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.setState(&#123;</span><br><span class="line">				movies: responseData.movies,</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;)</span><br><span class="line">		.done();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改原来的render函数，修改样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.state.movies) &#123; <span class="comment">//如果没有数据 返回renderLoadingView()</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.renderLoadingView();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> movie = <span class="keyword">this</span>.state.movies[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.renderMovie(movie); <span class="comment">//有数据的时候，执行这个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现<code>renderLoadingView()</code>函数和<code>renderMovie()</code>函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">renderLoadingView() &#123;<span class="comment">//添加加载提示</span></span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		&lt;View style = &#123;styles.container&#125;&gt;</span><br><span class="line">			&lt;Text&gt;</span><br><span class="line">				正在加载电影数据...</span><br><span class="line">			&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">		&lt;/</span>View&gt;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line">renderMovie(movie) &#123;<span class="comment">//拿到网络获取的数据，添加到控件上</span></span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">  	&lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">  		&lt;Image </span><br><span class="line">      		source = &#123;&#123;<span class="attr">uri</span>: movie.posters.thumbnail&#125;&#125;</span><br><span class="line">      		style = &#123;styles.thumbnail&#125;</span><br><span class="line">     	/&gt;</span><br><span class="line">    	&lt;View style = &#123;styles.rightContainer&#125;&gt;</span><br><span class="line">    		&lt;Text style = &#123;styles.title&#125;&gt;&#123;movie.title&#125;&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">    		&lt;Text style = &#123;styles.year&#125;&gt;&#123;movie.year&#125;&lt;/</span>Text&gt;</span><br><span class="line">    	&lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">  	&lt;/</span>View&gt;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>command + R</code>刷新模拟器运行程序。这时候得到的数据是网络数据</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/image/Simulator%20Screen%20Shot%202016%E5%B9%B47%E6%9C%8827%E6%97%A5%20%E4%B8%8A%E5%8D%8810.34.16.png" alt="image"></p>
<h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><p><code>ListView</code>可以说是ReactNative里的<code>UITableView</code>，会安排视图的渲染，只渲染屏幕上显示的元素，渲染完毕被移出屏幕外的元素会被移除掉。</p>
<p>第一步引入<code>ListView</code>组件，跟上文中引入<code>Image</code>组件一样。</p>
<p>修改render函数，把返回一条数据的代码修改为渲染包含多个电影信息的<code>ListView</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.state.loaded) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.renderLoadingView();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		&lt;ListView </span><br><span class="line">			dataSource = &#123;<span class="keyword">this</span>.state.dataSource&#125;</span><br><span class="line">			renderRow = &#123;<span class="keyword">this</span>.renderMovie&#125;</span><br><span class="line">			style = &#123;styles.listView&#125;</span><br><span class="line">		/&gt;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>constructor(props)</code>代码，不再使用<code>this.state.movies</code>来存放数据，把数据存放到<code>dataSource</code>里面，可以根据布尔值<code>this.state.loaded</code>来判断是否加载完毕</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">	<span class="keyword">super</span>(props);</span><br><span class="line">	<span class="keyword">this</span>.state = &#123;</span><br><span class="line">		dataSource: <span class="keyword">new</span> ListView.DataSource(&#123;</span><br><span class="line">			rowHasChanged: <span class="function">(<span class="params">row1, row2</span>) =&gt;</span> row1 !== row2,</span><br><span class="line">		&#125;),</span><br><span class="line">		loaded: <span class="literal">false</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">this</span>.fetchData = <span class="keyword">this</span>.fetchData.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>fetchData</code>方法，把数据更新到dataSource</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetchData() &#123;</span><br><span class="line">	fetch(REQUEST_URL)</span><br><span class="line">		.then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">		.then(<span class="function">(<span class="params">responseData</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.setState(&#123;</span><br><span class="line">				dataSource: <span class="keyword">this</span>.state.dataSource.cloneWithRows(responseData.movies),</span><br><span class="line">				loaded: <span class="literal">true</span>,</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;)</span><br><span class="line">		.done();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加样式<code>listView</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">listView</span>: &#123;</span><br><span class="line">  	<span class="attribute">paddingTop</span>: <span class="number">20</span>,</span><br><span class="line">  	backgroundColor: <span class="string">'#F5FCFF'</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><code>command + R</code>刷新模拟器运行程序。达到我们最终要的结果</p>
<p><img src="http://oalg33nuc.bkt.clouddn.com/image/Simulator%20Screen%20Shot%202016%E5%B9%B47%E6%9C%8827%E6%97%A5%20%E4%B8%8A%E5%8D%8811.04.52.png" alt="image"></p>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native笔记1-准备工作</title>
    <url>/2016/08/01/ReactNative1/</url>
    <content><![CDATA[<h2 id="装环境"><a href="#装环境" class="headerlink" title="装环境"></a>装环境</h2><p>安装<code>Homebrew,</code>mac的套件管理器</p>
<a id="more"></a>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/ruby -e "$(curl -fsSL https:/</span><span class="regexp">/raw.githubusercontent.com/</span>Homebrew<span class="regexp">/install/m</span>aster<span class="regexp">/install)"</span></span><br></pre></td></tr></table></figure>
<p>安装<code>Node.js</code></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">brew install <span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure>

<p>安装<code>react-native-cli</code>。 React Native的命令行工具</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g react-<span class="keyword">native</span>-cli</span><br></pre></td></tr></table></figure>


<p>安装<code>Watchman</code>。Facebook提供的监视文件系统变更工具</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>watchman</span><br></pre></td></tr></table></figure>

<h2 id="创建React-Native项目"><a href="#创建React-Native项目" class="headerlink" title="创建React Native项目"></a>创建React Native项目</h2><p>定位的指定文件夹，创建React Native项目</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">react-<span class="keyword">native</span> <span class="keyword">init</span> firstReactNative</span><br></pre></td></tr></table></figure>

<p>终端内运行项目</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入到项目文件夹中</span></span><br><span class="line"><span class="keyword">cd</span> firstReactNative </span><br><span class="line"><span class="comment">//运行项目</span></span><br><span class="line">react-native <span class="keyword">run</span>-ios</span><br></pre></td></tr></table></figure>

<p>也可以在Xcode中点击<code>firstReactNative/ios/firstRectNative.xcodeproj</code>运行</p>
<h2 id="编写代码并运行"><a href="#编写代码并运行" class="headerlink" title="编写代码并运行"></a>编写代码并运行</h2><p>用编译器打开<code>index.ios.js</code>文件，修改相应代码</p>
<p>在iOS模拟器上<code>command + R</code>刷新运行app</p>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>Core Animation开发笔记</title>
    <url>/2016/07/27/coreanimation/</url>
    <content><![CDATA[<h2 id="CAlayer"><a href="#CAlayer" class="headerlink" title="CAlayer"></a>CAlayer</h2><ol>
<li><p>CALayer 和UIView类似，同样是一些被层级关系树管理的矩形块。包括图片、文本、背景色等。和UIView最大不同是 不能处理用户交互</p>
<a id="more"></a>
</li>
<li><p>CALayer添加图层，需求是在UIView上添加一个图层，处理方式不是添加一个UIView(这样当然可以实现)，是创建一个layer，这是layer的背景色，添加到View的layer上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIView *bgview &#x3D; [[UIView alloc] initWithFrame:CGRectMake(100, 100, 200, 200)];</span><br><span class="line">bgview.backgroundColor &#x3D; [UIColor grayColor];</span><br><span class="line">[self.view addSubview:bgview];</span><br><span class="line">    </span><br><span class="line">CALayer *layer &#x3D; [CALayer layer];</span><br><span class="line">layer.frame &#x3D; CGRectMake(30, 30, 100, 100);</span><br><span class="line">layer.backgroundColor &#x3D; [UIColor blueColor].CGColor;</span><br><span class="line">[bgview.layer addSublayer:layer];</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="layer的contents"><a href="#layer的contents" class="headerlink" title="layer的contents"></a>layer的contents</h2><ol>
<li><p>在UIView上显示一张图片。一般的处理方式是在view上添加一个UIImageView ，现在可以用layer的contents</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIView *bgview &#x3D; [[UIView alloc] initWithFrame:CGRectMake(100, 100, 200, 100)];</span><br><span class="line">  bgview.backgroundColor &#x3D; [UIColor grayColor];</span><br><span class="line">  [self.view addSubview:bgview];</span><br><span class="line"></span><br><span class="line">bgview.layer.contents &#x3D; (__bridge id _Nullable)([UIImage imageNamed:@&quot;Icon-Small-50&quot;].CGImage);</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么要用关键字 __bridge 修饰UIImage？ 因为，contents的类型是id，之所以被定义为id，是因为在MacOS系统上，这个属性对CGImage和NSImage都有作用。在iOS上，如果赋值UIImage，只能得到一个空白图层。其实真正赋值的是CGImageRef类型，它是指向CGImage结构的指针，.CGImage返回了“CGImageRef”，把它直接赋值给contents，会报编译错误，因为CGImageRef不是一个Cocoa对象，而是一个Core Foundation类型，所以要通过__bridge 修饰。（如果用的非arc则不需要）</p>
</li>
<li><p>这时image会根据bgview的大小形变缩放了。 在UIImageView里有一个contentMode的属性来设置image的缩放</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imageview.contentMode &#x3D; UIViewContentModeScaleAspectFit;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在layer里有 contentsGravity</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bgview.layer.contentsGravity &#x3D; kCAGravityResizeAspect;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="contentsScale"><a href="#contentsScale" class="headerlink" title="contentsScale"></a>contentsScale</h2><ol>
<li><p>这个属性很少用到。这个属性顶一个图片的像素尺寸和视图比例</p>
</li>
<li><p>举个例子，将图片设置为不能拉伸， kCAGravityCenter这个属性值，会将图设置为不拉伸，图有多大就显示多大，不会局限于view的大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bgview.layer.contentsGravity &#x3D; kCAGravityCenter;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片为@2x图片，这时图片会放大了，会有明显的颗粒点。因为这时每个点1个像素绘制了图片，retina屏幕是每个点绘制2个像素点。CGImage没有拉伸的概念，如果用UIImage去拉伸图片没有问题。在用CGImage时拉伸时会丢失，所以模糊了。这时需要用contentsScale来修复这个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bgview.layer.contentsScale &#x3D; image.scale;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;image.scale 在@2x时 &#x3D; 2， @1x时 &#x3D; 1</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="maskToBounds"><a href="#maskToBounds" class="headerlink" title="maskToBounds"></a>maskToBounds</h2><ol>
<li><p>图片超出view的范围要切掉。在UIView中用 clispToBounds ，在CALayer中 使用 maskToBounds</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bgview.layer.masksToBounds &#x3D; YES;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="contentsRect"><a href="#contentsRect" class="headerlink" title="contentsRect"></a>contentsRect</h2><ol>
<li><p>切割图片，设置添加到layer.contents上的图片的子域。就是只显示某一部分</p>
</li>
<li><p>contentsRect 的取值是相对值。相对于图片的尺寸。默认 {0,0,1,1}， 如果取值 {0, 0, 0.5, 0.5} 则显示图片的左上角整个图片的1/4处</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;显示图片的上面1&#x2F;2处</span><br><span class="line">bgview.layer.contentsRect &#x3D; CGRectMake(0, 0, 1, 0.5);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用场景：载入多张图拼合一起的整张图，切割了放在不同地方。单张大图比多张小图载入速度快。缺点就是某个小图尺寸改变时会很麻烦。</p>
</li>
<li><p>有一些软件可以生成拼合图片，并生成拼合坐标的xml或plist文件，并给每个拼合图层设置contentsRect。这样就方便多了。我也在找这个软件</p>
</li>
</ol>
<h2 id="contentsCenter"><a href="#contentsCenter" class="headerlink" title="contentsCenter"></a>contentsCenter</h2><ol>
<li><p>可拉伸区域, contentsCenter的值也是相对值，默认 {0,0,1,1}，图片将会均匀拉伸。contentsCenter可以指定拉伸区域</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bgview.layer.contentsCenter &#x3D; CGRectMake(0.25, 0.25, 0.5, 0.5);</span><br><span class="line">&#x2F;&#x2F;中间一部分可以拉伸</span><br></pre></td></tr></table></figure>
</li>
<li><p>类似UIImage的不形变拉伸方法，指定拉伸位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UIImage *)stretchableImageWithLeftCapWidth:(NSInteger)leftCapWidth topCapHeight:(NSInteger)topCapHeight</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="drawing"><a href="#drawing" class="headerlink" title="drawing"></a>drawing</h2><ol>
<li><p>自定义view的时候，会有-drawRect方法，在这里可以绘制。这个方法不会默认实现，如果用不到寄宿图的话，就不要创建这个方法。没有自定义的绘制任务时，不要写一个空的 -drawRect方法，会造成资源浪费</p>
</li>
<li><p>使用layer的代理方法，绘制寄宿图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALayer *layer &#x3D; [CALayer layer];</span><br><span class="line">layer.frame &#x3D; CGRectMake(30, 30, 100, 100);</span><br><span class="line">layer.backgroundColor &#x3D; [UIColor blueColor].CGColor;</span><br><span class="line">layer.delegate &#x3D; self;</span><br><span class="line">layer.contentsScale &#x3D; [UIScreen mainScreen].scale;</span><br><span class="line">[bgview.layer addSublayer:layer];</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 需要手动调用，因为CALayer不会自动重绘内容。</span><br><span class="line">[layer display];</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;代理方法</span><br><span class="line">- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx</span><br><span class="line">&#123;</span><br><span class="line">    CGContextSetLineWidth(ctx, 10);</span><br><span class="line">    CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);</span><br><span class="line">    CGContextStrokeEllipseInRect(ctx, layer.bounds);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 不会对超出layer存放边界以外的地方有绘制作用，所有超出的地方就像被切掉了一样，类似masksToBounds一样</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>animation</tag>
      </tags>
  </entry>
  <entry>
    <title>Python笔记5-模块</title>
    <url>/2016/07/05/Python5/</url>
    <content><![CDATA[<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>把代码放到不同的<code>.py</code>文件，一个<code>.py</code>文件是一个模块(Module)。有Python的内置模块和第三方模块。</p>
<a id="more"></a>

<p>不同模块间不必考虑函数名变量名冲突，因为不同模块间完全允许函数名变量名相同。注意不要与内置函数名冲突。</p>
<p>避免模块名冲突，引入目录来组织模块，称为包(Package)。</p>
<p><img src="https://github.com/mxdios/notebook/blob/master/notebooks/images/QQ20160816-0.png?raw=true" alt="img"></p>
<p>引入包，顶层包名不冲突，那么里面所有的模块都不会冲突。例如<code>hello.py</code>模块，引入包<code>PythonTest</code>中，模块名就变成了<code>PythonTest.hello</code>。</p>
<p>注意：每个包目录下面都有一个<code>__init__.py</code>文件，这个文件必须存在，不然这就是个普通目录，而不是一个包。<code>__init__.py</code>是空文件也可以写代码，他的模块名是<code>PythonTest</code>。</p>
<p>注意：创建模块命名时，不能与自带模块名称冲突。例如系统自带<code>sys</code>模块，自己的模块不能命名为<code>sys.py</code>，否则将无法导入系统自带<code>sys</code>模块。</p>
<p>如果有多层级的包结构，就一路<code>.</code>下去。</p>
<h2 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h2><p>Python有很多内置模块，安装完毕即可使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">'a test module'</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'MXD'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	args = sys.argv</span><br><span class="line">	<span class="keyword">if</span> len(args) == <span class="number">1</span>:</span><br><span class="line">		print(<span class="string">'hello world!'</span>)</span><br><span class="line">	<span class="keyword">elif</span> len(args) == <span class="number">2</span>:</span><br><span class="line">		print(<span class="string">'hello %s!'</span> % args[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		print(<span class="string">'end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	test()</span><br></pre></td></tr></table></figure>

<h3 id="标准模板"><a href="#标准模板" class="headerlink" title="标准模板"></a>标准模板</h3><p><code>#!/usr/bin/env python3</code> 标准注释，可以让这个模块文件直接在Unix/Linux/Mac上运行</p>
<p><code># -*- coding: utf-8 -*-</code> 标准注释，表示该文件使用标准UTF-8编码</p>
<p><code>&#39;a test module&#39;</code> 表示该模块的文档注释，任何模块代码的第一个字符串都会被视为模块的文档注释</p>
<p><code>__author__ = &#39;MXD&#39;</code> 作者</p>
<p>以上是Python模块的标准模板，不是强制必写，写总是没错的</p>
<h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><p>下面是代码部分</p>
<p><code>import sys</code> 导入<code>sys</code>模块。导入模块之后就可以用了，相当于有了变量<code>sys</code>指向该模块，利用这个变量可以访问<code>sys</code>模块中的所有功能。</p>
<p><code>sys</code>模块有一个<code>argv</code>变量，是用list存储了在命令行中输入的所有参数。例如在命令行中输入如如下第一行代码，这是运行<code>hello.py</code>模块，这时<code>argv</code>中存的就是<code>[&#39;hello.py&#39;]</code>。<code>argv</code>中至少有一个元素，因为第一个元素永远是该模块名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mxdMacBook-Pro-3:PythonTest inspiry$ python3 hello.py</span><br><span class="line">hello world!</span><br><span class="line">mxdMacBook-Pro-3:PythonTest inspiry$ python3 hello.py mxd</span><br><span class="line">hello mxd!</span><br><span class="line">mxdMacBook-Pro-3:PythonTest inspiry$ python3 hello.py mxd,xx</span><br><span class="line">hello mxd,xx!</span><br><span class="line">mxdMacBook-Pro-3:PythonTest inspiry$ python3 hello.py [&#39;a&#39;, &#39;adf&#39;]</span><br><span class="line">end</span><br><span class="line">mxdMacBook-Pro-3:PythonTest inspiry$ python3 hello.py mxd adf</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="最后两行代码的详细解释"><a href="#最后两行代码的详细解释" class="headerlink" title="最后两行代码的详细解释"></a>最后两行代码的详细解释</h3><p>注意最后的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	test()</span><br></pre></td></tr></table></figure>

<p>在命令行中运行<code>hello</code>模块文件时，Python解释器会把特殊变量<code>__name__</code>置为<code>__main__</code>，如果在其他地方导入该    <code>hello</code>模块时，<code>if</code>判断将失败。这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外代码，最常见的就是运行测试。</p>
<p>下面详细记录我对这两行代码的作用理解。</p>
<p>注释掉这两行代码，再在终端上执行<code>python3 hello.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mxdMacBook-Pro<span class="number">-3</span>:PythonTest inspiry$ python3 hello.py</span><br><span class="line">mxdMacBook-Pro<span class="number">-3</span>:PythonTest inspiry$</span><br></pre></td></tr></table></figure>

<p>不会有任何结果返回。</p>
<p>因为在终端执行该模块，该模块中只定义了一个<code>test</code>函数，并没有调用操作。如果这时放开<code>test()</code>这一行代码，调用该函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mxdMacBook-Pro<span class="number">-3</span>:PythonTest inspiry$ python3 hello.py</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<p>调用成功！</p>
<p>但是，在启动Python交互环境的时候，导入该模块时，也会调用该函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mxdMacBook-Pro<span class="number">-3</span>:PythonTest inspiry$ python3</span><br><span class="line">Python <span class="number">3.5</span><span class="number">.2</span> (v3<span class="number">.5</span><span class="number">.2</span>:<span class="number">4</span>def2a2901a5, Jun <span class="number">26</span> <span class="number">2016</span>, <span class="number">10</span>:<span class="number">47</span>:<span class="number">25</span>) </span><br><span class="line">[GCC <span class="number">4.2</span><span class="number">.1</span> (Apple Inc. build <span class="number">5666</span>) (dot <span class="number">3</span>)] on darwin</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> hello</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<p>这就非我所愿了，我们想要的是我在调用模块的时候返回执行结果，我导入模块的时候不能调用函数。这就用到了注释掉的判断条件<code>if __name__ == &#39;__main__&#39;:</code></p>
<p>放开这行注释的判断条件，在Python交互环境下的执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mxdMacBook-Pro<span class="number">-3</span>:PythonTest inspiry$ python3</span><br><span class="line">Python <span class="number">3.5</span><span class="number">.2</span> (v3<span class="number">.5</span><span class="number">.2</span>:<span class="number">4</span>def2a2901a5, Jun <span class="number">26</span> <span class="number">2016</span>, <span class="number">10</span>:<span class="number">47</span>:<span class="number">25</span>) </span><br><span class="line">[GCC <span class="number">4.2</span><span class="number">.1</span> (Apple Inc. build <span class="number">5666</span>) (dot <span class="number">3</span>)] on darwin</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> hello</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello.test()</span><br><span class="line">hello world!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>还是上文的解释：<strong>在命令行中运行模块文件时，Python解释器会把特殊变量<code>__name__</code>置为<code>__main__</code>，而在导入模块时则不会有这种改变。</strong></p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>正常的函数和变量名是公开的(public)，可以被直接引用，比如<code>abc</code>, <code>m322</code>等；</p>
<p>双下划线开头双下划线结尾的变量<code>__xxx__</code>是特殊变量，有特殊用途，自定义变量不要用这种变量名;</p>
<p>单下划线或双下划线开头无下划线结尾的函数或变量名是非公开的(private),不应该被直接引用，比如<code>_abc</code>, <code>__xyz</code>;</p>
<p>只是”不应该”被直接引用，并不是”不能”被直接引用。Python并没有一种方法能完全限制访问非公开变量或函数。只是编程习惯上不应该这么引用。</p>
<p>使用案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_abc</span><span class="params">(name)</span>:</span></span><br><span class="line">	print(<span class="string">'hello %s'</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_xyz</span><span class="params">(name)</span>:</span></span><br><span class="line">	print(<span class="string">'biu %s'</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(name)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> len(name) &gt; <span class="number">3</span>:</span><br><span class="line">		<span class="keyword">return</span> _abc(name)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> _xyz(name)</span><br></pre></td></tr></table></figure>

<p>这是一个自定义模块，<code>test</code>函数是公开的函数，<code>_abc</code>和<code>_xyz</code>函数是内部函数实现，不需要调用。在调用的时候只需要调用公开的<code>test</code>函数即可，不需要关心内部实现细节。调用结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello.test(<span class="string">'aa'</span>)</span><br><span class="line">biu aa</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello.test(<span class="string">'aaaa'</span>)</span><br><span class="line">hello aaaa</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>这是一种非常有用的代码封装和抽象方法，外部不需要引用的函数全部定义为未公开的(private)，只有外部需要引用的函数才定义为<code>public</code>。</p>
<p>当然，坚持调用<code>_abc</code>函数也是可以的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello._abc(<span class="string">'aaaa'</span>)</span><br><span class="line">hello aaaa</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>只是不建议这么做。</p>
<h2 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h2><p>安装第三方模块，需要通过包管理工具<code>pip</code>完成。Mac或Linux不需要手动安装<code>pip</code>，Mac或Linux上可能并存Python3.x和Python2.x版本，对应的pip命令是<code>pip3</code></p>
<p>安装第三方库<code>Python Imaging Library</code>，这是Python下的图像处理工具库，目前<code>PIL</code>只支持到Python2.7，并且很久没更新。基于PIL的Pillow项目非常活跃，支持Python3.</p>
<p>安装Pillow</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install Pillow</span><br></pre></td></tr></table></figure>

<p>安装完成后，使用Pillow生成图片缩略图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im = Image.open(<span class="string">'img.png'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(im.format, im.size, im.mode)</span><br><span class="line">PNG (<span class="number">1920</span>, <span class="number">2172</span>) RGBA</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im.thumbnail((<span class="number">100</span>,<span class="number">200</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im.save(<span class="string">'newimg.jpg'</span>, <span class="string">'JPEG'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>其他常用的第三方库还有MySQL的驱动：<code>mysql-connector-python</code>，用于科学计算的NumPy库：<code>numpy</code>，用于生成文本的模板工具<code>Jinja2</code>，等等。</p>
<h2 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h2><p>在加载模块时，Python会在指定路径下找.py文件，找不到就报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mymod</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ImportError: No module named <span class="string">'mymod'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>显示搜索路径，搜索路径存放在<code>sys.path</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">''</span>, <span class="string">'/Library/Frameworks/Python.framework/Versions/3.5/lib/python35.zip'</span>, <span class="string">'/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5'</span>, <span class="string">'/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/plat-darwin'</span>, <span class="string">'/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/lib-dynload'</span>, <span class="string">'/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages'</span>]</span><br></pre></td></tr></table></figure>

<p>添加搜索路径，可以直接在运行时修改<code>sys.path</code>，运行关闭后失效</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path.append(<span class="string">'/Users/inspiry/desktop/work/PythonCode/PythonTest/hello'</span>)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python笔记4-函数式编程</title>
    <url>/2016/07/04/Python4/</url>
    <content><![CDATA[<p><em>Python不是纯函数式编程语言</em></p>
<a id="more"></a>

<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><h2 id="变量与函数名"><a href="#变量与函数名" class="headerlink" title="变量与函数名"></a>变量与函数名</h2><p>可以用一个变量指向一个函数名，而代替这个函数的操作。也可以说函数本身可以赋值给变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-10</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs</span><br><span class="line">&lt;built-<span class="keyword">in</span> function abs&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = abs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b(<span class="number">-29</span>)</span><br><span class="line"><span class="number">29</span></span><br></pre></td></tr></table></figure>

<p>其实函数名本身也是一个变量，是指向函数的变量。下面的代码可以验证这个结论</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-10</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">aa</span><span class="params">(num)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(num + <span class="number">100</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aa(<span class="number">10</span>)</span><br><span class="line"><span class="number">110</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs = aa</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">10</span>)</span><br><span class="line"><span class="number">110</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-10</span>)</span><br><span class="line"><span class="number">90</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><code>abs()</code>是系统提供的求绝对值得函数，我自定义了一个函数<code>aa()</code>，让输入的数+100然后打印出来，然后把<code>aa</code>函数名赋值给<code>abs</code>，然后系统的求绝对值的函数就变成了打印+100操作的函数了。</p>
<p>要恢复<code>abs()</code>的函数功能，要重启Python交互环境 <code>exit()</code>  -&gt; <code>python</code></p>
<hr>
<p>函数名可以赋值给变量，函数名本身也是个指向函数的变量。函数可以接受变量为参数，那么函数也可以作为参数传给另一个函数。</p>
<p>这句绕口令的意思是：函数可以作为另一个函数的参数，这种函数称为<code>高阶函数</code>。</p>
<p>自定义函数<code>addnum(x,y,z)</code>包含了三个参数，其中参数<code>z</code>是传入的是一个函数名，在<code>addnum</code>函数内<code>z,y</code>变为函数<code>z</code>的参数，执行完函数<code>z</code>操作，把结果相加打印出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">addnum</span><span class="params">(x,y,z)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(z(x) + z(y))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>addnum(<span class="number">-10</span>, <span class="number">10</span>, abs)</span><br><span class="line"><span class="number">20</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p><code>map()</code>函数传入两个参数，第一个参数是一个函数，第二个参数是一个可迭代对象<code>Iterable</code>，函数将作用于序列的每一个元素，把结果作为<code>生成器Iterator</code>返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">st</span><span class="params">(s)</span>:</span>						<span class="comment">#自定义函数st</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> s + a</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>st(<span class="string">'a'</span>)							<span class="comment">#结果是把传入的字符串拼接一个a'字符</span></span><br><span class="line"><span class="string">'aa'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = map(st, <span class="string">'12345'</span>)			<span class="comment">#调用map函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;map object at <span class="number">0x101517320</span>&gt;			<span class="comment">#返回一个Iterator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(a)</span><br><span class="line">[<span class="string">'1a'</span>, <span class="string">'2a'</span>, <span class="string">'3a'</span>, <span class="string">'4a'</span>, <span class="string">'5a'</span>]		<span class="comment">#转为list</span></span><br></pre></td></tr></table></figure>

<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h2><p><code>reduce()</code>函数也接受两个参数，第一个是有两个参数的函数，第二个参数是可迭代对象<code>Iterable</code>，两个元素作为参数作用于函数，结果和第三个元素作为参数作用于函数，依次运行下去，最后return结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reduce(fun, [x, y, z, m, n]) = fun(fun(fun(fun(x, y) z) m) n)</span><br></pre></td></tr></table></figure>

<h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><p><code>filter()</code>函数用于筛选过滤序列。操作方式类似<code>map()</code>，只是传入的函数返回值是<code>bool</code>类型，如果是<code>True</code>则保留该元素，如果是<code>False</code>则清除该元素，最后剩下的list作为<code>Iterator</code>返回</p>
<p>自定义函数，传入整数，偶数返回<code>True</code>，奇数返回<code>False</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(test, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]))</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]    <span class="comment">#只保留了偶数</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h2><p><code>sorted()</code>是排序算法的高阶函数，可以对list进行排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">-23</span>,<span class="number">33</span>])</span><br><span class="line">[<span class="number">-23</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">33</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>也可以对字符串的list进行排序，是根据ASCII码排序的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'a'</span>, <span class="string">'B'</span>, <span class="string">'Za'</span>, <span class="string">'Zb'</span>])</span><br><span class="line">[<span class="string">'B'</span>, <span class="string">'Za'</span>, <span class="string">'Zb'</span>, <span class="string">'a'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>还可以接收一个参数<code>key</code>函数，来实现自定义排序，比如按照绝对值大小排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">-23</span>], key = abs)</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">-23</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>这种实现原理是：key指向的函数作用于list里的每一个元素得到结果，把结果进行排序得到一个新list，命名为：newList，然后将原list按照这个newList里每个元素的对应关系返回相应的元素，实现排序</p>
<p>上文说到，默认的字符串排序是按照ASCII码排序的，大写字母的ASSCII码值要小于小写字母的ASSCII码值，所以<code>&#39;A&#39;</code>要排在<code>&#39;a&#39;</code>前面。如果要实现按照字母表顺序呢？其实只要忽略每个字符串的大小写就OK</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'a'</span>, <span class="string">'B'</span>, <span class="string">'Za'</span>, <span class="string">'Zb'</span>], key = str.lower)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'B'</span>, <span class="string">'Za'</span>, <span class="string">'Zb'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>要实现反向排序，只需要加入第三个参数<code>reverse = True</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'a'</span>, <span class="string">'B'</span>, <span class="string">'Za'</span>, <span class="string">'Zb'</span>], key = str.lower, reverse = <span class="literal">True</span>)</span><br><span class="line">[<span class="string">'Zb'</span>, <span class="string">'Za'</span>, <span class="string">'B'</span>, <span class="string">'a'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h1 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h1><h2 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h2><p>函数既然可以作为参数传递到函数中，自然也可以作为返回值被函数<code>return</code>出来。</p>
<p>定义一个求平方的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a * a</span><br></pre></td></tr></table></figure>

<p>将该函数作为返回值放到另一个函数<code>testTest()</code>中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testTest</span><span class="params">(b)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">		<span class="keyword">return</span> b * b</span><br><span class="line">	<span class="keyword">return</span> test</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>w = testTest(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w()</span><br><span class="line"><span class="number">100</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>在调用<code>testTest()</code>的时候，每次调用都是返回一个全新的函数。即便是传入相同的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>w = testTest(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = testTest(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>w == z</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>外部函数<code>testTest()</code>包含了内部函数<code>test()</code>，内部函数<code>test()</code>引用了外部函数变量。调用外部函数，在返回函数的时候，包括函数的相关参数都一起返回了。这种程序结构被称为<code>闭包</code>。</p>
<p>还有一个注意点，调用外部函数，返回的函数并没有立即执行，只有在调用的时候才会执行。返回的函数不要引用任何可能会变化的变量。</p>
<p>下面一个例子说明返回函数没有立即执行，和返回函数引用会变化的变量引发的问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">	array = []</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">fs</span><span class="params">()</span>:</span></span><br><span class="line">			<span class="keyword">return</span> x</span><br><span class="line">		array.append(fs)</span><br><span class="line">	<span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>

<p>定义函数<code>test1()</code>，函数内包含了一个循环，循环的<code>x</code>是一个变化的变量，内部函数<code>fs()</code>引用了外部这个可变化的变量<code>x</code>。每次循环生成一个<code>fs()</code>函数，存放到<code>array</code>数组中，最后返回<code>array</code>数组，里面放了四个<code>fs</code>函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1, f2, f3, f4 = test1()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f4()</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>最后的结果不是<code>1</code>,<code>2</code>,<code>3</code>,<code>4</code>，而全部都是<code>4</code></p>
<p>该函数的运行原理是：调用<code>test1()</code>，执行函数内的<code>for</code>循环，每一次循环都生成一个<code>fs()</code>内部函数，每个内部函数都互不干扰，但是每个函数都引用的外部函数的<code>x</code>，最后<code>for</code>循环执行完毕，返回了存放函数的数组。这时里面的函数没有任何一个执行了，但是此时的<code>x</code>早已变为<code>4</code>了。拿到四个函数<code>f1</code> <code>f2</code> <code>f3</code> <code>f4</code>运行，所以全部返回<code>4</code>。</p>
<p>所以说谨记一点：<strong>返回函数不要引用任何可变化的变量</strong></p>
<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>匿名函数就是没有写函数名的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list(map(<span class="keyword">lambda</span> x: x + x, [<span class="number">10</span>,<span class="number">22</span>,<span class="number">4</span>,<span class="number">21</span>]))</span><br><span class="line">[<span class="number">20</span>, <span class="number">44</span>, <span class="number">8</span>, <span class="number">42</span>]</span><br></pre></td></tr></table></figure>

<p>这里面<code>lambda x: x + x</code>就是匿名函数，<code>lambda</code>是表示匿名函数的关键字，<code>:</code>前是参数，后表达式。匿名函数只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p>
<p>匿名函数也是函数，所以也可以赋值给变量，作为参数传入函数或被函数返回。</p>
<p>但是，<em>Python对匿名函数支持有限，只有一些简单情况下可以用匿名参数</em></p>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>不更改函数的情况下，动态增加函数功能的方式，称为<code>装饰器(Decoratot)</code></p>
<p>函数的<code>__name__</code>属性可以获得函数名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test()</span><br><span class="line">helloworld</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = test</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a()</span><br><span class="line">helloworld</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.__name__</span><br><span class="line"><span class="string">'test'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>装饰器是一个返回函数的高阶函数。</p>
<p>自定义函数，打印hello world：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">print</span> (<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>
<p>如何在不改动该函数的前提下，打印出调用该函数的函数名？这就使用到了<code>装饰器</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inputTest</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inputFunc</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">		print(<span class="string">'调用函数 %s():'</span> % func.__name__)</span><br><span class="line">		<span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">	<span class="keyword">return</span> inputFunc</span><br></pre></td></tr></table></figure>
<p>上面代码就是一个打印日志的装饰器，<code>inputTest</code>函数，传入了一个函数<code>func</code>，返回了函数<code>inputFunc</code>。函数内自定义的函数<code>inputFunc</code>实现了打印传入函数<code>func</code>的函数名，并执行传入函数。</p>
<p>如何将这个装饰器作用于<code>test</code>函数？使用Python的<code>@</code>语法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@inputTest</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">print</span> (<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>
<p>将<code>@inputTest</code>放到<code>test()</code>函数定义上面，相当于执行了<code>test = inputTest(test)</code></p>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test()</span><br><span class="line">调用函数 test():</span><br><span class="line">hello world</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>装饰器本身如果需要加入参数，就需要编写一个返回装饰器的高阶函数。例如打印log需要自定义文本+函数名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inputTest</span><span class="params">(func)</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">inputFunc</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">			print(<span class="string">'%s %s():'</span> % (text, func.__name__))</span><br><span class="line">			<span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">		<span class="keyword">return</span> inputFunc</span><br><span class="line">	<span class="keyword">return</span> inputTest</span><br><span class="line"></span><br><span class="line"><span class="meta">@log('你好')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">print</span> (<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test()</span><br><span class="line">你好 test():</span><br><span class="line">hello world</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h1 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h1><p>Python的<code>functools</code>模块提供了很多功能，其中一种就是偏函数(Partial function)。</p>
<p>之前说的函数的<a href="https://github.com/mxdios/notebook/blob/master/notebooks/Python%E5%87%BD%E6%95%B0.md#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">默认参数</a>，指定某一函数的默认值，降低函数调用难度。偏函数也可以做到</p>
<p>函数<code>int()</code>可以吧字符串转换为整数，默认按照十进制转换。该函数还有一个额外参数<code>base</code>，可以指定按照某进制转换。注：<code>int(&#39;2323232&#39;, base = 8)</code>是指字符串是八进制数据字符串，转为十进制整数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'2323232'</span>) <span class="comment"># 十进制转换十进制</span></span><br><span class="line"><span class="number">2323232</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'2323232'</span>, base = <span class="number">8</span>) <span class="comment"># 八进制转换十进制</span></span><br><span class="line"><span class="number">632474</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'2323232'</span>, base = <span class="number">16</span>) <span class="comment"># 十六进制转换十进制</span></span><br><span class="line"><span class="number">36844082</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>需要大量转换二进制字符串时，每次传入<code>int(x, base = 2)</code>太麻烦，自定义函数<code>int2()</code>，转换二进制字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">int2</span><span class="params">(x, base = <span class="number">2</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> int(x, base)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1001001'</span>) <span class="comment"># 不传base默认按照二进制转换</span></span><br><span class="line"><span class="number">73</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1001001'</span>, base = <span class="number">8</span>)</span><br><span class="line"><span class="number">262657</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'100110'</span>, base = <span class="number">10</span>)</span><br><span class="line"><span class="number">100110</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>上述是基本做法，可以创建偏函数实现上述需求，不需要自定义函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(int, base = <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'100111'</span>)</span><br><span class="line"><span class="number">39</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1001'</span>, base = <span class="number">10</span>)</span><br><span class="line"><span class="number">1001</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><code>functools.partial</code>是将函数的某个参数给定一个默认值，返回新的函数。<code>int2 = functools.partial(int, base = 2)</code>就是指定<code>int()</code>函数中<code>base</code>参数的默认值是<code>2</code>并返回新的函数。</p>
<p>创建偏函数时，实际上可以接收函数对象、<code>*args</code> 和 <code>**kw</code> 三个参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>max2 = functools.partial(max, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>max2(<span class="number">3</span>,<span class="number">9</span>)  <span class="comment"># 相当于 max(10, 3, 9)</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>当函数参数太多时，需要简化，可以使用<code>functools.partial</code>创建一个偏函数。可以固定原函数的部分参数，调用起来更简单。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python笔记3-高级特性</title>
    <url>/2016/07/03/Python3/</url>
    <content><![CDATA[<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片就是切割list或者tuple里面的元素，获取某个或某段元素。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">1</span>]</span><br><span class="line">[<span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">2</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'c'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><code>L[a:b]</code> 表示返回从第<code>a</code>个元素到第<code>b</code>个元素，不包含第<code>b</code>个元素。 如果索引为<code>0</code>的话可以省略。</p>
<p>同样支持倒数切片，倒数第一个元素是的索引是<code>-1</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:<span class="number">-1</span>]</span><br><span class="line">[<span class="string">'d'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-1</span>:]</span><br><span class="line">[<span class="string">'e'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-4</span>:<span class="number">-1</span>]</span><br><span class="line">[<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>切片操作不仅可以切割相邻的元素，还可以分段切割</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[::<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">1</span>:<span class="number">3</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><code>L[a:b:c]</code> 表示返回从第<code>a</code>个元素到第<code>b</code>个元素(不包含第<code>b</code>个元素),每<code>c</code>个元素取一个。</p>
<p>同样对tuple也支持，只是返回的结果格式还是tuple</p>
<p>对字符串也同样适用，返回的还是字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">'123456789'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="string">'234'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str[::<span class="number">3</span>]</span><br><span class="line"><span class="string">'147'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>切片是一种很高能的操作。能随意截取list、tuple甚至字符串，相比于oc截取字符串的某一段，Python这种切片操作简单极了</p>
<h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>用<code>for</code>循环来遍历一个可遍历对象称为迭代</p>
<p>可遍历对象: list、 tuple、 dict、 set、str…</p>
<h2 id="迭代list"><a href="#迭代list" class="headerlink" title="迭代list"></a>迭代list</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> a <span class="keyword">in</span> l:</span><br><span class="line"><span class="meta">... </span>    print(a)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="迭代tuple"><a href="#迭代tuple" class="headerlink" title="迭代tuple"></a>迭代tuple</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> a <span class="keyword">in</span> tup:</span><br><span class="line"><span class="meta">... </span>    print(a)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="迭代dict"><a href="#迭代dict" class="headerlink" title="迭代dict"></a>迭代dict</h2><p>dict是key-value存储的，默认迭代的是key， 若想迭代value需要<code>.values()</code>, 若想同事迭代key-value 需要<code>.items()</code>。</p>
<p>dict的存储顺序是无序的，迭代结果的顺序并不一定按照顺序排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict = &#123;<span class="number">1</span>:<span class="string">'a'</span>, <span class="number">2</span>:<span class="string">'b'</span>, <span class="number">3</span>:<span class="string">'c'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> d <span class="keyword">in</span> dict:					<span class="comment">#默认迭代key</span></span><br><span class="line"><span class="meta">... </span>    print(d)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> d <span class="keyword">in</span> dict.values():       <span class="comment">#迭代value</span></span><br><span class="line"><span class="meta">... </span>    print(d)</span><br><span class="line">...</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> dict.items():		<span class="comment">#迭代key-value</span></span><br><span class="line"><span class="meta">... </span>    print(k, v)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> a</span><br><span class="line"><span class="number">2</span> b</span><br><span class="line"><span class="number">3</span> c</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="迭代set"><a href="#迭代set" class="headerlink" title="迭代set"></a>迭代set</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sets = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sets</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k <span class="keyword">in</span> sets:</span><br><span class="line"><span class="meta">... </span>    print(k)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="迭代str"><a href="#迭代str" class="headerlink" title="迭代str"></a>迭代str</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> s <span class="keyword">in</span> str:</span><br><span class="line"><span class="meta">... </span>    print(s)</span><br><span class="line">...</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="带索引的list迭代"><a href="#带索引的list迭代" class="headerlink" title="带索引的list迭代"></a>带索引的list迭代</h2><p>迭代一个list，还需要显示list的索引。在Java或oc中有<code>for(int i = 0; i &lt; list.count; i ++)</code>这样的for循环，打印i就是list的索引。 在Python中有<code>enumerate()</code>函数，能拿到list的索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, s <span class="keyword">in</span> enumerate(l):</span><br><span class="line"><span class="meta">... </span>    print(i, s)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> a</span><br><span class="line"><span class="number">1</span> b</span><br><span class="line"><span class="number">2</span> c</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="多个迭代变量"><a href="#多个迭代变量" class="headerlink" title="多个迭代变量"></a>多个迭代变量</h2><p>迭代时两个变量，比如一个list里面放了tuple <code>[(1,2),(3,4),(5,6)]</code> 可以引入两个迭代变量，遍历内容。 注意点是tuple的元素个数必须固定，跟给定的迭代变量参数个数相同，否则会报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> a, b <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">6</span>)]</span><br><span class="line">	print(a, b)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h2 id="判断对象是否可迭代"><a href="#判断对象是否可迭代" class="headerlink" title="判断对象是否可迭代"></a>判断对象是否可迭代</h2><p>引入<code>collections</code>模块的<code>Iterable</code>做类型判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">10</span>, Iterable)   <span class="comment">#整数不可迭代</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">10.4</span>, Iterable)   <span class="comment">#浮点型不可迭代</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">10</span>,<span class="number">11</span>], Iterable)  <span class="comment">#list可以迭代</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;<span class="number">10</span>:<span class="string">'a'</span>,<span class="number">11</span>:<span class="string">'b'</span>&#125;, Iterable)   <span class="comment">#dict可以迭代</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;<span class="number">10</span>,<span class="number">11</span>&#125;, Iterable)   <span class="comment">#set可迭代</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h1 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h1><p><code>List Comprehensions</code>列表生成式，用简单的代码生成复杂的list</p>
<p>生成<code>[1,2,3,4]</code> 使用<code>list(range(1,5))</code>，x从<code>1</code>到<code>5</code>不包括<code>5</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">1</span>,<span class="number">5</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="普通列表生成式"><a href="#普通列表生成式" class="headerlink" title="普通列表生成式"></a>普通列表生成式</h2><p>如果要生成<code>[1*1, 2*2, 3*3, 4*4, 5*5]</code>的list的话怎么生成呢？ 可以用for循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>    l.append(x * x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br></pre></td></tr></table></figure>

<p>如果要用列表生成式的话，只需要一行代码就能搞定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>列表生成式<code>[x * x for x in range(1,5)]</code>可以这样理解：<code>for</code>循环是生成元素的，<code>for</code>循环生成的元素放到前面结果元素计算式<code>x * x</code>中计算得到最终结果，结果本身就在<code>[]</code>中，不需要<code>append</code>了。</p>
<h2 id="带筛选条件的列表生成式"><a href="#带筛选条件的列表生成式" class="headerlink" title="带筛选条件的列表生成式"></a>带筛选条件的列表生成式</h2><p>列表生成式还可以增加筛选条，比如，生成1-10(包括10)中所有偶数的平方组成的list</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p>筛选条件跟在for循环后面，筛选for循环生成的元素，让只有符合条件的元素进入<code>结果元素计算式</code>中计算，组成最终的list</p>
<h2 id="两层循环的列表生成式"><a href="#两层循环的列表生成式" class="headerlink" title="两层循环的列表生成式"></a>两层循环的列表生成式</h2><p>需求：列出两个list里元素的两两一起的所有组合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[n + m <span class="keyword">for</span> n <span class="keyword">in</span> [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>] <span class="keyword">for</span> m <span class="keyword">in</span> [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>]]</span><br><span class="line">[<span class="string">'aA'</span>, <span class="string">'aB'</span>, <span class="string">'aC'</span>, <span class="string">'aD'</span>, <span class="string">'bA'</span>, <span class="string">'bB'</span>, <span class="string">'bC'</span>, <span class="string">'bD'</span>, <span class="string">'cA'</span>, <span class="string">'cB'</span>, <span class="string">'cC'</span>, <span class="string">'cD'</span>, <span class="string">'dA'</span>, <span class="string">'dB'</span>, <span class="string">'dC'</span>, <span class="string">'dD'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>根据打印结果知道，其实就是循环嵌套。这是二层嵌套，其实也可以有n层嵌套，可以试试。下面是三次for循环，可以自己试试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[n + m + x <span class="keyword">for</span> n <span class="keyword">in</span> [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>] <span class="keyword">for</span> m <span class="keyword">in</span> [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'1234'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="多个变量的列表生成式"><a href="#多个变量的列表生成式" class="headerlink" title="多个变量的列表生成式"></a>多个变量的列表生成式</h2><p>嵌套循环其实就是多个变量的列表生成式，一层循环的多个变量同样适用。比如迭代(遍历)dict，同时迭代出key-value，然后组成list</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[str(k) + v <span class="keyword">for</span> k,v <span class="keyword">in</span> &#123;<span class="number">1</span>:<span class="string">'a'</span>, <span class="number">2</span>:<span class="string">'b'</span>, <span class="number">3</span>:<span class="string">'c'</span>, <span class="number">4</span>:<span class="string">'d'</span>&#125;.items()]   <span class="comment">#str()是类型转换，迭代出来的k是int类型，要想与字符串拼接要先转成str类型</span></span><br><span class="line">[<span class="string">'1a'</span>, <span class="string">'2b'</span>, <span class="string">'3c'</span>, <span class="string">'4d'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>列表生成式只能生成有一定规律的list，比如1-10的偶数平方list，1-100中能被3整除的list。每个元素都是能通过算法计算出来的。</p>
<p>当用到一个list时，为节省存储空间，不用创建出完整的list再去使用，可以在循环中不断推算出后面的元素。类似iOS中的UItableView，只创建显示到屏幕上的cell，在滑动过程中再去创建设置cell(其实是拿内存中闲置的cell，cell的循环机制)。这种边循环边计算的机制称为<code>生成器(generator)</code></p>
<h2 id="创建生成器1"><a href="#创建生成器1" class="headerlink" title="创建生成器1"></a>创建生成器1</h2><p>创建一个<code>generator</code>方法很多，其中一种只要把生成式的<code>[]</code>换成<code>()</code>即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>)]             <span class="comment">#列表生成式创建list</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>))				<span class="comment">#创建generator</span></span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1025e08e0</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="遍历生成器元素"><a href="#遍历生成器元素" class="headerlink" title="遍历生成器元素"></a>遍历生成器元素</h2><p>生成器是边循环边计算元素的，那怎么打印其中每个元素呢？有一个函数<code>next()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1025e0938</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>每次调用<code>next(g)</code>的时候，计算出下一个元素的值，当超出list的长度时，就会抛出异常<code>StopIteration(停止迭代)</code></p>
<p>这种方法读取元素实在是太low了，generator也是可迭代对象，完全可以用for循环迭代</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> z <span class="keyword">in</span> g:</span><br><span class="line"><span class="meta">... </span>    print(z)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="创建生成器2"><a href="#创建生成器2" class="headerlink" title="创建生成器2"></a>创建生成器2</h2><p>有一种数列跟生成器运行机制类似，就是<code>斐波拉契数列</code>，除了开始的两个1，每个数都是前两个数的和。这个数列就是边循环边计算出元素的。</p>
<p>可以用函数打印这样的一个数列，输出指定位数的<code>斐波拉契数列</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(num)</span>:</span></span><br><span class="line">	n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> n &lt; num:</span><br><span class="line">		print(b)</span><br><span class="line">		a, b = b, a + b</span><br><span class="line">		n = n + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="插曲-有趣的赋值方式"><a href="#插曲-有趣的赋值方式" class="headerlink" title="插曲:有趣的赋值方式"></a>插曲:有趣的赋值方式</h3><p>这里有一种很有趣的赋值方式，在oc和java中看不到。就是上面函数中的<code>n, a, b = 0, 0, 1</code>和<code>a, b = b, a + b</code>，这是一种同时赋值的方法，<code>=</code>右边的值赋值给<code>=</code>左边相应位置的参数，每个参数赋值是同时进行的，他们的值都是这条赋值式上面时获得的值。</p>
<p>比如<code>a, b = b, a + b</code>,在赋值的时候，<code>a = b</code> 和 <code>b = a + b</code>是同时进行的，最终的结果都是在<code>a = 1, b = 2</code>的前提下得到的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = b, a + b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>在其他语言中，这种赋值要引入第三变量。不然第二条赋值结果会因为第一条赋值操作而改变。</p>
<hr>
<p>上文中的<code>test(num)</code>函数变为生成器很简单，只需要把函数的<code>print(b)</code>换成<code>yield b</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(num)</span>:</span></span><br><span class="line">	n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> n &lt; num:</span><br><span class="line">		<span class="keyword">yield</span> b</span><br><span class="line">		a, b = b, a + b</span><br><span class="line">		n = n + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果一个函数定义中包含了关键字<code>yield</code>，那么这个函数不再是一个普通的函数，而是一个生成器</p>
<p>调用结果，返回的是一个generator对象:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test(<span class="number">9</span>)</span><br><span class="line">&lt;generator object test at <span class="number">0x101f0f8e0</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="生成器的执行原理"><a href="#生成器的执行原理" class="headerlink" title="生成器的执行原理"></a>生成器的执行原理</h3><p>在函数中添加了<code>yield</code>，这个函数就变成了生成器。这时就改变了Python函数的执行顺序，Python函数是顺序执行的，遇到return或最后一行语句就返回。如果变成了生成器，执行顺序就变成了遇到<code>yield</code>返回，下次执行会从上次返回<code>yield</code>的位置处继续执行</p>
<p>例如定义函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">'a'</span></span><br><span class="line">	print(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">'b'</span></span><br><span class="line">	print(<span class="number">3</span>)</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">'c'</span></span><br><span class="line">	print(<span class="number">4</span>)</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">'d'</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">'END'</span></span><br></pre></td></tr></table></figure>
<p>执行调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>test()</span><br><span class="line">&lt;generator object test at <span class="number">0x101ae08e0</span>&gt;   <span class="comment">#test()函数是生成器generator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(a)     <span class="comment">#第一次调用</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(a)     <span class="comment">#第二次调用</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(a)     <span class="comment">#第三次调用</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(a)     <span class="comment">#第四次调用</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="string">'d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(a)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration: END</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>和第一种创建的生成器一样，用for循环遍历该生成器 test()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> test():</span><br><span class="line"><span class="meta">... </span>    print(n)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">a</span><br><span class="line"><span class="number">2</span></span><br><span class="line">b</span><br><span class="line"><span class="number">3</span></span><br><span class="line">c</span><br><span class="line"><span class="number">4</span></span><br><span class="line">d</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>发现了一个问题，for循环遍历拿不到<code>return</code>的返回值<code>END</code>。看上面的<code>next(a)</code>调用，最后超出范围时抛出的错误<code>: END</code>， <code>END</code>在这里面。</p>
<p>其实生成器generator的return值在异常错误<code>StopIteration</code>的<code>value</code>值里</p>
<p>用循环遍历<code>test()</code>，并捕获异常，拿到<code>return</code>返回的<code>END</code>值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            x = next(a)</span><br><span class="line"><span class="meta">... </span>            print(x)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>            print(e.value)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">a</span><br><span class="line"><span class="number">2</span></span><br><span class="line">b</span><br><span class="line"><span class="number">3</span></span><br><span class="line">c</span><br><span class="line"><span class="number">4</span></span><br><span class="line">d</span><br><span class="line">END</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>总结：generator是在循环过程中不断计算出下一个元素的值，并在适当条件结束循环。对于函数改为的generator遇到return或者到函数的最后一行语句就是结束generator的指令。就是<strong>函数结束，generator结束</strong></p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>可以直接作用于for循环的对象为可迭代对象: <code>Iterable</code></p>
<p>可迭代对象有：<code>list(数组)</code>、<code>tuple(元组)</code>、<code>dict(字典)</code>、<code>set(key的集合)</code>、<code>str(字符串)</code>、<code>generator(生成器/带yiel的函数)</code></p>
<p>引入<code>collections</code>模块里的<code>Iterable</code> 可以判断一个对象是否是<code>Iterable(可迭代对象)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">100</span>, Iterable)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>可迭代对象里的<code>generator</code>，不但可以作用于for循环，还可以被<code>next()</code>不断调用并返回下一个值，直到抛出错误<code>StopIteration</code>。这种可以被<code>next()</code>函数调用不断返回下一个值得对象被称为迭代器<code>Iterator</code></p>
<p>引入<code>collections</code>模块里的<code>Iterator</code> 可以判断一个对象是否是<code>Iterator(迭代器)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterator)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterator)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">10</span>, Iterator)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>可迭代对象里的<code>生成器generator</code>是<code>Iterator迭代器</code></p>
<p>其他的<code>list(数组)</code>、<code>tuple(元组)</code>、<code>dict(字典)</code>、<code>set(key的集合)</code>、<code>str(字符串)</code> 虽然是<code>可迭代对象Iterable</code>，但不是<code>Iterator(迭代器)</code></p>
<p>可以用<code>iter()</code>函数把这些可迭代对象变为迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter(&#123;&#125;), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter([]), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter(<span class="number">10</span>), Iterator)   <span class="comment">#int类型连可迭代对象都不是，无法转为迭代器</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'int'</span> object <span class="keyword">is</span> <span class="keyword">not</span> iterable</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>为什么<code>list</code>这些可迭代对象不是迭代器呢？因为迭代器<code>Iterator</code>是一个数据流，可以存放无限大的数据，只是一个有序序列，不可能知道他的长度，只能不断<code>next()</code>计算下一个数据，只有在需要下一个数据的时候才去计算，是一种惰性计算。而<code>list</code>等这类可迭代对象都是可知长度的，不能<code>next()</code>循环计算下一个值。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python笔记2-函数</title>
    <url>/2016/07/02/Python2/</url>
    <content><![CDATA[<h2 id="一些函数举例"><a href="#一些函数举例" class="headerlink" title="一些函数举例"></a>一些函数举例</h2><a id="more"></a>

<ul>
<li><p>绝对值 abs(-1)</p>
</li>
<li><p>最大值 max(1,2,3)</p>
</li>
<li><p>类型转换 int(‘123’)  float(‘12.3’) str(100) bool(1)</p>
</li>
<li><p>整数转十六进制 hex(10)</p>
</li>
</ul>
<p>给函数起别名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = abs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>在Python交互环境中自定义函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">myAbs</span><span class="params">(x)</span>:</span>       <span class="comment">#def是定义函数的关键字 myAbs是函数名 x是参数</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:      <span class="comment">#注意要缩进四个空格，不然会自定义失败</span></span><br><span class="line"><span class="meta">... </span>         <span class="keyword">return</span> x   <span class="comment">#同样要缩进，if判断语句的写法，代码块</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>         <span class="keyword">return</span> -x</span><br><span class="line"><span class="meta">... </span>					 <span class="comment">#两个回车，退出函数编辑</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myAbs(<span class="number">-5</span>)			 <span class="comment">#调用函数</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myAbs(<span class="number">5</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>在.py文件中自定义函数并运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line">print(my_abs(<span class="number">10</span>))		<span class="comment">#调用函数，并打印出结果</span></span><br><span class="line">print(my_abs(<span class="number">-10</span>))</span><br></pre></td></tr></table></figure>

<p>将函数封装在一个.py文件，并在Python交互环境中调用</p>
<p>将下面函数代码写入一个.py文件，并将该文件命名为myabs.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>

<p>python 进入Python交互环境</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> myabs <span class="keyword">import</span> my_abs  <span class="comment">#引入函数  myabs是文件名不带.py， my_abs是文件里的函数名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_abs(<span class="number">-5</span>)     			   <span class="comment">#调用函数</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="空函数与pass语句"><a href="#空函数与pass语句" class="headerlink" title="空函数与pass语句"></a>空函数与pass语句</h2><p>自定义一个空函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nodef</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>pass 就是什么都不做，用作占位符，能让程序运行起来，不报错。没有它会有语法错误</p>
<p>用Sublime text文本编辑器写好多语句时，都会自动加上pass</p>
<h2 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h2><p>自定义的my_abs()函数相比于系统的abs函数还是不一样。比如传入错误类型的参数’a’</p>
<p>两者报错不同。系统abs函数会检查出参数错误，而自定义的my_abs 是if判断条件错误。所以要增加参数类型检查，判断如果是不符合的参数类型，抛出异常</p>
<p>检查数据类型用isinstance()函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abss</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (int, float)):   <span class="comment">##如果不是int和float类型的话，抛出类型异常</span></span><br><span class="line">	<span class="keyword">raise</span> TypeError(<span class="string">'输入类型错误'</span>)</span><br><span class="line"><span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>

<p><strong>写这个的时候遇到了一个问题，一个看代码很难发现的问题</strong></p>
<p>错误提示如下：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">TabError:</span> inconsistent use of tabs <span class="keyword">and</span> spaces <span class="keyword">in</span> indentation</span><br><span class="line"><span class="meta">#翻译: 在缩进制表符和空格的使用不一致</span></span><br></pre></td></tr></table></figure>

<p>在我进行缩进的时候，不同位置用了不同的缩进方式，四个空格和tab共用了，然后就报错了。我尝试了一下，全部使用四个空格缩进和全部使用tab缩进都可以，但是不能混合使用。</p>
<h2 id="函数多个返回值"><a href="#函数多个返回值" class="headerlink" title="函数多个返回值"></a>函数多个返回值</h2><p>函数可以有多个返回值，return 时用分号分割开来每个返回值即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abss</span><span class="params">(x)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (int, float)):</span><br><span class="line">		<span class="keyword">raise</span> TypeError(<span class="string">'输入类型错误'</span>)</span><br><span class="line">	<span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> x, x + <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> -x, x + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>返回结果 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_abss(<span class="number">10</span>)</span><br><span class="line">(<span class="number">10</span>, <span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p>其实返回的就是一个tuple</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>定义函数需要写函数名和参数</p>
</li>
<li><p>做必要的参数数据类型检查</p>
</li>
<li><p>随时随地都可以return结果</p>
</li>
<li><p>可以有多个返回值，以tuple的形式返回</p>
</li>
<li><p>函数执行完毕也没有return，会return None</p>
</li>
</ul>
<h1 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h1><h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><p>计算某一个数的平方值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPower</span><span class="params">(a)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a * a</span><br><span class="line">	</span><br><span class="line"><span class="comment">#参数a就是一个位置参数</span></span><br></pre></td></tr></table></figure>

<p>另一种需求，我要计算 a的3次方、4次方、5次方…… 可以加一个参数，把函数改为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPower</span><span class="params">(a, n)</span>:</span></span><br><span class="line">	s = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">		n = n - <span class="number">1</span></span><br><span class="line">		s = s * a</span><br><span class="line">	<span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<p>这样就可以完成需求了。</p>
<p>但是，算平方是最常用的，在算平方的时候依旧输入两个参数 myPower(2, 2)，这样感觉很费劲。</p>
<p>Python中有一个叫默认参数的东西可以解决这个问题</p>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>指定某一个参数的默认值，如果这个参数不传值的话就用某个值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPower</span><span class="params">(a, n = <span class="number">2</span>)</span>:</span>  <span class="comment">#如果n没有传值，则n=2</span></span><br><span class="line">	s = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">		n = n - <span class="number">1</span></span><br><span class="line">		s = s * a</span><br><span class="line">	<span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<p>调用函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myPower(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myPower(<span class="number">2</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意点：有多个参数时，必须按参数必须在前面，默认参数在后面</strong></p>
<p>因为默认参数如果在必选参数前面的话，调用时输入参数，第一个参数无法确定是给默认参数的还是给必选参数的。</p>
<p>但是，只有一个参数的时候，可以把这个参数设置为默认参数。</p>
<hr>
<p><em>有两个默认参数的时候怎么办？</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classname</span><span class="params">(name, age, city = <span class="number">6</span>, gender = <span class="string">'Beijing'</span>)</span>:</span></span><br><span class="line">	print(name, age, city, gender)</span><br></pre></td></tr></table></figure>

<p>调用结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classname(<span class="string">'小明'</span>, <span class="number">10</span>)</span><br><span class="line">小明 <span class="number">10</span> <span class="number">6</span> Beijing</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classname(<span class="string">'小明'</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="string">'tianjing'</span>)</span><br><span class="line">小明 <span class="number">10</span> <span class="number">10</span> tianjing</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classname(<span class="string">'小明'</span>, <span class="number">10</span>, <span class="number">15</span>)</span><br><span class="line">小明 <span class="number">10</span> <span class="number">15</span> Beijing</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classname(<span class="string">'小明'</span>, <span class="number">10</span>, <span class="string">'shanghai'</span>)</span><br><span class="line">小明 <span class="number">10</span> shanghai Beijing</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>前三次调用都没有问题，最后一次有问题了。</p>
<p>有多个默认参数的时候，调用时按顺序写入参数没有问题，如果要跳过某个默认参数输入后面的默认参数，就要指定参数名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classname(<span class="string">'小明'</span>, <span class="number">10</span>, gender = <span class="string">'shanghai'</span>)</span><br><span class="line">小明 <span class="number">10</span> <span class="number">6</span> shanghai</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>默认参数还有一个注意点: <strong>默认参数必须为指向不可变的对象</strong></p>
<p>举例：以list为默认参数，设置函数。 给定一个list，添加’z’元素返回lsit。默认list为[‘a’]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addend</span><span class="params">(L = [<span class="string">'a'</span>])</span>:</span></span><br><span class="line">	L.append(<span class="string">'z'</span>)</span><br><span class="line">	<span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>

<p>调用结果为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>addend()</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'z'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>addend()</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'z'</span>, <span class="string">'z'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>addend()</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'z'</span>, <span class="string">'z'</span>, <span class="string">'z'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>addend()</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'z'</span>, <span class="string">'z'</span>, <span class="string">'z'</span>, <span class="string">'z'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>addend()</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'z'</span>, <span class="string">'z'</span>, <span class="string">'z'</span>, <span class="string">'z'</span>, <span class="string">'z'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>每次运行函数记住了上次的结果，叠加了内容</p>
<p>因为参数L 是一个变量，指向一个对象list [‘a’] , list是可变的，每次运行L指向的list都改变了，不再是默认参数[‘a’]</p>
<p>所以 <strong>默认参数必须指向不可变对象！！</strong></p>
<p>其实上述需求也是可以实现的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addend</span><span class="params">(L = None)</span>:</span></span><br><span class="line"><span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">	L = [<span class="string">'a'</span>]</span><br><span class="line">L.append(<span class="string">'z'</span>)</span><br><span class="line"><span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>

<p>调用结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>addend()</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'z'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>addend()</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'z'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>addend()</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'z'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>这种实现方式类似于oc中在方法内部处理某个参数的操作，如果某个参数传了nil，则参数初始化为某个值</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>计算多个数字的平方和，用list或者tuple包一组数，传入函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(num)</span>:</span></span><br><span class="line">	sum = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> num:</span><br><span class="line">		sum = sum + n * n</span><br><span class="line">	<span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>

<p>调用结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="number">14</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>可以用可变参数，实现并不需要用list或tuple包裹数字，直接传入数 calc(1,2,3)。 可变参数会在函数调用时自动组装为一个tuple</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*num)</span>:</span>			<span class="comment">#加一个*即可</span></span><br><span class="line">	sum = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> num:</span><br><span class="line">		sum = sum + n * n</span><br><span class="line">	<span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>

<p>调用结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">14</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>可变参数可以传入任意个参数包括0个。cals()也可以</strong></p>
<p><strong>可变参数一般要放到所有参数的最后面，如果可变参数后面还跟着其他参数，这些参数有独特的含义——命名关键字参数</strong></p>
<hr>
<p>这时如果有一组list或者tuple数据要计算平方和，nums = [1,2,3], 单个元素取出传入calc函数 calc(nums[0], nums[1], nums[2])，这样做肯定是可以的，但是太麻烦，如果list有一百个元素就疯了。如果把整个list传入的话又会报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Users/inspiry/Desktop/myabs.py"</span>, line <span class="number">7</span>, <span class="keyword">in</span> calc</span><br><span class="line">    sum = sum + n * n</span><br><span class="line">TypeError: can<span class="string">'t multiply sequence by non-int of type '</span>list<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>简单，传入list或者tuple的时候加一个*，</p>
<p>Python允许添加*号， 把list或tuple变为可变参数传入函数中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(*[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>

<p><strong>默认参数和可变参数的概念swift中也有，应该是借鉴Python吧</strong></p>
<h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>关键字参数是用两个星号(**)表示的，会在函数调用时自动组装为dict</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(name, age, **other)</span>:</span></span><br><span class="line">	print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, other)</span><br></pre></td></tr></table></figure>

<p>**other为关键字参数，可以传入任意个参数，也可以不传入。传入参数时是以key-value的方式传的</p>
<p>调用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="string">'mxd'</span>, <span class="number">10</span>)</span><br><span class="line">name: mxd age: <span class="number">10</span> other: &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="string">'mxd'</span>, <span class="number">18</span>, a = <span class="string">'a'</span>, b = <span class="number">20</span>)</span><br><span class="line">name: mxd age: <span class="number">18</span> other: &#123;<span class="string">'a'</span>: <span class="string">'a'</span>, <span class="string">'b'</span>: <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>

<p>类比可变参数可以把list添加一个*传入函数中作为参数，同样关键字参数也可以这样做。把一个dict 传入函数当做关键字参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>oth = &#123;<span class="string">'job'</span>: <span class="string">'ios'</span>, <span class="string">'book'</span>: <span class="string">'macbook pro'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="string">'mxd'</span>, <span class="number">18</span>, **oth)</span><br><span class="line">name: mxd age: <span class="number">18</span> other: &#123;<span class="string">'job'</span>: <span class="string">'ios'</span>, <span class="string">'book'</span>: <span class="string">'macbook pro'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>注意点: 函数 calc(name, age, **other) 中的other得到了一个oth指向的dict，得到的其实是oth的一份拷贝，在函数内对其改变操作，不会影响外面的oth</p>
<h2 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h2><p>命名关键字参数是给参数起名，关键字参数虽然以key-value的方式传入参数，给每个参数制定了key，但是这个key还是不能确定，调用者可以传入不受限制的关键字参数。</p>
<p>限制关键字参数的key，就是指定关键字参数的名字，就用到了命名关键字参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(name, *, age)</span>:</span></span><br><span class="line">	print(name, age)</span><br></pre></td></tr></table></figure>

<p>命名关键字参数的写法是以*作为分隔符，分号后面的参数为命名关键字参数。可以跟多个参数，def calc(name, *, age, other):  这时age 和 other都是命名关键字</p>
<p>调用时必须传入，且必须以 命名 = 内容 的key-value方式调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="string">'mxd'</span>, age = <span class="number">18</span>)</span><br><span class="line">mxd <span class="number">18</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>之前说可变参数要放到参数最后面，后面再跟参数的话就是命名关键字参数了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(name, *age, other, zz)</span>:</span></span><br><span class="line">	print(name, age, other, zz)</span><br></pre></td></tr></table></figure>

<p>other 和 zz 都是命名关键字了，必须传入，调用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="string">'mxd'</span>, <span class="number">18</span>, <span class="number">11</span>, other = <span class="string">'2'</span>, zz = <span class="number">3</span>)</span><br><span class="line">mxd (<span class="number">18</span>, <span class="number">11</span>) <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>命名关键字参数也可以指定参数默认值，指定other参数的默认值为’good’</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(name, *age, other = <span class="string">'good'</span>, zz)</span>:</span></span><br><span class="line">	print(name, age, other, zz)</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="string">'mxd'</span>, <span class="number">32</span>,<span class="number">22</span>,<span class="number">22</span>, zz = <span class="string">'a'</span>)</span><br><span class="line">mxd (<span class="number">32</span>, <span class="number">22</span>, <span class="number">22</span>) good a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="string">'mxd'</span>, <span class="number">10</span>, other = <span class="string">'no'</span>, zz = <span class="string">'b'</span>)</span><br><span class="line">mxd (<span class="number">10</span>,) no b</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h2><p><strong>5种参数：必选参数、默认参数、可变参数、关键字参数、命名关键字参数。在使用的时候如果有多种参数共同存在是，顺序必须为：必选参数、默认参数、可变参数、命名关键字参数、关键字参数</strong></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python笔记1-基础</title>
    <url>/2016/07/01/Python1/</url>
    <content><![CDATA[<h2 id="安装Python环境"><a href="#安装Python环境" class="headerlink" title="安装Python环境"></a>安装Python环境</h2><a id="more"></a>

<ul>
<li><p>在安装了Homebrew的前提下，终端命令brew install python3</p>
</li>
<li><p>安装Homebrew</p>
<pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre></li>
<li><p>安装完成之后输入 python  终端显示&gt;&gt;&gt;，  说明Python安装成功，进入了Python交互环境，输入Python代码回车得到执行结果</p>
</li>
<li><p>退出Python交互环境  exit() 回车。 或者直接关闭终端</p>
</li>
</ul>
<h2 id="第一个Python程序"><a href="#第一个Python程序" class="headerlink" title="第一个Python程序"></a>第一个Python程序</h2><p>在终端环境下，输入python 进入&gt;&gt;&gt;  Python交互环境</p>
<ul>
<li><p>打印hello world</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"hello world"</span>)</span><br><span class="line">或者</span><br><span class="line">print(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>数字计算，直接输入 100+33 回车 会得到133的结果，任何有效的数学计算都能算出来</p>
</li>
</ul>
<p>运行.py文件 (包含Python的代码是以.py为拓展名的文本文件，需要用Python解析器去执行该文件)</p>
<ul>
<li>终端中输入 python 文件名.py 回车，执行.py文件中的Python代码</li>
</ul>
<p><strong>注意点: 文本文件中的Python代码必须是执行代码，例如打印100+10，不能像终端&gt;&gt;&gt;Python交互环境中100+10这样写，而应该写为print(100+10),这样才能输出结果</strong></p>
<h2 id="Python代码文本执行"><a href="#Python代码文本执行" class="headerlink" title="Python代码文本执行"></a>Python代码文本执行</h2><h3 id="Python交互环境下执行代码文件"><a href="#Python交互环境下执行代码文件" class="headerlink" title="Python交互环境下执行代码文件"></a>Python交互环境下执行代码文件</h3><ul>
<li><p>创建一个文本文件hello.py, 文本文件里写print(“hello world”)。 终端cd切换到文件所在的目录。执行代码，终端会打印出hello world</p>
<pre><code>python hello.py</code></pre></li>
</ul>
<h3 id="直接运行-py文件，执行代码文件"><a href="#直接运行-py文件，执行代码文件" class="headerlink" title="直接运行.py文件，执行代码文件"></a>直接运行.py文件，执行代码文件</h3><ul>
<li><p>在终端中直接运行.py文件，不用写python。在Windows环境下不可以，在mac和Linux下是可以的。</p>
</li>
<li><p>更改文本文件hello.py里的代码</p>
<pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line">print(<span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure></code></pre></li>
<li><p>在终端中赋予hello.py执行权限</p>
<pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chmod a+x hello.py</span><br></pre></td></tr></table></figure></code></pre></li>
<li><p>直接运行hello.py</p>
<pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">./hello.py</span><br></pre></td></tr></table></figure></code></pre><h2 id="Python代码助手"><a href="#Python代码助手" class="headerlink" title="Python代码助手"></a>Python代码助手</h2></li>
</ul>
<p>python代码助手是在先输入Python代码，然后本机运行Python脚本执行代码。</p>
<p>脚本地址 <a href="https://raw.githubusercontent.com/michaelliao/learn-python3/master/teach/learning.py" target="_blank" rel="noopener">learning.py</a> 右键保存</p>
<p>在终端中 python learning.py 运行。显示 <strong>Ready for Python code on port 39093…</strong> 运行成功</p>
<p>问题： 提醒 <strong>Your current python is 2.7. Please use Python 3.4.</strong>  Mac上自带的Python版本是2.7，装了3.4，两个版本并存了，需要把2.7卸载掉，过或者把3.4放到path的前面。或者在输入执行脚本 ： python3 learning.py</p>
<p>可以使用 pyenv 或者 virtualenv 切换Python版本</p>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ul>
<li><p>输出字符串</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'hello world'</span>) 或者 print(<span class="string">'hello'</span>, <span class="string">'world'</span>)  </span><br><span class="line"><span class="comment">#结果 hello world</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输出计算结果</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">10</span>+<span class="number">10</span>)  <span class="comment">#20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输出字符串+计算结果</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'10+10='</span>, <span class="number">10</span>+<span class="number">10</span>) <span class="comment">#10+10= 20</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ul>
<li><p>输入操作</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = input()</span><br><span class="line">mxd</span><br><span class="line">print(name)   <span class="comment">#mxd</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有内容提醒的输入操作</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = input(<span class="string">'请输入名字'</span>)</span><br><span class="line">mxd</span><br><span class="line">print(<span class="string">'你好'</span> + name) <span class="comment">#你好 mxd</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Python的语法格式"><a href="#Python的语法格式" class="headerlink" title="Python的语法格式"></a>Python的语法格式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是注释</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>每一行都是一个语句，不用加; 结尾。 当以:结尾时，第二行缩进为代码块，例如 if 语句</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">10</span>:</span><br><span class="line">	print(a)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(-a)</span><br></pre></td></tr></table></figure></li>
<li><p>注意点： 缩进要用4个空格，或者tab，但是绝对不能混用</p>
</li>
<li><p>Python区分大小写</p>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>python 的变量数据类型是可变的，不固定的，成为动态语言</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br><span class="line">print(a)</span><br><span class="line">a = <span class="string">"abc"</span></span><br><span class="line">print(a)</span><br><span class="line">	</span><br><span class="line"><span class="comment">#会打印出来</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<p>a的数据类型改变了。这是允许的。但是在Java oc中是不可以的。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>在Python中，通常用全部大写的变量名表示常量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PI = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>

<p>其实实际意义上 PI 仍然是一个变量，Python不会保证PI的值不会被改变。全部大写只是一个习惯写法，改变PI的值也没问题</p>
<h3 id="地板除"><a href="#地板除" class="headerlink" title="地板除"></a>地板除</h3><p>在Python中有两种除法， 浮点型的除法 /    整数除法 //</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">10</span> / <span class="number">3</span>)</span><br><span class="line"><span class="comment">#得出结果 3.3333333333333335</span></span><br></pre></td></tr></table></figure>

<p>即使除数和被除数都是整型，除完之后也是浮点型。即便是能整除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">9</span> / <span class="number">3</span>)</span><br><span class="line"><span class="comment">#得出结果 3.0</span></span><br></pre></td></tr></table></figure>
<p>要想得到跟oc中 / 除法一样的整型相除得整型的除法结果，就要用地板除 //</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">10</span>//<span class="number">3</span>)</span><br><span class="line">print(<span class="number">9</span>//<span class="number">3</span>)</span><br><span class="line"><span class="comment">#两个打印结果都是  3</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><p>字符串类型 str</p>
<p>% 运算符用作格式化字符串，  %s 字符串， %d 整数， %f 浮点数。 如果不确定数据类型，%s 可以用作任何数据类型，它会把别的数据类型转为字符串</p>
<h2 id="list-和-tuple"><a href="#list-和-tuple" class="headerlink" title="list 和 tuple"></a>list 和 tuple</h2><h3 id="list-数组"><a href="#list-数组" class="headerlink" title="list 数组"></a>list 数组</h3><p>list是一种有序集合，就是数组。list相比于oc中的NSMutableArray有很多独有的特性。比NSMutableArray更加易操作，有更多的功能。swift中新的数据类型元组貌似就借鉴了Python中的list部分功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classname = [<span class="string">'abc'</span>, <span class="string">'xyz'</span>,<span class="string">'bob'</span>]</span><br></pre></td></tr></table></figure>
<p>获取list元素个数 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">len(classname)</span><br></pre></td></tr></table></figure>

<p>角标索引访问某个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classname[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>Python有一种比较特殊的元素访问方式，以负数做索引。 比如 classname[-1], 这是访问最后一个元素，也就是倒数第一个元素。</p>
<p>以类推，访问倒数第二个元素 classname[-2], 访问倒数第三个元素classname[-3]</p>
<p>当然数组角标索引不能越界！</p>
<p>list数组是可变的</p>
<hr>
<p>追加元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classname.append(<span class="string">'admin'</span>)</span><br><span class="line">	</span><br><span class="line">print(classname) <span class="comment">#结果['abc', 'xyz', 'bob', 'admin']</span></span><br></pre></td></tr></table></figure>

<p>插入元素，插入到索引为1的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classname.insert(<span class="number">1</span>, <span class="string">'jack'</span>)</span><br></pre></td></tr></table></figure>

<p>删除指定索引的list元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classname.pop(<span class="number">0</span>)</span><br><span class="line">	</span><br><span class="line"><span class="comment">#删除最后一个元素</span></span><br><span class="line">classname.pop()</span><br></pre></td></tr></table></figure>

<p>替换某个索引的元素值，直接给该索引元素赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classname[<span class="number">0</span>] = <span class="string">'mak'</span></span><br></pre></td></tr></table></figure>

<p>list内的元素类型也可以不同，不像oc似的必须为对象类型。而且，也可以编辑某一个元素，改变其数据类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classname = [<span class="string">'abc'</span>, <span class="number">123</span>, <span class="literal">True</span>]</span><br><span class="line">	</span><br><span class="line">classname[<span class="number">1</span>] = <span class="string">'efg'</span></span><br></pre></td></tr></table></figure>
<p>list嵌套， list里的元素也可以是一个list。 可以用类似oc中字典一层一层往下找的办法，获取list里面list里的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classname = [<span class="string">'abc'</span>, <span class="number">123</span>, <span class="literal">True</span>, [<span class="number">1</span>, <span class="string">'bc'</span>, <span class="string">'ff'</span>]]</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 获取打印 ff。 classname这个list里的第三个元素里的第二个元素</span></span><br><span class="line">print(classname[<span class="number">3</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>空list也是可以的，长度为0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classname = []</span><br><span class="line">	</span><br><span class="line">len(classname)  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>

<h3 id="tuple元组"><a href="#tuple元组" class="headerlink" title="tuple元组"></a>tuple元组</h3><p>tuple 不可变，创建时用(), 创建时内容就要确定下来，而且后面不能更改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuples = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>也可以创建空的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuples = ()</span><br></pre></td></tr></table></figure>

<p>注意点是创建只有一个元素的tuple</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果写成这样的话，会容易误解，因为()也是数学公式中的小括号，这种情况下，Python会当做小括号处理</span></span><br><span class="line">	</span><br><span class="line">tuples = (<span class="number">1</span>) 就变成了 tuples = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果想创建一个只有一个元素的tuple，需要这样写:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuples = (<span class="number">1</span>,)</span><br><span class="line">	</span><br><span class="line"><span class="comment">#打印出来的也是(1,)  这是为了避免出现歧义</span></span><br></pre></td></tr></table></figure>

<p>tuple 元素的可变现象， 不是说tuple只要定义了就不能变了吗？为什么还有可变现象？看下面代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuples = (<span class="number">1</span>,<span class="number">2</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">tuples[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'x'</span></span><br><span class="line">tuples[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'y'</span></span><br><span class="line">tuples[<span class="number">2</span>].append(<span class="string">'f'</span>)</span><br><span class="line">print(tuples)</span><br><span class="line">	</span><br><span class="line"><span class="comment">#打印出来的tuples是  (1, 2, ['x', 'y', 'f'])</span></span><br></pre></td></tr></table></figure>

<p>表面上看tuple内的元素变了，其实并不是tuple变了，而是tuple里面的list变了。tuple内部每个元素的指向并没有发生变化，指向1的还是指向1，指向2的还是指向2，指向list的还是指向list</p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>if else 的条件判断，执行流程肯定是国际惯例，区别只是写法不同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span>:</span><br><span class="line">    print(a)</span><br><span class="line">    print(<span class="string">'a是正整数'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(-a)</span><br></pre></td></tr></table></figure>
<dl><dt>缩进去的是代码块，可以有多行，都是一块代码。</dt><dd>千万不能少些，缩进千万不能省略，而且建议用四个空格缩进。</dd></dl><hr>
<p>还有一种写法不同，就是else if 需要简写为elif</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">200</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">10</span>:</span><br><span class="line">    print(<span class="string">'小于10'</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt; <span class="number">100</span>:</span><br><span class="line">    print(<span class="string">'大于100'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'其他'</span>)</span><br></pre></td></tr></table></figure>

<p>if判断条件简写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> a:</span><br><span class="line">    print(<span class="string">'a非零'</span>)</span><br></pre></td></tr></table></figure>

<p>非零、非空即真的理念同样适用于Python。只是不适用于swift，其他的貌似都适应吧</p>
<hr>
<p>一个错误的判断条件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = input(<span class="string">'请输入一个数字'</span>)</span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span>:</span><br><span class="line">	print(<span class="string">'正数'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">'负数'</span>)</span><br></pre></td></tr></table></figure>
<p>报错了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"./hello.py"</span>, line <span class="number">5</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">0</span>:</span><br><span class="line">TypeError: unorderable types: str() &gt; int()</span><br></pre></td></tr></table></figure>
<p>一个str类型的和一个int类型的做 &gt; 比较， 所以报错了。</p>
<p>用int()函数将str类型转为整数类型，再比较就OK了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = int(input(<span class="string">'请输入一个数字'</span>))</span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span>:</span><br><span class="line">	print(<span class="string">'正数'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">'负数'</span>)</span><br></pre></td></tr></table></figure>
<p>但这时如果输入一个字符a，还是会报错。 后面会讲到错误和调试，检查并捕获程序运行时的错误。</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for-in 循环"></a>for-in 循环</h3><p>for-in 遍历list里的每一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = [<span class="string">'xiao'</span>, <span class="string">'ming'</span>, <span class="string">'haha'</span>]	</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> name:</span><br><span class="line">	print(a)</span><br></pre></td></tr></table></figure>

<p>range()函数。 可以生成一个整数数列，比如 range[5] 是从0到5(不包括5)的整数</p>
<p>把range()函数生成的数列转为list  list(range(5))</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(list(range(<span class="number">5</span>)))</span><br><span class="line"><span class="comment">#打印出来是 [1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">10</span>:</span><br><span class="line">	print(n)</span><br><span class="line">	n = n+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>注意点： n++不适用，会语法报错。 ++n会死循环输出0</p>
<h2 id="字典dict-和-set"><a href="#字典dict-和-set" class="headerlink" title="字典dict 和 set"></a>字典dict 和 set</h2><h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>dict 字典是以key-value键值方式存储数据的一种集合。oc中的字典NSDictionary。Java中一般称为key-value数组。</p>
<p>初始化一个dict</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'xiaoming'</span>: <span class="number">10</span>, <span class="string">'xiaohua'</span>: <span class="number">20</span>, <span class="string">'xiaoli'</span>: <span class="string">'dd'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>一个key只能对应一个value，相同的key后面的值会把前面的值冲掉</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'xiaoming'</span>: <span class="number">10</span>, <span class="string">'xiaohua'</span>: <span class="number">20</span>, <span class="string">'xiaoming'</span>: <span class="number">80</span>&#125;</span><br><span class="line">print(d)</span><br><span class="line"><span class="comment">#这句打印出来的结果为： &#123;'xiaoming': 'dd', 'xiaohua': 20&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以根据key修改对应value的值，也可以增加新的key-value键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'xiaoming'</span>: <span class="number">10</span>, <span class="string">'xiaohua'</span>: <span class="number">20</span>, <span class="string">'xiaoli'</span>: <span class="string">'dd'</span>&#125;</span><br><span class="line">d[<span class="string">'xiaoli'</span>] = <span class="number">30</span>  <span class="comment">#修改xiaoli 为 30</span></span><br><span class="line">d[<span class="string">'xiaowang'</span>] = <span class="number">80</span> <span class="comment">#新增一个数据xiaowang: 80</span></span><br></pre></td></tr></table></figure>

<p>根据不存在的key读取value会报错，判断key是否存在的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">'xiaoming'</span> <span class="keyword">in</span> d:</span><br><span class="line">    print(<span class="string">'yes'</span>)</span><br><span class="line"><span class="comment">#判断'xiaoming'是不是dict d 中的key  'xiaoming' in d 如果是True，如果不是False</span></span><br></pre></td></tr></table></figure>
<p>第二种判断key是否存在的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(d.get(<span class="string">'xiaoming'</span>))</span><br><span class="line"><span class="comment">#如果有xiaoming这个key 则返回对应的value，如果没有则返回None。</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">#或者如果没有返回指定的值</span></span><br><span class="line">print(d.get(<span class="string">'xiaoming'</span>, <span class="number">-1</span>))</span><br><span class="line"><span class="comment">#如果没有，返回指定的-1</span></span><br></pre></td></tr></table></figure>

<p>删除某个key-value键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d.pop(<span class="string">'xiaoming'</span>)</span><br><span class="line"><span class="comment">#如果key不存在，也会报错</span></span><br></pre></td></tr></table></figure>

<p><strong>注意: dict内部数据的顺序跟key放入顺序没有关系。是无序的</strong><br><strong>注意: dict的key必须为不可变对象，只要不可变就行(数字也行)。list是可变的，不能作为key</strong></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set是一组key的集合，没有value。之所以说它是一组key，是因为set里面存储的东西不重复、不可变、无序</p>
<p>创建set， 需要提供一个list作为输入集合。但是set里面的元素顺序跟list元素顺序没有关系。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>单个添加key的方法, 不能一次添加多个。允许添加重复的key，但是无效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.add(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>删除元素，删除无效的key会报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.remove(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>set的不重复特点可以做两个set的交集并集操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line">w = set([<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>])</span><br><span class="line">	</span><br><span class="line">print(s &amp; w, s | w) <span class="comment">#打印的是交集 和 并集</span></span><br></pre></td></tr></table></figure>

<p>set内的元素也是不可变的，不能存放list</p>
<h3 id="不可变对象的永远不可变性"><a href="#不可变对象的永远不可变性" class="headerlink" title="不可变对象的永远不可变性"></a>不可变对象的永远不可变性</h3><p>字符串是不可变的对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'abc'</span>				<span class="comment">#创建字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.replace(<span class="string">'a'</span>, <span class="string">'A'</span>)    <span class="comment">#将字符串中的a字符替换为A</span></span><br><span class="line"><span class="string">'Abc'</span>						<span class="comment">#得到结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'abc'</span>						<span class="comment">#打印a还是'abc'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>为什么a的值没有改变？</p>
<p>其实内存中是这样运行的，a是一个变量，’abc’是字符串对象，a这个变量指向了’abc’字符串对象。</p>
<p>执行 a.replace(‘a’, ‘A’) 操作时，replace方法作用于字符串对象’abc’, ‘abc’是不可变的字符串对象，replace改变不了其中某个字符，其实是创建了一个新的字符串’Abc’返回了。</p>
<p>下面代码说明了这个原理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'abc'</span>					<span class="comment">#创建字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.replace(<span class="string">'a'</span>, <span class="string">'A'</span>)		<span class="comment">#将字符串中的a字符替换为A  用b指向这个新串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">'Abc'</span>							<span class="comment">#打印b是'Abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'abc'</span>							<span class="comment">#打印a是'abc'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>对于不变的对象，调用任一方法操作对象，对象自身内容都不会改变，这些方法会创建新的对象并返回。这样保证了不可变对象本身的永远不可变性</strong></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS的cookie使用</title>
    <url>/2016/01/27/ioscookie/</url>
    <content><![CDATA[<p>cookie是网络会话过程中记录客户端用户身份的一段文本信息。</p>
<p>http协议是一种无状态协议，每次数据交换都是一次单独的会话链接。一次数据交换结束，链接断开，再次交换数据，就需要重新链接。服务器无法从链接上跟踪客户端信息。cookie弥补了http协议的不足。</p>
<a id="more"></a>

<p>在网站访问中，cookie用的非常频繁。</p>
<p>客户端开发中，用到cookie的机会比较少。但是cookie是一直存在的，只是我们不用而已。</p>
<p>http请求，cookie会一直存在，任何一次http请求都会携带cookie到服务端。有时候我们可以把cookie作为识别用户身份的参数。而不必将uid放到请求参数中传递给服务器。</p>
<p><strong>保存cookie</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray *cookies &#x3D; [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookiesForURL:[NSURL URLWithString:@&quot;接口地址&quot;]];</span><br><span class="line">NSData *data &#x3D; [NSKeyedArchiver archivedDataWithRootObject:cookies];</span><br><span class="line">[[NSUserDefaults standardUserDefaults] setObject:data forKey:@&quot;UserDefaultsCookie&quot;];</span><br></pre></td></tr></table></figure>

<p>在获取用户信息的接口请求时获取cookie，并用userDefaults保存到plist里。</p>
<p><strong>设置cookie</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSData *cookiesdata &#x3D; [[NSUserDefaults standardUserDefaults] objectForKey:kUserDefaultsCookie];</span><br><span class="line">if([cookiesdata length]) &#123;</span><br><span class="line">    NSArray *cookies &#x3D; [NSKeyedUnarchiver unarchiveObjectWithData:cookiesdata];</span><br><span class="line">    NSHTTPCookie *cookie;</span><br><span class="line">    for (cookie in cookies) &#123;</span><br><span class="line">        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>设置cookie在程序启动的时候设置</em></p>
<p>程序启动时设置cookie，此次程序运行所有的http请求都会携带这个cookie，服务器会拿到这个cookie，在session中比对，找到对应的用户，做相应操作。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>记个人博客时代的开始</title>
    <url>/2016/01/01/%E8%AE%B0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%97%B6%E4%BB%A3%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<p>接触编程有六年了，以敲代码为职业混饭吃也有三年了。既不是名牌大学毕业，也没就职过牛逼闪闪的金牌企业。作为一个默默无闻的码农，耕种着自己的一亩三分地，偶尔在CSDN或者简书上写篇博客，也不是什么高深技术，只是自己工作中遇到的一些问题。即便如此，也没积累下来，博客单薄的像是篇目录。</p>
<a id="more"></a>

<p>用了两天时间使用 Hexo + github 搭建了自己的博客，终于开启了个人博客时代，虽然有点晚，但比起明天还是早。搭建过程中也踩了不少坑，网络上有各种各样的解决办法，搭建博客的流程也烂大街般的多，我也不逞能再写一篇更烂的了。</p>
<p>一直以来想学的太多，关注的太杂，总是不能聚焦一点深入下去，行动的步伐跟不上大脑的冲动。还有之前敲代码时遇到的问题也没有记录完全，想钻研的技术一搁下就抛到脑后了。希望有自己的博客后，能专注一些，不贪多，不烂尾。</p>
<p>现在码代码，之前喜欢写文字。要不是我写的太烂，现在就不是码农而是作家了(说的好像代码写的不烂似的)。不管怎么说，还是很有兴趣写博客的，只是之前没坚持下来。</p>
<p>这个博客不会是纯技术，会掺杂其他的文，但还会以技术为主。目前也别期望出现高质量有深度的技术文，我也写不出来。算是我的个人学习博客，慢慢写，慢慢积累…</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>短文</tag>
        <tag>碎碎念</tag>
      </tags>
  </entry>
</search>
